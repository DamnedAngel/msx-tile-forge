#!/bin/env -S python3
# -*- coding: utf-8 -*-
import json
import platformdirs # type: ignore
import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser
from tkinter import filedialog
from tkinter import messagebox
from tkinter import simpledialog
from contextlib import suppress
import struct
import os
import math
import copy
import base64
import io
from PIL import Image, ImageTk

# --- Constants ---
APP_VERSION = "0.0.49"

ICON_IMAGE = r"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"
SPLASH_IMAGE = r"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7ExF0pPm+RHuJTeXm6291r7/ve/9hb/wf/hd/61/ii8HK74E/v1////2j/0X/0tzzMroIDcz68RMUYdO5/sfnleevvP0XQ+YuRwHdwGB3AhEwCgQLwkhNw1YeTBjwxxHnd/91i8+4eR4sjx9sufw0al7ec933pvY8wRUFF9CiJuJ1ypeCQKFUIHkJggQkQVk4Hru+7/ok57TO+fzetquu/P0vd75VXs9dYCIGRXZXW6UgAAVqEAB+RQFlodwPI5j9+z5FXWG8xkffvvicc4hz6Gb8zx752v7zg/oXrqy7enMcVwuFLBtkahJRWAmAR4MjKs+lw8h4/p8n73/QfP86ZNzPJ75XnN9ss/sqbwQnLvn5cmT737nOz/4g1//9/76X/+RH/71fAlY8ab75je/+RM/8RN/5xd+Qb26xIGADrhOccyeH3ywPf3qj/6WJ7/hd3z4a3/z/sAP4swxvCIExmsqX8RECAbG4OT4NfOt/++/8S9/9I2fP45jefqkc3j+wfsf/ab/+j/3tX/qX/rF731wEOFMtbuAysPKnbywBRg3EzfGjXcESdyFEDhzfHTd//Tx7Z/71/7Qt37uZ9559x24bk/E59/79g//47/36//d//E3vv3dyxhUjHjXLp8Xcad8incVd0JBIVFgx+U/xTf/H3/iD3/3//1/f/fdY30mF+rZ+99978d+19Pf+S99+P53jj4SZHCIiKiWuBkD4kYEjcIOUaATV27c/XD/9v/r6d/66e/93L/ns293OeW4dF5njgUE4axVgW/94jf/2d/7z/5v/43/DXfyRrvwpqt+6qf+5V/4xn+M02AixAu1nM/c/YjLO7/hx7/2E7/n8oP/4LPzUry/524snxQkN/FZQrwQLDe1CqKMX336DvNONT2XINjW03e/9fydv/3+s6eXAVRgdwGVh5VP2pKHGBAEEVCTmyCLh/KYZ2dfO7527T08yJ3JRbn4kfzi9fIfn0+eMtyEiwpUPAQVIB+LQF4RHHllN4VA9gw5n/sD735t96vWR5w7vntN6DxPLt999s4HHz196tgVegFQyYVEzWq5Ccyyw71wE3jEAagz7z79kR/3H/jtX//P/zPv//V/87t/8y8efe/yzlfJGAkW1AOC/p6v/z1//n/35//if+8v/K7/5n+bN92FN93P//zP/6v/6r/2la9+ddvltUltjqP2+r19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sSGxIw5+2MH9/f1VVQrEWpJDVkdn1+v//C9WD6xim1122WWDw8MRArOOIECAub8993hId0+3XCU5JFrUguCiiy6uqpId0mjUV6++5+67f3f38pV3/PbuX/36tuwmWxPMMrewEVmAEC1iJ4jNEpsjxHZ4zllnlRP1FCGJaYKIGBkZectb3sr2GBgYuOCCCw477PC99953//0PPOigg/ff/4C9p+z14//+AbNB4vfgaU9/eq0oBELcS+ro6Lhn+Yo3/vkb2B6XXXZZipDEBrKdc37WM58piY1UVcVs6OntfdGfvWhieERIiPWy3d7evnLFylNPe8rY+Chbk3O+6aabXvfG1zXq9aqqmElsWkQcddRRzWbTNs5Myzl39/R+94bvXvnlq9ged955x5ve9BfLlu22xx57POyghx/+iEcefsQjDz3siL/6P2+DxNYEs8tgM5NoMVPMTpIAR9IMCZDEZgg0JSQBMjItBouNnX7aU1OtcK7COUyYtXp6+y6//PKLL76YbfbSl770da99/a23/vLue1bd+du7brv99jt/97vf/va3ith7r72cS3aCJHIWYgOGzBRZzJ7ddt39cY8/vt6oI+GEEw6bCi9YvPiCz3zuQx/6INvmPe95z5VX/ZtdCQEya42OjB5wwP5Pf8bT7IqN5JyxmEG0iO3152/881A451AKIkiiCALonz//xu/edMIJj73llp+yRR/84Aef/ZwzJuoTOZu1hEIKSSFFSEhs5B8++tGJ0UnAOStXOGdBRFtH54tf8uI7f3sH22ZkZPiMM579T5/4xPDI2Pj4xNj4xOjYxMjY2PDw8EP22jOlNjBbFMwq4+wsI8QmiP8NEWE2SSA20tbWds45rxoaGIwI7iVSis7u7pe97Oyrr/4y2+Cd73zntdd+IxW1tva2jo72jo729o6O9vb2qqqOOeYxfX0L7czOEC1CbJLF7FHE+/72/ZMjI1JGmXUMqrL7F8x/wxv+/F3veIed2aIPfOADf/eh96NAgSXu02w0XvOa18ybt0AEM9lm9ixbtuwv//IvR4aGkFlPKCI1m2X/vL4f/NePDzviyDe/+U2rV69mIz/84Q8f+9jHfuj8v18zMGgjie2x//4HHHLIw+qTdaaYacadnZ3Dw6NPeMKJd/72TrbG9lOf+rRbf/ULpSLVaqlW1Nra2jva22pt7R21k046SarY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"

# ICON_IMAGE = r"iVBORw0"
# SPLASH_IMAGE = r"iVBORw0"

TILE_WIDTH = 8
TILE_HEIGHT = 8
EDITOR_PIXEL_SIZE = 30
VIEWER_TILE_SIZE = TILE_WIDTH * 2  # 16
PALETTE_SQUARE_SIZE = 20
NUM_TILES_ACROSS = 16
MAX_TILES = 256
SUPERTILE_GRID_DIM = 4 # This might become dynamic or project-specific later
SUPERTILE_DEF_TILE_SIZE = TILE_WIDTH * 4  # 32
SUPERTILE_SELECTOR_PREVIEW_SIZE = TILE_WIDTH * 4 # Used for an old ST selector calculation, review if still needed for that
NUM_SUPERTILES_ACROSS = 8 # Used for an old ST selector calculation, review if still needed for that
MAX_SUPERTILES = 65535 # MODIFIED - Increased from 256
DEFAULT_MAP_WIDTH = 32  # In supertiles
DEFAULT_MAP_HEIGHT = 24  # In supertiles
DEFAULT_WIN_VIEW_WIDTH_TILES = 32  # Default screen size
DEFAULT_WIN_VIEW_HEIGHT_TILES = 24  # Default screen size
MAX_WIN_VIEW_HEIGHT_TILES = 27  # Allow up to 27 for half-tile logic

MINIMAP_INITIAL_WIDTH = 256  # Default desired width of minimap window in pixels
MINIMAP_INITIAL_HEIGHT = 212  # Default desired height of minimap window in pixels

DRAG_THRESHOLD_PIXELS = 3 # Minimum pixels mouse must move to initiate a drag

RESERVED_BYTES_COUNT = 4 # NEW constant for clarity

# Unicode constant strings
UP = " \N{BLACK UP-POINTING TRIANGLE}"
DOWN = " \N{BLACK DOWN-POINTING TRIANGLE}"

# --- Constants for TileUsageWindow (can be placed near other constants or here) ---
TILE_USAGE_PREVIEW_SIZE = 24 # Pixel size for tile previews in the usage window

# --- Constants for SupertileUsageWindow (can be placed near other constants or here) ---
SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL = 1 # Example: Scale factor for display (1 means 1 screen pixel per MSX pixel)
SUPERTILE_USAGE_ROW_PADDING = 4
SUPERTILE_USAGE_COL0_OFFSET_GUESS = 20 # For tree indicator/padding in column #0
SUPERTILE_USAGE_MIN_IMAGE_MSX_W = 8    # Min MSX pixel width for ST content area to be visible

# --- Palette Editor Constants ---
MSX2_PICKER_COLS = 32
MSX2_PICKER_ROWS = 16
MSX2_PICKER_SQUARE_SIZE = 15
CURRENT_PALETTE_SLOT_SIZE = 30

# --- MSX2 Default Palette (Indices & Colors) ---
MSX2_RGB7_VALUES = [
    (0, 0, 0),
    (0, 0, 0),
    (1, 6, 1),
    (3, 7, 3),
    (1, 1, 7),
    (2, 3, 7),
    (5, 1, 1),
    (2, 6, 7),
    (7, 1, 1),
    (7, 3, 3),
    (6, 6, 1),
    (6, 6, 4),
    (1, 4, 1),
    (6, 2, 5),
    (5, 5, 5),
    (7, 7, 7),
]
BLACK_IDX = 1
MED_GREEN_IDX = 2
WHITE_IDX = 15

# --- Placeholder Colors ---
INVALID_TILE_COLOR = "#FF00FF"
INVALID_SUPERTILE_COLOR = "#00FFFF"

# --- Grid & Overlay Constants ---
GRID_COLOR_CYCLE = [
    "#FFFFFF",
    "#000000",
    "#FF00FF",
    "#00FFFF",
    "#FFFF00",
]  # White, Black, Magenta, Cyan, Yellow
GRID_DASH_PATTERN = (5, 3)  # 5 pixels on, 3 pixels off
WIN_VIEW_HANDLE_SIZE = 8  # Pixel size of resize handles
WIN_VIEW_HALF_ROW_COLOR = "#80808080"  # Semi-transparent grey for overscan area (adjust alpha if needed, format depends on tk version)

# --- MSX2 Color Generation ---
msx2_512_colors_hex = []
msx2_512_colors_rgb7 = []
for r in range(8):
    for g in range(8):
        for b in range(8):
            r_255 = min(255, r * 36)
            g_255 = min(255, g * 36)
            b_255 = min(255, b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            msx2_512_colors_hex.append(hex_color)
            msx2_512_colors_rgb7.append((r, g, b))

# --- Data Structures ---
tileset_patterns = [
    [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
tileset_colors = [
    [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
current_tile_index = 0
num_tiles_in_set = 1
selected_color_index = WHITE_IDX
last_drawn_pixel = None
supertiles_data = [
    [[0 for _ in range(SUPERTILE_GRID_DIM)] for _ in range(SUPERTILE_GRID_DIM)]
    for _ in range(MAX_SUPERTILES)
]
current_supertile_index = 0
num_supertiles = 1
selected_tile_for_supertile = 0
map_width = DEFAULT_MAP_WIDTH  # In supertiles
map_height = DEFAULT_MAP_HEIGHT  # In supertiles
map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
selected_supertile_for_map = 0
last_painted_map_cell = None
tile_clipboard_pattern = None
tile_clipboard_colors = None
supertile_clipboard_data = None

# --- Utility Functions ---
def get_contrast_color(hex_color):
    try:
        hex_color = hex_color.lstrip("#")
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
        return "#000000" if luminance > 0.5 else "#FFFFFF"
    except:
        return "#000000"

# --- Usage Window Classes -----------------------------------------------------------------------------------------------
class ColorUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Color Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = [] 
        self.current_sort_column_id = "slot_index" 
        self.current_sort_direction_is_asc = True   
        self.refresh_timer_id = None 
        self.style = ttk.Style()

        # --- Load saved configuration for this window ---
        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.load_specific_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col = saved_config.get('sort_column_id', self.current_sort_column_id)
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})
        
        self.current_sort_column_id = initial_sort_col
        self.current_sort_direction_is_asc = initial_sort_asc
        # --- End Load Config ---

        self._is_dragging_col_separator = False 
        self._treeview_refresh_timer_id = None 

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(0, weight=1) 
        main_frame.grid_columnconfigure(0, weight=1)

        self.data_column_ids_for_values = ("slot_index_val", "pixel_uses_val", "line_refs_val", "tile_refs_val")
        
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings", 
            height=16, 
            selectmode="browse"
        )

        # --- Column Configuration with loaded widths or defaults ---
        col0_default_w = 60 # Includes swatch + padding
        self.tree.column("#0", 
                         width=initial_col_widths.get("#0", col0_default_w), 
                         minwidth=30, stretch=tk.YES, anchor="w")
        self.tree.heading("#0", text="Color", command=lambda: self._sort_by_column("#0"))

        col_idx_default_w = 60
        self.tree.column("slot_index_val", 
                         width=initial_col_widths.get("slot_index_val", col_idx_default_w), 
                         minwidth=40, stretch=tk.YES, anchor="center")
        self.tree.heading("slot_index_val", text="Index", command=lambda: self._sort_by_column("slot_index"))

        col_counts_default_w = 80
        self.tree.column("pixel_uses_val", 
                         width=initial_col_widths.get("pixel_uses_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("pixel_uses_val", text="Pixel Uses", command=lambda: self._sort_by_column("pixel_uses_count"))

        self.tree.column("line_refs_val", 
                         width=initial_col_widths.get("line_refs_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("line_refs_val", text="Line Refs", command=lambda: self._sort_by_column("line_refs_count"))

        self.tree.column("tile_refs_val", 
                         width=initial_col_widths.get("tile_refs_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("tile_refs_val", text="Tile Refs", command=lambda: self._sort_by_column("tile_refs_count"))
        
        self.header_details = {
            "#0": {"id": "#0", "data_key": "slot_index"},
            "slot_index": {"id": "slot_index_val", "data_key": "slot_index"},
            "pixel_uses_count": {"id": "pixel_uses_val", "data_key": "pixel_uses_count"},
            "line_refs_count": {"id": "line_refs_val", "data_key": "line_refs_count"},
            "tile_refs_count": {"id": "tile_refs_val", "data_key": "tile_refs_count"}
        }
        self._update_header_sort_indicators()

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew") 

        color_swatch_preview_height = 16 
        self.treeview_style_name = f"ColorUsage_{id(self)}.Treeview"
        target_row_height_style = color_swatch_preview_height + 4 # Image size + small padding (increased slightly)
        
        try:
            self.style.configure(self.treeview_style_name, rowheight=target_row_height_style)
            self.style.map(self.treeview_style_name,
                      background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                      foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
            self.tree.configure(style=self.treeview_style_name)
        except tk.TclError as e_style:
            self.app_ref.debug(f"[DEBUG] ColorUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}.")

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press) 
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+') 
        self.tree.bind("<Configure>", self._on_tree_configure_debounced) 

        button_frame_container = ttk.Frame(main_frame) 
        button_frame_container.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None 
        if self.app_ref.debug_enabled:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)
        
        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: # Default size if no geometry saved or on first run
            self.update_idletasks() # Ensure widgets are created
            # Calculate required height: 16 items * row_height + header_height + scrollbar_height + padding
            header_h_approx = 30 # Approximate height of Treeview header
            scrollbar_h_approx = 20 # Approximate height for horizontal scrollbar
            total_h = (16 * target_row_height_style) + header_h_approx + scrollbar_h_approx + 20 # Overall padding
            total_w = col0_default_w + col_idx_default_w + (col_counts_default_w * 3) + 20 # Sum of col widths + scrollbar + padding
            self.geometry(f"{max(300,total_w)}x{max(300,total_h)}")


        self.app_ref.update_specific_window_config(self.window_class_name, is_open=True) # Mark as open
        self.after(10, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                widths["#0"] = self.tree.column("#0", "width")
                for col_id in self.data_column_ids_for_values:
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                self.app_ref.debug("[DEBUG] ColorUsageWindow: TclError getting column widths for save.")
        return {
            "sort_column_id": self.current_sort_column_id,
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def request_refresh(self, delay_ms=300): 
        if not self.winfo_exists(): 
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)

    def _perform_debounced_refresh(self): 
        self.refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _sort_by_column(self, column_clicked_key):
        data_sort_key = self.header_details.get(column_clicked_key, {}).get("data_key")
        if not data_sort_key:
            self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Invalid column key '{column_clicked_key}' for sorting.")
            return

        if self.current_sort_column_id == data_sort_key:
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else:
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = data_sort_key
            # Index column defaults to ascending, count columns default to descending
            if "count" in data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for key, details in self.header_details.items():
            col_id_for_tree = details["id"] 
            data_key_for_sort = details["data_key"]
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(col_id_for_tree)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "")

            if data_key_for_sort == self.current_sort_column_id:
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(col_id_for_tree, text=text_to_set)
            except tk.TclError: pass

    def refresh_data(self): 
        self.app_ref.debug(f"[DEBUG] ColorUsageWindow: refresh_data() called. Sort by: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            self.app_ref.debug("[DEBUG] ColorUsageWindow: Treeview not ready for refresh_data.")
            return
        
        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear()
        
        usage_data = [] 
        if hasattr(self.app_ref, '_calculate_color_usage_data'):
            try: usage_data = self.app_ref._calculate_color_usage_data() 
            except Exception as e:
                self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Error calling _calculate_color_usage_data: {e}")
                for i in range(16): 
                     usage_data.append({'slot_index': i, 'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF", 'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0})
        else: 
            self.app_ref.debug("[DEBUG] ColorUsageWindow: _calculate_color_usage_data not found for refresh.")
            for i in range(16): 
                usage_data.append({'slot_index': i, 'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF", 'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0})

        valid_sort_key = self.current_sort_column_id
        if usage_data and self.current_sort_column_id not in usage_data[0]: 
            self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Invalid sort column '{self.current_sort_column_id}' in refresh_data. Defaulting to slot_index.")
            valid_sort_key = 'slot_index' 
            self.current_sort_column_id = 'slot_index'
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators()
        elif not usage_data: self.app_ref.debug("[DEBUG] ColorUsageWindow: usage_data is empty, skipping sort.")
        
        if usage_data: 
            try: usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort: self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Error during sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        preview_image_size = 16 
        for item_data in usage_data: 
            slot_idx = item_data['slot_index']
            hex_color = item_data['current_color_hex']
            photo = None
            try:
                img_w, img_h = max(1, preview_image_size), max(1, preview_image_size)
                photo = tk.PhotoImage(width=img_w, height=img_h)
                hex_color_to_put = hex_color
                if not (isinstance(hex_color, str) and hex_color.startswith('#') and (len(hex_color) == 7 or len(hex_color) == 9)):
                    hex_color_to_put = "#FF00FF" 
                photo.put(hex_color_to_put, to=(0, 0, img_w, img_h))
                self._image_references.append(photo) 
            except tk.TclError as e_photo: 
                self.app_ref.debug(f"[DEBUG] ColorUsageWindow: TclError creating/putting color swatch for slot {slot_idx} color '{hex_color}': {e_photo}")
            
            item_iid = f"slot_{slot_idx}"
            self.tree.insert("", "end", 
                             iid=item_iid, 
                             image=photo if photo else '', 
                             text="", 
                             values=(f" {slot_idx}", 
                                     item_data['pixel_uses_count'], 
                                     item_data['line_refs_count'], 
                                     item_data['tile_refs_count']),
                             tags=('color_row',) 
                            )
        try: 
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('color_row', background=row_bg)
        except tk.TclError: pass

        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)


    def _on_item_selected(self, event):
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection() 
        if not selected_items: return
        item_id_str = selected_items[0]
        try:
            if item_id_str.startswith("slot_"): slot_index = int(item_id_str.split("_")[1])
            else: self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Could not parse slot_index from iid '{item_id_str}'."); return
        except (ValueError, IndexError) as e: self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Error parsing slot_index from iid '{item_id_str}': {e}"); return
        
        if 0 <= slot_index <= 15: 
            self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Item selected, slot_index: {slot_index}")
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'): self.app_ref.synchronize_selection_from_usage_window("color", slot_index)
        else: self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Parsed invalid slot_index {slot_index}.")

    def _on_close(self): 
        # Update in-memory config before destroying
        if hasattr(self.app_ref, 'update_specific_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: # Window might be closing
                 pass 
            self.app_ref.update_specific_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id)
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None
            
        self.app_ref.debug("[DEBUG] ColorUsageWindow closed.")
        if self.app_ref: self.app_ref.color_usage_window = None 
        
        try: 
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass

    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return # Ensure event is for the tree itself

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        self._treeview_refresh_timer_id = self.after(150, self._do_refresh_if_tree_valid_from_configure) # Increased delay slightly

    def _do_refresh_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped():
            # For ColorUsageWindow, a configure event on the tree usually means its own size changed.
            # No need to call refresh_data if only the tree's alloc. width/height changed,
            # as content (16 rows, fixed image sizes) is static.
            # However, if a full refresh is desired for some reason:
            # self.app_ref.debug("[DEBUG] ColorUsageWindow: Tree <Configure> -> Refreshing data.")
            # self.refresh_data()
            self.app_ref.debug("[DEBUG] ColorUsageWindow: Tree <Configure> event. No data refresh needed.")
        else:
            self.app_ref.debug("[DEBUG] ColorUsageWindow: Tree <Configure> -> Skipped (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        if region == "separator": 
            self._is_dragging_col_separator = True
            self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Drag started on separator.")
        else:
            self._is_dragging_col_separator = False

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False
            self.app_ref.debug("[DEBUG] ColorUsageWindow: Column drag ended. Updating config for column widths.")
            # Save new column widths to in-memory config
            if hasattr(self.app_ref, 'update_specific_window_config'):
                self.app_ref.update_specific_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config() # This gets widths and sort state
                )

class TileUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Tile Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = [] 
        self.current_sort_column_id = "tile_index" 
        self.current_sort_direction_is_asc = True   
        self.refresh_timer_id = None 
        self.style = ttk.Style()

        # --- Load saved configuration for this window ---
        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.load_specific_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col = saved_config.get('sort_column_id', self.current_sort_column_id)
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})

        self.current_sort_column_id = initial_sort_col
        self.current_sort_direction_is_asc = initial_sort_asc
        # --- End Load Config ---

        self._is_dragging_col_separator = False 
        self._treeview_refresh_timer_id = None

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(0, weight=1) 
        main_frame.grid_columnconfigure(0, weight=1)

        self.data_column_ids_for_values = ("tile_index_val", "total_uses_val", "used_by_sts_val")
        
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings", 
            height=16, # Default height, can be overridden by saved geometry
            selectmode="browse"
        )

        # --- Column #0: Tile Preview (Fixed Width, Not User Resizable) ---
        col0_img_fixed_width = TILE_USAGE_PREVIEW_SIZE + 8 
        self.tree.column("#0", width=col0_img_fixed_width, minwidth=col0_img_fixed_width, stretch=tk.NO, anchor="center")
        self.tree.heading("#0", text="Tile", command=lambda: self._sort_by_column("#0"))

        # --- Data Columns (User Resizable) ---
        col_idx_default_w = 70
        self.tree.column("tile_index_val", 
                         width=initial_col_widths.get("tile_index_val", col_idx_default_w), 
                         minwidth=50, stretch=tk.YES, anchor="center")
        self.tree.heading("tile_index_val", text="Index", command=lambda: self._sort_by_column("tile_index"))

        col_refs_default_w = 100
        self.tree.column("total_uses_val", 
                         width=initial_col_widths.get("total_uses_val", col_refs_default_w), 
                         minwidth=70, stretch=tk.YES, anchor="center")
        self.tree.heading("total_uses_val", text="Tile Refs", command=lambda: self._sort_by_column("total_uses_count"))
        
        self.tree.column("used_by_sts_val", 
                         width=initial_col_widths.get("used_by_sts_val", col_refs_default_w), 
                         minwidth=70, stretch=tk.YES, anchor="center")
        self.tree.heading("used_by_sts_val", text="ST Refs", command=lambda: self._sort_by_column("used_by_sts_count"))

        self.header_details = {
            "#0": {"id": "#0", "data_key": "tile_index"}, 
            "tile_index": {"id": "tile_index_val", "data_key": "tile_index"},
            "total_uses_count": {"id": "total_uses_val", "data_key": "total_uses_count"},
            "used_by_sts_count": {"id": "used_by_sts_val", "data_key": "used_by_sts_count"}
        }
        self._update_header_sort_indicators()

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        self.treeview_style_name = f"TileUsage_{id(self)}.Treeview"
        target_row_height_style = TILE_USAGE_PREVIEW_SIZE + 4 # Image size + slightly more padding
        try:
            self.style.configure(self.treeview_style_name, rowheight=target_row_height_style)
            self.style.map(self.treeview_style_name,
                      background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                      foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
            self.tree.configure(style=self.treeview_style_name)
        except tk.TclError as e_style:
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}.")

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press)
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+')
        self.tree.bind("<Configure>", self._on_tree_configure_debounced)
        
        button_frame_container = ttk.Frame(main_frame)
        button_frame_container.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None
        if self.app_ref.debug_enabled:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)
        
        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                self.app_ref.debug(f"[DEBUG] TileUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: # Default size if no geometry saved
            self.update_idletasks()
            # Default height for ~16-20 items, default width based on column estimates
            default_h = (16 * target_row_height_style) + 60 # Approx header, scrollbar, padding
            default_w = col0_img_fixed_width + col_idx_default_w + (col_refs_default_w * 2) + 20
            self.geometry(f"{max(350, default_w)}x{max(300, default_h)}")

        self.app_ref.update_specific_window_config(self.window_class_name, is_open=True)
        self.after(10, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                # Column #0 width is fixed, but we can save its configured fixed width
                widths["#0"] = self.tree.column("#0", "width") 
                for col_id in self.data_column_ids_for_values:
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                self.app_ref.debug("[DEBUG] TileUsageWindow: TclError getting column widths for save.")
        return {
            "sort_column_id": self.current_sort_column_id,
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def request_refresh(self, delay_ms=300): 
        if not self.winfo_exists(): 
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)

    def _perform_debounced_refresh(self): 
        self.refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _sort_by_column(self, column_clicked_key):
        data_sort_key = self.header_details.get(column_clicked_key, {}).get("data_key")
        if not data_sort_key:
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: Invalid column key '{column_clicked_key}' for sorting.")
            return

        if self.current_sort_column_id == data_sort_key:
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else:
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = data_sort_key
            # Index column defaults to ascending, count columns default to descending
            if "count" in data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for key, details in self.header_details.items():
            col_id_for_tree = details["id"] 
            data_key_for_sort = details["data_key"]
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(col_id_for_tree)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "") # Remove old indicators

            if data_key_for_sort == self.current_sort_column_id:
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(col_id_for_tree, text=text_to_set)
            except tk.TclError: pass
            
    def refresh_data(self): 
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            return
        
        self.app_ref.debug(f"[DEBUG] TileUsageWindow: refresh_data() called. Sort by: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        
        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear()
        
        usage_data = [] 
        if hasattr(self.app_ref, '_calculate_tile_usage_data'):
            try: 
                usage_data = self.app_ref._calculate_tile_usage_data() 
            except Exception as e:
                self.app_ref.debug(f"[DEBUG] Error calling _calculate_tile_usage_data: {e}")
                for i in range(getattr(self.app_ref, 'num_tiles_in_set', 1)): 
                     usage_data.append({'tile_index': i, 'total_uses_count': 0, 'used_by_sts_count': 0})
        else: 
            self.app_ref.debug("[DEBUG] TileUsageWindow: _calculate_tile_usage_data not found for refresh.")
            for i in range(getattr(self.app_ref, 'num_tiles_in_set', 1)): 
                usage_data.append({'tile_index': i, 'total_uses_count': 0, 'used_by_sts_count': 0})

        valid_sort_key = self.current_sort_column_id
        if usage_data and valid_sort_key not in usage_data[0]: 
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: Invalid sort key '{valid_sort_key}'. Defaulting to 'tile_index'.")
            valid_sort_key = 'tile_index' 
            self.current_sort_column_id = 'tile_index'
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators()
        
        if usage_data: 
            try:
                usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort: 
                self.app_ref.debug(f"[DEBUG] TileUsageWindow: Error during sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        preview_image_size = TILE_USAGE_PREVIEW_SIZE 
        for item_data in usage_data: 
            tile_idx = item_data['tile_index']
            photo = None
            try:
                if hasattr(self.app_ref, 'create_tile_image'):
                    photo = self.app_ref.create_tile_image(tile_idx, preview_image_size)
                    if photo:
                        self._image_references.append(photo) 
                else:
                    self.app_ref.debug(f"[DEBUG] TileUsageWindow: create_tile_image not found for tile {tile_idx}")
            except Exception as e_photo: 
                self.app_ref.debug(f"[DEBUG] TileUsageWindow: Error creating preview image for tile {tile_idx}: {e_photo}")

            item_iid = f"tile_{tile_idx}"
            self.tree.insert("", "end", 
                             iid=item_iid, 
                             image=photo if photo else '', 
                             text="", 
                             values=(f" {tile_idx}", 
                                     item_data['total_uses_count'], 
                                     item_data['used_by_sts_count']),
                             tags=('tile_row',))
        
        try:
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('tile_row', background=row_bg)
        except tk.TclError: pass
        
        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)
        
    def _on_item_selected(self, event):
        global num_tiles_in_set
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection() 
        if not selected_items: return
        item_id_str = selected_items[0] 
        try:
            if item_id_str.startswith("tile_"):
                actual_item_idx = int(item_id_str.split("_")[1])
            else:
                self.app_ref.debug(f"[DEBUG] TileUsageWindow: Could not parse tile_index from iid '{item_id_str}'.")
                return
        except (ValueError, IndexError) as e:
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: Error parsing tile_index from iid '{item_id_str}': {e}")
            return
        
        if 0 <= actual_item_idx < num_tiles_in_set: 
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                self.app_ref.synchronize_selection_from_usage_window("tile", actual_item_idx)
        else:
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: Parsed invalid tile_index {actual_item_idx} for selection sync.")

    def _on_close(self): 
        if hasattr(self.app_ref, 'update_specific_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: pass
            self.app_ref.update_specific_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id)
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None
        
        self.app_ref.debug("[DEBUG] TileUsageWindow closed.")
        if self.app_ref: 
            self.app_ref.tile_usage_window = None 
        
        try:
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass

    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        self._treeview_refresh_timer_id = self.after(150, self._do_refresh_if_tree_valid_from_configure)

    def _do_refresh_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped():
            self.app_ref.debug("[DEBUG] TileUsageWindow: Tree <Configure> event. No data refresh, fixed image size.")
            # For fixed image sizes, only column data stretch might occur, Treeview handles this.
            # If rows become clipped/unclipped due to height change, a refresh might be desired
            # to re-center selection or re-evaluate what's "visible" if lazy loading were used.
            # For now, no explicit refresh_data() call.
        else:
            self.app_ref.debug("[DEBUG] TileUsageWindow: Tree <Configure> -> Skipped (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        column_id_pressed = self.tree.identify_column(event.x)

        if region == "separator" and column_id_pressed != "#0": # Prevent resizing column #0
            self._is_dragging_col_separator = True
            self.app_ref.debug(f"[DEBUG] TileUsageWindow: Drag started on separator for data column.")
        else:
            self._is_dragging_col_separator = False

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False
            self.app_ref.debug("[DEBUG] TileUsageWindow: Column drag ended. Updating config for column widths.")
            if hasattr(self.app_ref, 'update_specific_window_config'):
                self.app_ref.update_specific_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config()
                )

class SupertileUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Supertile Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = []
        self.current_sort_column_id = "st_index" 
        self.current_sort_direction_is_asc = True
        self.refresh_timer_id = None
        
        # --- Load saved configuration for this window ---
        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.load_specific_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col_data_key = saved_config.get('sort_column_id', self.current_sort_column_id) # This is the data key
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})
        
        # current_sort_column_id in this window can be "#0" (for tree view header) or a data key
        # We need to map the saved data_key back to the column_id for tree header state
        self.current_sort_column_id = initial_sort_col_data_key # Store the data key for sorting logic
        self.current_sort_direction_is_asc = initial_sort_asc
        # The actual tree header sort indicator will be updated via _update_header_sort_indicators
        # --- End Load Config ---
        
        self._is_dragging_col_separator = False
        self._col0_width_at_drag_start = 0 # For image column specifically
        self._treeview_refresh_timer_id = None
        self.styled_row_height = 0 
        self._update_images_timer_id = None 

        app_st_grid_h = self.app_ref.supertile_grid_height
        tile_h_const = TILE_HEIGHT 
        scale_const = SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL 

        self.preview_target_content_h = max(1, int(app_st_grid_h * tile_h_const * scale_const))
        treeview_styled_row_h = self.preview_target_content_h + SUPERTILE_USAGE_ROW_PADDING
        self.styled_row_height = treeview_styled_row_h 
        
        min_col0_image_area_w = SUPERTILE_USAGE_MIN_IMAGE_MSX_W * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        self.min_col0_total_width = max(1, int(min_col0_image_area_w + SUPERTILE_USAGE_COL0_OFFSET_GUESS))

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(1, weight=1) # Treeview itself is in row 1
        main_frame.grid_columnconfigure(0, weight=1)

        self.style = ttk.Style()
        self.treeview_style_name = f"SupertileUsage_{id(self)}.Treeview" 
        try:
            self.style.configure(self.treeview_style_name, rowheight=treeview_styled_row_h)
            self.style.map(self.treeview_style_name,
                           background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                           foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
        except tk.TclError as e_style:
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}")
            try: 
                app_style = getattr(self.app_ref, 'style', ttk.Style()) 
                app_style.configure('Treeview', rowheight=treeview_styled_row_h) # Fallback
                self.treeview_style_name = 'Treeview' 
            except Exception as e_gen:
                 self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Failed to apply generic Treeview rowheight: {e_gen}")

        self.data_column_ids_for_values = ("st_index_val", "uses_on_map_val")
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings",
            height=16, 
            selectmode="browse",
            style=self.treeview_style_name
        )

        col0_default_width = 150 
        self.tree.column("#0", 
                         width=initial_col_widths.get("#0", col0_default_width), 
                         minwidth=self.min_col0_total_width, stretch=tk.YES, anchor=tk.W)
        self.tree.heading("#0", text="Supertile", command=lambda: self._sort_by_column("#0"))

        index_col_default_width = 70
        self.tree.column("st_index_val", 
                         width=initial_col_widths.get("st_index_val", index_col_default_width), 
                         minwidth=50, stretch=tk.YES, anchor=tk.CENTER)
        self.tree.heading("st_index_val", text="Index", command=lambda: self._sort_by_column("st_index"))
        
        # This structure maps the sort key used in logic (e.g. "st_index") to the tree column ID and data key.
        # For column "#0", the "command_key" is what _sort_by_column receives.
        self.header_details = { 
            "#0": {"id": "#0", "data_key": "st_index"}, # Sort by ST index when image col header clicked
            "st_index": {"id": "st_index_val", "data_key": "st_index"},
            "uses_on_map_count": {"id": "uses_on_map_val", "data_key": "uses_on_map_count"}
        }
        # Map the loaded sort data_key back to the command_key for _update_header_sort_indicators
        self.current_sort_command_key = initial_sort_col_data_key # Default if not found
        for cmd_key, details_dict in self.header_details.items():
            if details_dict["data_key"] == initial_sort_col_data_key:
                self.current_sort_command_key = cmd_key
                break
        # self.current_sort_column_id still holds the data_key for sorting the data array.

        uses_col_default_width = 100
        self.tree.column("uses_on_map_val", 
                         width=initial_col_widths.get("uses_on_map_val", uses_col_default_width), 
                         minwidth=80, stretch=tk.YES, anchor=tk.CENTER)
        self.tree.heading("uses_on_map_val", text="Uses on Map", command=lambda: self._sort_by_column("uses_on_map_count"))
        
        self._update_header_sort_indicators() # Apply initial sort indicator to headers

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=1, column=0, sticky="nsew") # Treeview in grid row 1
        v_scrollbar.grid(row=1, column=1, sticky="ns")
        h_scrollbar.grid(row=2, column=0, sticky="ew") # H-scrollbar below tree

        button_frame_container = ttk.Frame(main_frame)
        button_frame_container.grid(row=3, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None
        if self.app_ref.debug_enabled:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press)
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+')
        self.tree.bind("<Configure>", self._on_tree_configure_debounced)
        
        v_scrollbar.bind("<ButtonRelease-1>", lambda e: self._schedule_update_visible_images(delay_ms=100), add='+')
        v_scrollbar.bind("<B1-Motion>", lambda e: self._schedule_update_visible_images(delay_ms=150), add='+')
        self.tree.bind("<MouseWheel>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<Button-4>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<Button-5>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<KeyPress-Up>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-Down>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-Prior>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+') 
        self.tree.bind("<KeyPress-Next>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+') 
        self.tree.bind("<KeyPress-Home>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-End>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')

        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: # Default size if no geometry saved
            self.update_idletasks()
            default_h = (16 * treeview_styled_row_h) + 60 # Approx for 16 rows + header/scrollbar
            default_w = col0_default_width + index_col_default_width + uses_col_default_width + 20
            self.geometry(f"{max(400, default_w)}x{max(400, default_h)}")
            
        self.app_ref.update_specific_window_config(self.window_class_name, is_open=True)
        self.after(50, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                widths["#0"] = self.tree.column("#0", "width")
                for col_id in self.data_column_ids_for_values: # Correctly iterate defined data columns
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                self.app_ref.debug("[DEBUG] SupertileUsageWindow: TclError getting column widths for save.")
        return {
            # Save the data_key used for sorting, not the command_key
            "sort_column_id": self.current_sort_column_id, 
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def refresh_data(self):
        self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: refresh_data() called. Sort: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: Treeview not ready for refresh_data.")
            return

        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear() 

        usage_data = []
        if hasattr(self.app_ref, '_calculate_supertile_usage_data'):
            try:
                usage_data = self.app_ref._calculate_supertile_usage_data()
            except Exception as e:
                self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Error calling _calculate_supertile_usage_data: {e}")
                for i in range(getattr(self.app_ref, 'num_supertiles', 0)):
                     usage_data.append({'st_index': i, 'uses_on_map_count': 0})
        else:
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: _calculate_supertile_usage_data not found.")
            for i in range(getattr(self.app_ref, 'num_supertiles', 0)):
                 usage_data.append({'st_index': i, 'uses_on_map_count': 0})

        # self.current_sort_column_id here is the data_key (e.g. "st_index", "uses_on_map_count")
        valid_sort_key = self.current_sort_column_id
        
        if usage_data and valid_sort_key not in usage_data[0]:
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Invalid sort column DATA KEY '{valid_sort_key}'. Defaulting to 'st_index'.")
            valid_sort_key = 'st_index'
            self.current_sort_column_id = 'st_index' 
            self.current_sort_command_key = "#0" # Assuming "#0" is command key for st_index data key
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators() 

        if usage_data:
            try:
                usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort:
                self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Error sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        for item_data in usage_data:
            st_idx = item_data['st_index']
            item_iid = f"st_{st_idx}"
            self.tree.insert(
                "", "end",
                iid=item_iid,
                text="", 
                image='', 
                values=(f"  {st_idx}", item_data['uses_on_map_count']),
                tags=('st_row',) 
            )
        
        try:
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('st_row', background=row_bg)
        except tk.TclError: pass
        
        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)

        self.after_idle(self._schedule_update_visible_images)

    def _sort_by_column(self, column_command_key):
        # column_command_key is like "#0", "st_index", "uses_on_map_count" (keys from self.header_details)
        self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Sorting by command_key '{column_command_key}'")
        
        new_data_sort_key = self.header_details.get(column_command_key, {}).get("data_key")
        if not new_data_sort_key:
            self.app_ref.debug(f"  [DEBUG] Could not find data_key for command_key '{column_command_key}'. Aborting sort.")
            return

        if self.current_sort_column_id == new_data_sort_key: 
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else: 
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = new_data_sort_key
            self.current_sort_command_key = column_command_key # Update the command key being sorted by
            # Index column defaults to ascending, count columns default to descending
            if "count" in new_data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for cmd_key, details in self.header_details.items():
            tree_col_id = details["id"]      # e.g., "#0", "st_index_val"
            data_key = details["data_key"] # e.g., "st_index"
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(tree_col_id)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "")

            if data_key == self.current_sort_column_id: # Compare with the data key
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(tree_col_id, text=text_to_set)
            except tk.TclError: pass

    def _on_item_selected(self, event):
        global num_supertiles 
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection()
        if not selected_items: return

        item_iid_str = selected_items[0] 
        try:
            if item_iid_str.startswith("st_"):
                actual_st_idx = int(item_iid_str.split("_")[1])
            else:
                self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Could not parse st_index from iid '{item_iid_str}'.")
                return
        except (ValueError, IndexError) as e:
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Error parsing st_index from iid '{item_iid_str}': {e}")
            return
        
        if 0 <= actual_st_idx < num_supertiles: 
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Item selected, st_index: {actual_st_idx}")
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                self.app_ref.synchronize_selection_from_usage_window("supertile", actual_st_idx)
        else:
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Parsed invalid st_index {actual_st_idx} (global num_supertiles: {num_supertiles}) for selection sync.")

    def request_refresh(self, delay_ms=300):
        # self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: request_refresh called. Current timer: {self.refresh_timer_id}")
        if not self.winfo_exists():
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)
        # self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: new refresh_timer_id set to: {self.refresh_timer_id}")

    def _perform_debounced_refresh(self):
        # self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: _perform_debounced_refresh executing for timer {self.refresh_timer_id}.")
        self.refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _on_close(self):
        # Update in-memory config before destroying
        if hasattr(self.app_ref, 'update_specific_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: pass
            self.app_ref.update_specific_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id) 
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id) 
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None

        if hasattr(self, '_update_images_timer_id') and self._update_images_timer_id is not None:
            try: self.after_cancel(self._update_images_timer_id)
            except tk.TclError: pass
            self._update_images_timer_id = None

        self.app_ref.debug("[DEBUG] SupertileUsageWindow closed.")
        if self.app_ref: 
            self.app_ref.supertile_usage_window = None 
        try: 
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass
        
    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        # Refresh data if tree is configured, as column widths might affect image rendering for col #0
        self._treeview_refresh_timer_id = self.after(150, self._do_populate_if_tree_valid_from_configure)

    def _do_populate_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped():
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: Tree <Configure> -> Refreshing data (due to potential col width change).")
            self.refresh_data() # This will trigger lazy image loading
        else:
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: Tree <Configure> -> Skipped refresh (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        if region == "separator":
            self._is_dragging_col_separator = True
            column_id_pressed = self.tree.identify_column(event.x) # Get which separator line
            try:
                # Store width of the column to the LEFT of the separator
                # For tree.column("#0"), it's simple. For others, it's column_id_pressed.
                # However, identify_column often gives the column to the RIGHT of separator.
                # The important part is knowing a drag started. We'll get all widths on release.
                if column_id_pressed == "#0": # Dragging separator for the first column
                    self._col0_width_at_drag_start = self.tree.column("#0", "width")
                # For other columns, the Treeview handles resize, we just save on release.
            except tk.TclError: 
                self._is_dragging_col_separator = False 
                return
            self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Drag started on separator. Col ID: {column_id_pressed}")
        else:
            self._is_dragging_col_separator = False

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False 
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: Column drag ended. Scheduling width check/config save.")
            self.after_idle(self._check_col_widths_and_update_config_after_drag)

    def _check_col_widths_and_update_config_after_drag(self):
        if not self.winfo_exists() or not self.tree.winfo_exists(): return
        
        config_changed_by_drag = False
        try:
            current_col0_width = self.tree.column("#0", "width")
            if hasattr(self, '_col0_width_at_drag_start') and current_col0_width != self._col0_width_at_drag_start:
                self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Col #0 width changed by drag: {self._col0_width_at_drag_start} -> {current_col0_width}. Refreshing for new image crops.")
                if self.winfo_ismapped():
                    self.refresh_data() # This will re-crop images for col #0
                config_changed_by_drag = True
            
            # Even if col #0 didn't change, other columns might have. Update config.
            if hasattr(self.app_ref, 'update_specific_window_config'):
                 self.app_ref.update_specific_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config() # This gets all current widths
                )
                 if not config_changed_by_drag: # If only other columns changed, mark config as changed
                     self.app_ref.debug("[DEBUG] SupertileUsageWindow: Data column widths may have changed. Config updated.")


        except tk.TclError:
            self.app_ref.debug("[DEBUG] SupertileUsageWindow: TclError during _check_col_widths_after_drag.")
    
    # --- Lazy Loading Methods (Copied from previous successful implementation) ---
    def _schedule_update_visible_images(self, delay_ms=50):
        if not self.winfo_exists():
            return
        if hasattr(self, '_update_images_timer_id') and self._update_images_timer_id is not None:
            try:
                self.after_cancel(self._update_images_timer_id)
            except tk.TclError: 
                pass
        self._update_images_timer_id = self.after(delay_ms, self._update_visible_item_images)

    def _update_visible_item_images(self):
        self._update_images_timer_id = None
        if not self.winfo_exists() or not hasattr(self, 'tree') or not self.tree.winfo_exists() or not self.app_ref:
            return

        children = self.tree.get_children()
        if not children:
            return

        num_items = len(children)
        try:
            yview = self.tree.yview() 
            tree_height_px = self.tree.winfo_height()
        except tk.TclError: 
            return

        row_h = self.styled_row_height 
        if row_h <= 0 or tree_height_px <= 0 : return
        
        buffer_items = 3 
        num_items_on_screen_estimate = math.ceil(tree_height_px / row_h) if row_h > 0 else num_items
        first_visible_model_idx = int(yview[0] * num_items)
        start_load_idx = max(0, first_visible_model_idx - buffer_items)
        end_load_idx = min(num_items, first_visible_model_idx + num_items_on_screen_estimate + buffer_items)

        total_col0_width = 0
        try:
            total_col0_width = self.tree.column("#0", "width")
        except tk.TclError: return 

        effective_total_col0_width = max(total_col0_width, self.min_col0_total_width)
        image_content_area_width = max(1, effective_total_col0_width - SUPERTILE_USAGE_COL0_OFFSET_GUESS)
        newly_added_images = []

        for i in range(start_load_idx, end_load_idx):
            item_iid = children[i]
            current_img_name_in_tree_list = self.tree.item(item_iid, "image")
            current_img_name_in_tree = ""
            if isinstance(current_img_name_in_tree_list, (list, tuple)) and current_img_name_in_tree_list:
                current_img_name_in_tree = str(current_img_name_in_tree_list[0])
            elif isinstance(current_img_name_in_tree_list, str):
                current_img_name_in_tree = current_img_name_in_tree_list
            
            if not current_img_name_in_tree: 
                try:
                    if item_iid.startswith("st_"): st_idx = int(item_iid.split("_")[1])
                    else: continue
                except (ValueError, IndexError): continue
                photo = None
                try:
                    if hasattr(self.app_ref, 'create_cropped_supertile_preview_for_usage_window'):
                        photo = self.app_ref.create_cropped_supertile_preview_for_usage_window(
                            st_idx, image_content_area_width, self.preview_target_content_h 
                        )
                        if photo:
                            newly_added_images.append(photo)
                            self.tree.item(item_iid, image=photo)
                except Exception as e_photo:
                    self.app_ref.debug(f"[DEBUG] SupertileUsageWindow: Error lazy-load preview ST {st_idx}: {e_photo}")
        
        if newly_added_images:
            self._image_references.extend(newly_added_images)

# --- Application Class  -----------------------------------------------------------------------------------------------
class TileEditorApp:
    def __init__(self, root):
        # --- 1. Basic App/Root Window Setup ---
        self.debug_enabled = getattr(root, 'app_debug_mode', False)
        self.debug("[DEBUG] TileEditorApp __init__ started (Reordered).")
        
        self.root = root
        self.root.title("MSX Tile Forge - Untitled") 
        with suppress(tk.TclError): # Try to maximize window
            self.root.state("zoomed")

        try:
            image_data = base64.b64decode(ICON_IMAGE)
            app_icon = tk.PhotoImage(data=image_data)
            # The 'True' argument makes this the default icon for all Toplevels
            self.root.iconphoto(True, app_icon)
            # IMPORTANT: Keep a reference to the image to prevent garbage collection
            self.root.app_icon_ref = app_icon
            self.debug("Successfully set application icon from embedded data.")
        except Exception as e:
            self.debug(f"[ERROR] Failed to set application icon: {e}")
    
        self.current_project_base_path = None
        self.project_modified = False
        self.scroll_speed_units = 3 
        self.is_currently_painting_tile = False # For drag-paint refresh fix

        self.config_app_name = "MSXTileForge" 
        self.config_file_name = "usage_windows_settings.json" # Changed name slightly
        self.window_configs = {} # Holds loaded/current configs for usage windows
        self._load_window_configs() # Load configs at startup

        # Initialize active palette (needed early if default colors are used by UI elements immediately)
        self.active_msx_palette = []
        for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
            self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
        self.selected_palette_slot = 0 # For Palette Editor

        # Timer IDs for debouncing configure events
        self._main_window_configure_timer = None 
        self._map_canvas_configure_timer = None 
        self._palette_pane_resize_timer = None 

        # --- 2. Core Data Structures Initialization ---
        self.supertile_grid_width = SUPERTILE_GRID_DIM 
        self.supertile_grid_height = SUPERTILE_GRID_DIM 

        # Image Caches
        self.tile_image_cache = {}      
        self.supertile_image_cache = {} 
        self.map_render_cache = {}      
        self.pil_map_viewport_image = None 
        self.tk_map_photoimage = None      

        # Drag State
        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        self.drag_indicator_id = None

        # Map View State
        self.map_zoom_level = 1.0
        self.show_supertile_grid = tk.BooleanVar(value=False)
        self.show_window_view = tk.BooleanVar(value=False)
        self.grid_color_index = 1 
        self.window_view_tile_x = 0
        self.window_view_tile_y = 0
        self.window_view_tile_w = tk.IntVar(value=DEFAULT_WIN_VIEW_WIDTH_TILES)
        self.window_view_tile_h = tk.IntVar(value=DEFAULT_WIN_VIEW_HEIGHT_TILES)
        self.window_view_resize_handle = None
        self.drag_start_x = 0 
        self.drag_start_y = 0
        self.drag_start_win_tx = 0
        self.drag_start_win_ty = 0
        self.drag_start_win_tw = 0
        self.drag_start_win_th = 0
        self.map_controls_min_width = 0 

        # Minimap State
        self.minimap_window = None
        self.minimap_canvas = None
        self.MINIMAP_VIEWPORT_COLOR = "#FF0000"
        self.MINIMAP_WIN_VIEW_COLOR = "#0000FF"
        self.minimap_background_cache = None
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0
        self.minimap_resize_timer = None
        self._minimap_resizing_internally = False

        # Interaction State
        self.is_ctrl_pressed = False
        self.current_mouse_action = None 
        self.pan_start_x = 0
        self.pan_start_y = 0
        self.last_placed_supertile_cell = None 
        self.is_shift_pressed = False

        # Map Selection & Clipboard
        self.map_selection_active = False
        self.map_selection_rect_id = None
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_clipboard_data = None
        self.map_paste_preview_rect_id = None
        
        # Menu item state
        self.edit_menu = None 
        self.copy_menu_item_index = -1
        self.paste_menu_item_index = -1

        # Marked Unused State
        self.marked_unused_tiles = set()
        self.marked_unused_supertiles = set()

        # Dialog References
        self.rom_import_dialog = None
        self.color_usage_window = None
        self.tile_usage_window = None
        self.supertile_usage_window = None 

        # --- 3. Menu Creation ---
        self.create_menu()

        # --- 4. Global Key Bindings ---
        self._setup_global_key_bindings()

        # --- 5. Main UI Layout (Notebook and Tabs) ---
        self.notebook = ttk.Notebook(root) 
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")

        self.tab_palette_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_tile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_supertile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_map_editor = ttk.Frame(self.notebook, padding="10")

        self.notebook.add(self.tab_palette_editor, text="Palette Editor")
        self.notebook.add(self.tab_tile_editor, text="Tile Editor")
        self.notebook.add(self.tab_supertile_editor, text="Supertile Editor")
        self.notebook.add(self.tab_map_editor, text="Map Editor")

        # --- 6. Widget Creation for Each Tab ---
        self.create_palette_editor_widgets(self.tab_palette_editor)
        self.create_tile_editor_widgets(self.tab_tile_editor)
        self.create_supertile_editor_widgets(self.tab_supertile_editor)
        self.create_map_editor_widgets(self.tab_map_editor) 
        
        # --- 7. Core Event Bindings ---
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)
        self._setup_map_canvas_bindings() 
        
        self.root.protocol("WM_DELETE_WINDOW", self.confirm_quit)
        self.root.bind("<Configure>", self._on_main_window_configure)

        # --- 8. Initial UI State Updates & Refresh ---
        self._update_window_title() 
        self.update_all_displays(changed_level="all") 
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        self._update_map_cursor()
        
        # --- 9. Restore Usage Window States (NEW) ---
        self._apply_initial_usage_window_states() # Open windows based on loaded config
        
        # --- 10. Final Debug Message ---
        self.debug("[DEBUG] TileEditorApp __init__ finished.")

    def debug(self, message):
        """Prints the message to the console only if debug mode is enabled."""
        if self.debug_enabled:
            print(str(message)) # Ensure message is a string

    # --- Palette Conversion Helpers ---
    def _hex_to_rgb7(self, hex_color):
        try:
            if not isinstance(hex_color, str):
                raise TypeError("Input must be a string.")
            if not hex_color.startswith("#") or len(hex_color) != 7:
                raise ValueError(f"Input '{hex_color}' is not a valid #RRGGBB format.")
            lookup_hex = hex_color.lower()
            idx512 = msx2_512_colors_hex.index(lookup_hex)
            return msx2_512_colors_rgb7[idx512]
        except ValueError:
            print(
                f"Warning: Could not find exact MSX2 RGB7 mapping for hex '{hex_color}'. Returning (0,0,0)."
            )
            return (0, 0, 0)
        except TypeError as e:
            print(f"Error in _hex_to_rgb7: Input type error for '{hex_color}'. {e}")
            return (0, 0, 0)
        except Exception as e:
            print(f"Unexpected error in _hex_to_rgb7 for '{hex_color}': {e}")
            return (0, 0, 0)

    def _rgb7_to_hex(self, r, g, b):
        try:
            safe_r = max(0, min(7, int(r)))
            safe_g = max(0, min(7, int(g)))
            safe_b = max(0, min(7, int(b)))
            r_255 = min(255, safe_r * 36)
            g_255 = min(255, safe_g * 36)
            b_255 = min(255, safe_b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            return hex_color
        except (ValueError, TypeError) as e:
            print(f"Error in _rgb7_to_hex converting input ({r},{g},{b}): {e}")
            return "#000000"
        except Exception as e:
            print(f"Unexpected error in _rgb7_to_hex for ({r},{g},{b}): {e}")
            return "#000000"

    # --- Cache Management ---
    def invalidate_tile_cache(self, tile_index):
        keys_to_remove = [k for k in self.tile_image_cache if k[0] == tile_index]
        for key in keys_to_remove:
            self.tile_image_cache.pop(key, None)
        for st_index in range(num_supertiles):
            definition = supertiles_data[st_index]
            used = False
            # Check if definition is valid for current dimensions before iterating
            if len(definition) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) :
                for r_st_def in range(self.supertile_grid_height):
                    # Ensure row exists (it should if height check passed)
                    if r_st_def < len(definition):
                        for c_st_def in range(self.supertile_grid_width):
                             # Ensure column exists within row
                            if c_st_def < len(definition[r_st_def]):
                                if definition[r_st_def][c_st_def] == tile_index:
                                    used = True
                                    break
                            else: # Should not happen if width check above is good
                                self.debug(f"[DEBUG]Warning: Invalidate tile cache, ST {st_index} row {r_st_def} too short for width {self.supertile_grid_width}")
                                break
                    else: # Should not happen if height check passed
                        self.debug(f"[DEBUG]Warning: Invalidate tile cache, ST {st_index} definition too short for height {self.supertile_grid_height}")
                        break
                    if used:
                        break
            else:
                # This case indicates an inconsistency between self.supertile_grid_width/height
                # and the actual structure of supertiles_data[st_index].
                # This might happen if dimensions change but data isn't properly migrated/reinitialized.
                # For now, we'll skip invalidating supertile cache if the structure is unexpected,
                # or one could choose to invalidate all supertile caches as a precaution.
                self.debug(f"[DEBUG]Warning: Supertile {st_index} definition dimensions mismatch project settings during tile cache invalidation. Skipping ST cache invalidation for this ST.")
                pass # Or: self.invalidate_supertile_cache(st_index) if aggressive


            if used:
                self.invalidate_supertile_cache(st_index)

    def invalidate_supertile_cache(self, supertile_index):
        keys_to_remove_st_img = [
            k for k in self.supertile_image_cache if k[0] == supertile_index
        ]
        for key_st_img in keys_to_remove_st_img:
            self.supertile_image_cache.pop(key_st_img, None)

        # Also invalidate corresponding entries in map_render_cache
        keys_to_remove_map_render = [
            k for k in self.map_render_cache if k[0] == supertile_index
        ]
        for key_map_render in keys_to_remove_map_render:
            self.map_render_cache.pop(key_map_render, None)

    def clear_all_caches(self):
        self.tile_image_cache.clear()
        self.supertile_image_cache.clear()
        self.map_render_cache.clear() # Added to clear the new map render cache

    # --- Image Generation ---
    def create_tile_image(self, tile_index, size):
        cache_key = (tile_index, size)
        if cache_key in self.tile_image_cache:
            return self.tile_image_cache[cache_key]
        render_size = max(1, int(size))
        img = tk.PhotoImage(width=render_size, height=render_size)
        if not (0 <= tile_index < num_tiles_in_set):
            img.put(INVALID_TILE_COLOR, to=(0, 0, render_size, render_size))
            self.tile_image_cache[cache_key] = img
            return img
        pattern = tileset_patterns[tile_index]
        colors = tileset_colors[tile_index]
        pixel_w_ratio = TILE_WIDTH / render_size
        pixel_h_ratio = TILE_HEIGHT / render_size
        for y in range(render_size):
            tile_r = min(TILE_HEIGHT - 1, int(y * pixel_h_ratio))
            try:
                fg_idx, bg_idx = colors[tile_r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            row_colors_hex = []
            for x in range(render_size):
                tile_c = min(TILE_WIDTH - 1, int(x * pixel_w_ratio))
                try:
                    pixel_val = pattern[tile_r][tile_c]
                except IndexError:
                    pixel_val = 0
                color_hex = fg_color if pixel_val == 1 else bg_color
                row_colors_hex.append(color_hex)
            try:
                img.put("{" + " ".join(row_colors_hex) + "}", to=(0, y))
            except tk.TclError as e:
                print(
                    f"Warning [create_tile_image]: TclError tile {tile_index} size {size} row {y}: {e}"
                )
                if row_colors_hex:
                    img.put(row_colors_hex[0], to=(0, y, render_size, y + 1))
        self.tile_image_cache[cache_key] = img
        return img

    def create_supertile_image(self, supertile_index, target_preview_width, target_preview_height): # Renamed parameters
        # Ensure target dimensions are at least 1x1
        safe_target_preview_width = max(1, int(target_preview_width))
        safe_target_preview_height = max(1, int(target_preview_height))

        # Cache key now includes actual target dimensions and source supertile grid dimensions
        cache_key = (supertile_index, safe_target_preview_width, safe_target_preview_height, self.supertile_grid_width, self.supertile_grid_height)
        if cache_key in self.supertile_image_cache: # Use supertile_image_cache
            return self.supertile_image_cache[cache_key]

        img = tk.PhotoImage(width=safe_target_preview_width, height=safe_target_preview_height)

        if not (0 <= supertile_index < num_supertiles):
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            self.debug(f"[DEBUG]Warning: Supertile {supertile_index} internal dim mismatch for create_supertile_image. Expected {src_st_tile_grid_w}x{src_st_tile_grid_h}")
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        # --- Letterboxing/Pillarboxing logic REMOVED ---
        # The image is created with exact target dimensions, and we render directly into it.

        # Pixels of one original base tile (e.g., 8x8) when rendered within the target_preview_width/height
        output_pixels_per_base_tile_w = safe_target_preview_width / src_st_tile_grid_w
        output_pixels_per_base_tile_h = safe_target_preview_height / src_st_tile_grid_h
        
        # Heuristic: if rendering a source tile column/row to less than 1 pixel on average.
        if safe_target_preview_width < src_st_tile_grid_w or safe_target_preview_height < src_st_tile_grid_h:
             img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
             self.supertile_image_cache[cache_key] = img
             return img

        # Ratio of source base tile pixels (e.g., TILE_WIDTH) to its display size in the preview.
        src_pixels_per_output_pixel_w_ratio = TILE_WIDTH / output_pixels_per_base_tile_w if output_pixels_per_base_tile_w > 1e-9 else float('inf')
        src_pixels_per_output_pixel_h_ratio = TILE_HEIGHT / output_pixels_per_base_tile_h if output_pixels_per_base_tile_h > 1e-9 else float('inf')

        for y_out_preview in range(safe_target_preview_height):
            row_colors_hex_preview = []
            for x_out_preview in range(safe_target_preview_width):
                src_base_tile_c_in_st_grid_preview = min(src_st_tile_grid_w - 1, int(x_out_preview / output_pixels_per_base_tile_w))
                src_base_tile_r_in_st_grid_preview = min(src_st_tile_grid_h - 1, int(y_out_preview / output_pixels_per_base_tile_h))

                x_in_scaled_base_tile_area_preview = (x_out_preview / output_pixels_per_base_tile_w - src_base_tile_c_in_st_grid_preview) * output_pixels_per_base_tile_w
                y_in_scaled_base_tile_area_preview = (y_out_preview / output_pixels_per_base_tile_h - src_base_tile_r_in_st_grid_preview) * output_pixels_per_base_tile_h
                
                src_pixel_c_in_base_tile_preview = min(TILE_WIDTH - 1, int(x_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_w_ratio))
                src_pixel_r_in_base_tile_preview = min(TILE_HEIGHT - 1, int(y_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_h_ratio))

                pixel_color_hex_final_preview = INVALID_TILE_COLOR

                try:
                    tile_idx_from_st_def_preview = definition[src_base_tile_r_in_st_grid_preview][src_base_tile_c_in_st_grid_preview]
                    if 0 <= tile_idx_from_st_def_preview < num_tiles_in_set:
                        if not (0 <= src_pixel_r_in_base_tile_preview < TILE_HEIGHT and \
                                len(tileset_patterns[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview and \
                                0 <= src_pixel_c_in_base_tile_preview < TILE_WIDTH and \
                                len(tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]) > src_pixel_c_in_base_tile_preview and \
                                len(tileset_colors[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview):
                            pixel_color_hex_final_preview = INVALID_TILE_COLOR
                        else:
                            pattern_pixel_val_preview = tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview][src_pixel_c_in_base_tile_preview]
                            fg_idx_val_preview, bg_idx_val_preview = tileset_colors[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]
                            
                            if not (0 <= fg_idx_val_preview < len(self.active_msx_palette) and 0 <= bg_idx_val_preview < len(self.active_msx_palette)):
                                fg_color_preview = INVALID_TILE_COLOR; bg_color_preview = INVALID_TILE_COLOR
                            else:
                                fg_color_preview = self.active_msx_palette[fg_idx_val_preview]
                                bg_color_preview = self.active_msx_palette[bg_idx_val_preview]
                            pixel_color_hex_final_preview = fg_color_preview if pattern_pixel_val_preview == 1 else bg_color_preview
                except IndexError:
                    pixel_color_hex_final_preview = INVALID_TILE_COLOR
                
                row_colors_hex_preview.append(pixel_color_hex_final_preview)
            
            try:
                if safe_target_preview_width > 0:
                    img.put("{" + " ".join(row_colors_hex_preview) + "}", to=(0, y_out_preview))
            except tk.TclError as e:
                if row_colors_hex_preview and safe_target_preview_width > 0:
                    img.put(row_colors_hex_preview[0], to=(0, y_out_preview, safe_target_preview_width, y_out_preview + 1))
        
        self.supertile_image_cache[cache_key] = img # Store in the original cache
        return img

    # --- Menu Creation ---
    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # --- File Menu ---
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(
            label="New Project (All)", command=self.new_project, accelerator="Ctrl+N"
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Project...", command=self.open_project, accelerator="Ctrl+O"
        )
        file_menu.add_command(
            label="Save Project", command=self.save_project, accelerator="Ctrl+S"
        )
        file_menu.add_command(
            label="Save Project As...",
            command=self.save_project_as,
            accelerator="Ctrl+Shift+S",
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Palette...", command=self.open_palette 
        )
        file_menu.add_command(
            label="Save Palette...", command=self.save_palette
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Tileset...", command=self.open_tileset
        )
        file_menu.add_command(
            label="Save Tileset...", command=self.save_tileset
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Supertiles...", command=self.open_supertiles
        )
        file_menu.add_command(
            label="Save Supertiles...", command=self.save_supertiles
        )
        file_menu.add_separator()
        file_menu.add_command(label="Open Map...", command=self.open_map)
        file_menu.add_command(label="Save Map...", command=self.save_map)
        file_menu.add_separator()
        file_menu.add_command(
            label="Exit", command=self.confirm_quit, accelerator="Ctrl+Q"
        )

        # --- Edit Menu ---
        self.edit_menu = tk.Menu(menubar, tearoff=0) 
        menubar.add_cascade(label="Edit", menu=self.edit_menu)

        self.edit_menu.add_command(
            label="Copy",
            command=self.handle_generic_copy,
            state=tk.DISABLED,
            accelerator="Ctrl+C",
        )
        self.copy_menu_item_index = 0 

        self.edit_menu.add_command(
            label="Paste",
            command=self.handle_generic_paste,
            state=tk.DISABLED,
            accelerator="Ctrl+V",
        )
        self.paste_menu_item_index = 1

        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Clear Current Tile", command=self.clear_current_tile
        )
        self.edit_menu.add_command(
            label="Clear Current Supertile", command=self.clear_current_supertile
        )
        self.edit_menu.add_command(label="Clear Map", command=self.clear_map)
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Set Map Dimensions...", command=self.set_map_dimensions
        ) 

        # --- View Menu ---
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(
            label="Show/Hide Minimap", command=self.toggle_minimap, accelerator="Ctrl+M"
        )
        view_menu.add_separator() 
        view_menu.add_command(label="Color Usage", command=self.toggle_color_usage_window)
        view_menu.add_command(label="Tile Usage", command=self.toggle_tile_usage_window)
        view_menu.add_command(label="Supertile Usage", command=self.toggle_supertile_usage_window) # ADD THIS LINE


        # --- Import Menu ---
        import_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Import", menu=import_menu)
        import_menu.add_command(
            label="Append Tileset from File...", 
            command=self.append_tileset_from_file
        )
        import_menu.add_command(
            label="Append Supertiles from File...", 
            command=self.append_supertiles_from_file
        )
        import_menu.add_separator()
        import_menu.add_command(
            label="Import Tiles from ROM...", 
            command=self.open_rom_importer
        )

        # --- Help Menu ---
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About...", command=self.show_about_box)

    # --- Widget Creation ---
    def create_palette_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame, padding=5)
        left_frame.grid(row=0, column=0, sticky="ns")
        right_frame = ttk.Frame(main_frame, padding=5)
        right_frame.grid(row=0, column=1, sticky="nsew")
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0)
        main_frame.grid_columnconfigure(1, weight=1)
        # Left Frame Contents
        current_palette_frame = ttk.LabelFrame(
            left_frame, text="Active Palette (16 colors)"
        )
        current_palette_frame.pack(pady=(0, 10), fill="x")
        cp_canvas_width = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        cp_canvas_height = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        self.current_palette_canvas = tk.Canvas(
            current_palette_frame,
            width=cp_canvas_width,
            height=cp_canvas_height,
            borderwidth=0,
            highlightthickness=0,
        )
        self.current_palette_canvas.pack()
        self.current_palette_canvas.bind(
            "<Button-1>", self.handle_current_palette_click
        )
        info_frame = ttk.LabelFrame(left_frame, text="Selected Slot Info")
        info_frame.pack(pady=(0, 10), fill="x")

        # Create a canvas for the color preview and rearrange labels
        preview_canvas_size = 48 
        self.selected_color_preview_canvas = tk.Canvas(
            info_frame, 
            width=preview_canvas_size, 
            height=preview_canvas_size,
            bg="darkgrey",
            highlightthickness=0
        )
        self.selected_color_preview_canvas.grid(row=0, column=0, rowspan=3, padx=5, pady=5)
        
        self.selected_slot_label = ttk.Label(info_frame, text="Slot: 0")
        self.selected_slot_label.grid(row=0, column=1, padx=(0, 5), sticky="sw")

        self.selected_slot_rgb_label = ttk.Label(info_frame, text="RGB: #000000")
        self.selected_slot_rgb_label.grid(row=1, column=1, padx=(0, 5), sticky="nw")
        
        # --- NEW: Usage Label ---
        self.selected_color_usage_label = ttk.Label(info_frame, text="Usage: N/A")
        self.selected_color_usage_label.grid(row=2, column=1, padx=(0, 5), sticky="nw")
        
        info_frame.grid_rowconfigure(0, weight=1)
        info_frame.grid_rowconfigure(1, weight=1)
        info_frame.grid_rowconfigure(2, weight=1) # Configure new row
        info_frame.grid_columnconfigure(1, weight=1)
        # --- END NEW ---

        rgb_frame = ttk.LabelFrame(left_frame, text="Set Color (RGB 0-7)")
        rgb_frame.pack(pady=(0, 10), fill="x")
        r_label = ttk.Label(rgb_frame, text="R:")
        r_label.grid(row=0, column=0, padx=(5, 0))
        self.rgb_r_var = tk.StringVar(value="0")
        self.rgb_r_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_r_var, width=2)
        self.rgb_r_entry.grid(row=0, column=1)
        g_label = ttk.Label(rgb_frame, text="G:")
        g_label.grid(row=0, column=2, padx=(5, 0))
        self.rgb_g_var = tk.StringVar(value="0")
        self.rgb_g_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_g_var, width=2)
        self.rgb_g_entry.grid(row=0, column=3)
        b_label = ttk.Label(rgb_frame, text="B:")
        b_label.grid(row=0, column=4, padx=(5, 0))
        self.rgb_b_var = tk.StringVar(value="0")
        self.rgb_b_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_b_var, width=2)
        self.rgb_b_entry.grid(row=0, column=5)
        apply_rgb_button = ttk.Button(
            rgb_frame, text="Set", command=self.handle_rgb_apply
        )
        apply_rgb_button.grid(row=0, column=6, padx=5, pady=5)
        reset_palette_button = ttk.Button(
            left_frame,
            text="Reset to MSX2 Default",
            command=self.reset_palette_to_default,
        )
        reset_palette_button.pack(pady=(0, 5), fill="x")
        # Right Frame Contents
        picker_frame = ttk.LabelFrame(right_frame, text="MSX2 512 Color Picker")
        picker_frame.pack(expand=True, fill="both")
        picker_canvas_width = MSX2_PICKER_COLS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_canvas_height = MSX2_PICKER_ROWS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_hbar = ttk.Scrollbar(picker_frame, orient=tk.HORIZONTAL)
        picker_vbar = ttk.Scrollbar(picker_frame, orient=tk.VERTICAL)
        self.msx2_picker_canvas = tk.Canvas(
            picker_frame,
            bg="lightgrey",
            scrollregion=(0, 0, picker_canvas_width, picker_canvas_height),
            xscrollcommand=picker_hbar.set,
            yscrollcommand=picker_vbar.set,
        )
        picker_hbar.config(command=self.msx2_picker_canvas.xview)
        picker_vbar.config(command=self.msx2_picker_canvas.yview)
        self.msx2_picker_canvas.grid(row=0, column=0, sticky="nsew")
        picker_vbar.grid(row=0, column=1, sticky="ns")
        picker_hbar.grid(row=1, column=0, sticky="ew")
        picker_frame.grid_rowconfigure(0, weight=1)
        picker_frame.grid_columnconfigure(0, weight=1)
        self.msx2_picker_canvas.bind("<Button-1>", self.handle_512_picker_click)
        self.draw_512_picker()

    def create_tile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        # Left Frame (Editor, Attributes, Transform)
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10))

        editor_frame = ttk.LabelFrame(
            left_frame, text="Tile Editor (Left: FG, Right: BG)"
        )
        editor_frame.grid(row=0, column=0, pady=(0, 10), sticky="ew") 
        
        self.editor_canvas = tk.Canvas(
            editor_frame,
            width=TILE_WIDTH * EDITOR_PIXEL_SIZE,
            height=TILE_HEIGHT * EDITOR_PIXEL_SIZE,
            bg="grey",
        )
        self.editor_canvas.grid(row=0, column=0, sticky=tk.NSEW) 
        editor_frame.grid_rowconfigure(0, weight=1) 
        editor_frame.grid_columnconfigure(0, weight=0) 

        self.editor_canvas.bind("<Button-1>", self.handle_editor_click)
        self.editor_canvas.bind("<B1-Motion>", self.handle_editor_drag)
        self.editor_canvas.bind(
            "<Button-3>", self.handle_editor_click
        ) 
        self.editor_canvas.bind(
            "<B3-Motion>", self.handle_editor_drag
        ) 
        self.editor_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.editor_canvas.bind("<Leave>", self._reset_cursor)

        self.editor_canvas.bind("<ButtonRelease-1>", self._handle_editor_paint_release, add="+")
        self.editor_canvas.bind("<ButtonRelease-3>", self._handle_editor_paint_release, add="+") # Also for right-button drag painting

        fg_bg_buttons_container = ttk.Frame(editor_frame)
        fg_bg_buttons_container.grid(row=0, column=1, sticky=(tk.N, tk.S), padx=(10, 0))
        editor_frame.grid_columnconfigure(1, weight=0) 
        
        self.attr_row_frames = [] 
        self.attr_fg_labels = []
        self.attr_bg_labels = []

        for r_idx in range(TILE_HEIGHT):
            row_control_frame = ttk.Frame(fg_bg_buttons_container)
            row_control_frame.grid(row=r_idx, column=0, sticky=tk.EW)
            fg_bg_buttons_container.grid_rowconfigure(r_idx, weight=1) 

            row_control_frame.grid_columnconfigure(0, weight=0)  
            row_control_frame.grid_columnconfigure(1, weight=1)  
            row_control_frame.grid_columnconfigure(2, weight=0)  

            row_num_label = ttk.Label(row_control_frame, text=f"{r_idx}:")
            row_num_label.grid(row=0, column=0, padx=(0, 5), sticky=tk.W)

            fg_label = tk.Label(
                row_control_frame, text=" FG ", width=3, relief="raised", borderwidth=2
            )
            fg_label.grid(row=0, column=1, padx=(0, 2), sticky=tk.E) 
            fg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "fg"))
            self.attr_fg_labels.append(fg_label)

            bg_label = tk.Label(
                row_control_frame, text=" BG ", width=3, relief="raised", borderwidth=2
            )
            bg_label.grid(row=0, column=2, padx=(2, 0), sticky=tk.W) 
            bg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "bg"))
            self.attr_bg_labels.append(bg_label)
            
            self.attr_row_frames.append(row_control_frame)

        # --- NEW: Selected Tile Info Frame ---
        selected_tile_info_frame = ttk.LabelFrame(left_frame, text="Selected Tile Info")
        selected_tile_info_frame.grid(row=1, column=0, pady=(10, 5), sticky="ew")
        
        # Add a reference for the preview image to prevent garbage collection
        self.selected_tile_preview_image_ref = None

        preview_canvas_size = 48 # A fixed size for the preview
        self.selected_tile_preview_canvas = tk.Canvas(
            selected_tile_info_frame, 
            width=preview_canvas_size, 
            height=preview_canvas_size, 
            bg="darkgrey",
            highlightthickness=0
        )
        self.selected_tile_preview_canvas.grid(row=0, column=0, rowspan=2, padx=5, pady=5)

        self.selected_tile_info_label = ttk.Label(selected_tile_info_frame, text="Tile: 0")
        self.selected_tile_info_label.grid(row=0, column=1, padx=5, sticky="sw")
        
        self.selected_tile_usage_label = ttk.Label(selected_tile_info_frame, text="Used: N/A")
        self.selected_tile_usage_label.grid(row=1, column=1, padx=5, sticky="nw")
        
        selected_tile_info_frame.grid_rowconfigure(0, weight=1)
        selected_tile_info_frame.grid_rowconfigure(1, weight=1)
        # --- END NEW ---

        transform_frame = ttk.LabelFrame(left_frame, text="Transform")
        transform_frame.grid(row=2, column=0, pady=(0, 5), sticky="ew") # Changed row from 1 to 2
        
        flip_h_button = ttk.Button(
            transform_frame, text="Flip H", command=self.flip_tile_horizontal
        )
        flip_h_button.grid(row=0, column=0, padx=3, pady=3)
        flip_v_button = ttk.Button(
            transform_frame, text="Flip V", command=self.flip_tile_vertical
        )
        flip_v_button.grid(row=0, column=1, padx=3, pady=3)
        rotate_button = ttk.Button(
            transform_frame, text="Rotate", command=self.rotate_tile_90cw
        )
        rotate_button.grid(row=0, column=2, padx=3, pady=3)
        shift_up_button = ttk.Button(
            transform_frame, text="Shift Up", command=self.shift_tile_up
        )
        shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        shift_down_button = ttk.Button(
            transform_frame, text="Shift Down", command=self.shift_tile_down
        )
        shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        shift_left_button = ttk.Button(
            transform_frame, text="Shift Left", command=self.shift_tile_left
        )
        shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        shift_right_button = ttk.Button(
            transform_frame, text="Shift Right", command=self.shift_tile_right
        )
        shift_right_button.grid(row=1, column=3, padx=3, pady=3)
        
        self.mark_unused_tiles_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_tiles
        )
        self.mark_unused_tiles_button.grid(row=3, column=0, pady=(5, 10), sticky="ew") # Changed row from 2 to 3

        # Right Frame (Palette, Tileset Viewer, Buttons)
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(
            row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E)
        ) 
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0) 
        main_frame.grid_columnconfigure(1, weight=1) 

        palette_frame = ttk.LabelFrame(
            right_frame, text="Color Selector (Click to select color for FG/BG)"
        )
        palette_frame.grid(row=0, column=0, pady=(0, 10), sticky=(tk.N, tk.W, tk.E))
        self.tile_editor_palette_canvas = tk.Canvas(
            palette_frame,
            width=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            height=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            borderwidth=0,
            highlightthickness=0,
        )
        self.tile_editor_palette_canvas.grid(row=0, column=0)
        self.tile_editor_palette_canvas.bind(
            "<Button-1>", self.handle_tile_editor_palette_click
        )

        viewer_frame = ttk.LabelFrame(right_frame, text="Tileset (Click to select for edition)")
        viewer_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(0, weight=0) 
        right_frame.grid_rowconfigure(1, weight=1) 
        right_frame.grid_rowconfigure(2, weight=0) 
        right_frame.grid_rowconfigure(3, weight=0) # Row 3 is now gone from this frame
        right_frame.grid_columnconfigure(0, weight=1) 

        viewer_canvas_width = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1
        num_rows_in_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS)
        viewer_canvas_height = num_rows_in_viewer * (VIEWER_TILE_SIZE + 1) + 1
        viewer_hbar = ttk.Scrollbar(viewer_frame, orient=tk.HORIZONTAL)
        viewer_vbar = ttk.Scrollbar(viewer_frame, orient=tk.VERTICAL)
        self.tileset_canvas = tk.Canvas(
            viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width, viewer_canvas_height),
            xscrollcommand=viewer_hbar.set,
            yscrollcommand=viewer_vbar.set,
        )
        viewer_hbar.config(command=self.tileset_canvas.xview)
        viewer_vbar.config(command=self.tileset_canvas.yview)
        self.tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        viewer_frame.grid_rowconfigure(0, weight=1)
        viewer_frame.grid_columnconfigure(0, weight=1)

        self.tileset_canvas.bind("<Button-1>", self.handle_tileset_click)
        self.tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.tileset_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+") # Added
        self.tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")   # Added
        self.tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")   # Added

        tile_button_frame = ttk.Frame(right_frame)
        tile_button_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(5, 0))

        self.add_tile_button = ttk.Button(
            tile_button_frame, text="Add New", command=self.handle_add_tile
        )
        self.add_tile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.add_many_tiles_button = ttk.Button(
            tile_button_frame, text="Add Many...", command=self.handle_add_many_tiles
        )
        self.add_many_tiles_button.pack(side=tk.LEFT, padx=3)

        self.insert_tile_button = ttk.Button(
            tile_button_frame, text="Insert", command=self.handle_insert_tile
        )
        self.insert_tile_button.pack(side=tk.LEFT, padx=3)

        self.delete_tile_button = ttk.Button(
            tile_button_frame, text="Delete", command=self.handle_delete_tile
        )
        self.delete_tile_button.pack(side=tk.LEFT, padx=3)
        
        # --- MODIFIED: Moved and repurposed this label ---
        self.tile_info_label = ttk.Label(tile_button_frame, text="Tiles: 0")
        self.tile_info_label.pack(side=tk.LEFT, padx=(10, 0), anchor=tk.W)

    def create_supertile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10)) 

        def_frame = ttk.LabelFrame(
            left_frame, text="Supertile Definition (Click to place selected tile)"
        )
        def_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew") 
        
        def_canvas_width_actual = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
        def_canvas_height_actual = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
        def_canvas_width_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_width_actual)
        def_canvas_height_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_height_actual)

        self.supertile_def_canvas = tk.Canvas(
            def_frame, width=def_canvas_width_actual, height=def_canvas_height_actual, bg="darkgrey"
        )
        self.supertile_def_canvas.grid(row=0, column=0, sticky="nw") 
        def_frame.grid_rowconfigure(0, weight=0) 
        def_frame.grid_columnconfigure(0, weight=0)

        self.supertile_def_canvas.bind("<Button-1>", self.handle_supertile_def_click)
        self.supertile_def_canvas.bind("<B1-Motion>", self.handle_supertile_def_drag)
        self.supertile_def_canvas.bind(
            "<ButtonRelease-1>", self.handle_supertile_def_release
        )
        self.supertile_def_canvas.bind(
            "<Button-3>", self.handle_supertile_def_right_click
        )
        self.supertile_def_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.supertile_def_canvas.bind("<Leave>", self._reset_cursor)

        info_labels_frame = ttk.Frame(left_frame)
        info_labels_frame.grid(
            row=1, column=0, pady=(0, 5), sticky="ew"
        )
        self.supertile_def_info_label = ttk.Label(
            info_labels_frame, text=f"Editing Supertile: {current_supertile_index}" 
        )
        self.supertile_def_info_label.pack(anchor=tk.W)
        self.supertile_tile_select_label = ttk.Label(
            info_labels_frame,
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}", 
        )
        self.supertile_tile_select_label.pack(anchor=tk.W)

        st_transform_frame = ttk.LabelFrame(left_frame, text="Transform Supertile")
        st_transform_frame.grid(
            row=2, column=0, pady=(0, 5), sticky="ew"
        )

        st_flip_h_button = ttk.Button(
            st_transform_frame, text="Flip H", command=self.flip_supertile_horizontal
        )
        st_flip_h_button.grid(row=0, column=0, padx=3, pady=(5, 3))
        st_flip_v_button = ttk.Button(
            st_transform_frame, text="Flip V", command=self.flip_supertile_vertical
        )
        st_flip_v_button.grid(row=0, column=1, padx=3, pady=(5, 3))
        
        self.st_rotate_button = ttk.Button(
            st_transform_frame, text="Rotate", command=self.rotate_supertile_90cw
        )
        self.st_rotate_button.grid(row=0, column=2, padx=3, pady=(5, 3))

        st_shift_up_button = ttk.Button(
            st_transform_frame, text="Shift Up", command=self.shift_supertile_up
        )
        st_shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        st_shift_down_button = ttk.Button(
            st_transform_frame, text="Shift Down", command=self.shift_supertile_down
        )
        st_shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        st_shift_left_button = ttk.Button(
            st_transform_frame, text="Shift Left", command=self.shift_supertile_left
        )
        st_shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        st_shift_right_button = ttk.Button(
            st_transform_frame, text="Shift Right", command=self.shift_supertile_right
        )
        st_shift_right_button.grid(row=1, column=3, padx=3, pady=3)

        self.mark_unused_st_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_supertiles_and_tiles
        )
        self.mark_unused_st_button.grid(row=3, column=0, pady=(5, 10), sticky="ew")

        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E))
        main_frame.grid_columnconfigure(1, weight=1)
        main_frame.grid_rowconfigure(0, weight=1)

        tileset_viewer_frame = ttk.LabelFrame(
            right_frame, text="Tileset (Click to select tile to draw supertile)"
        )
        tileset_viewer_frame.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0, 10)
        )
        right_frame.grid_rowconfigure(0, weight=1) 

        viewer_canvas_width_tiles = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1
        num_rows_in_tile_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS) 
        viewer_canvas_height_tiles = num_rows_in_tile_viewer * (VIEWER_TILE_SIZE + 1) + 1

        st_viewer_hbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.HORIZONTAL)
        st_viewer_vbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.VERTICAL)
        self.st_tileset_canvas = tk.Canvas(
            tileset_viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width_tiles, viewer_canvas_height_tiles),
            xscrollcommand=st_viewer_hbar.set,
            yscrollcommand=st_viewer_vbar.set,
        )

        st_viewer_hbar.config(command=self.st_tileset_canvas.xview)
        st_viewer_vbar.config(command=self.st_tileset_canvas.yview)
        self.st_tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        st_viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        tileset_viewer_frame.grid_rowconfigure(0, weight=1)
        tileset_viewer_frame.grid_columnconfigure(0, weight=1)

        self.st_tileset_canvas.bind("<Button-1>", self.handle_st_tileset_click)
        self.st_tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.st_tileset_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )
        self.st_tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        st_selector_frame = ttk.LabelFrame(
            right_frame, text="Supertile Selector (Click to select for edition)"
        )
        st_selector_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(1, weight=1) 

        target_selector_width = 256 
        self.supertile_selector_canvas = tk.Canvas(
            st_selector_frame,
            bg="lightgrey",
            scrollregion=(0, 0, 1, 1), 
            width=target_selector_width 
        )
        st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        
        # --- Modified scrollbar commands for supertile_selector_canvas ---
        def st_sel_canvas_xview_wrapper(*args):
            self.debug(f"[DEBUG] ST Editor - Supertile Selector XScrollbar: args={args}")
            self.supertile_selector_canvas.xview(*args)
            # Potentially trigger redraw if lazy loading images horizontally
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)


        def st_sel_canvas_yview_wrapper(*args):
            self.debug(f"[DEBUG] ST Editor - Supertile Selector YScrollbar: args={args}")
            self.supertile_selector_canvas.yview(*args)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)

        self.supertile_selector_canvas.config(
            xscrollcommand=st_sel_hbar.set,
            yscrollcommand=st_sel_vbar.set
        )
        st_sel_hbar.config(command=st_sel_canvas_xview_wrapper) # Use wrapper
        st_sel_vbar.config(command=st_sel_canvas_yview_wrapper) # Use wrapper
        # --- End of modification ---

        self.supertile_selector_canvas.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E)
        )
        st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)

        self.supertile_selector_canvas.bind(
            "<Button-1>", self.handle_supertile_selector_click
        )
        self.supertile_selector_canvas.bind(
            "<B1-Motion>", self.handle_viewer_drag_motion
        )
        self.supertile_selector_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )
        self.supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        bottom_controls_frame = ttk.Frame(right_frame)
        bottom_controls_frame.grid(
            row=2, column=0, sticky="ew", pady=(5, 0)
        )
        right_frame.grid_rowconfigure(2, weight=0)

        self.add_supertile_button = ttk.Button(
            bottom_controls_frame, text="Add New", command=self.handle_add_supertile
        )
        self.add_supertile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.add_many_supertiles_button = ttk.Button(
            bottom_controls_frame, text="Add Many...", command=self.handle_add_many_supertiles
        )
        self.add_many_supertiles_button.pack(side=tk.LEFT, padx=3)

        self.insert_supertile_button = ttk.Button(
            bottom_controls_frame, text="Insert", command=self.handle_insert_supertile
        )
        self.insert_supertile_button.pack(side=tk.LEFT, padx=3)

        self.delete_supertile_button = ttk.Button(
            bottom_controls_frame, text="Delete", command=self.handle_delete_supertile
        )
        self.delete_supertile_button.pack(side=tk.LEFT, padx=3)

        self.supertile_sel_info_label = ttk.Label(
            bottom_controls_frame, text=f"Supertiles: {num_supertiles}" 
        )
        self.supertile_sel_info_label.pack(side=tk.LEFT, anchor=tk.W, padx=(10, 0))

    def create_map_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        self.map_paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.map_paned_window.pack(expand=True, fill="both", padx=5, pady=5)

        map_area_frame = ttk.Frame(self.map_paned_window, padding=(0,0,5,0)) 
        self.map_paned_window.add(map_area_frame, weight=3) 
        self.map_editor_map_pane_container = map_area_frame 

        palette_area_frame = ttk.Frame(self.map_paned_window, padding=(5,0,0,0)) 
        self.map_paned_window.add(palette_area_frame, weight=1) 
        self.map_editor_palette_pane_container = palette_area_frame

        map_area_frame.grid_columnconfigure(0, weight=1)
        map_area_frame.grid_rowconfigure(3, weight=1) 
        
        controls_frame = ttk.Frame(map_area_frame)
        controls_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        size_label = ttk.Label(controls_frame, text="Map Size:")
        size_label.grid(row=0, column=0, padx=(0, 5), pady=2)
        self.map_size_label = ttk.Label(controls_frame, text=f"{map_width} x {map_height}")
        self.map_size_label.grid(row=0, column=1, padx=(0, 10), pady=2)
        zoom_frame = ttk.Frame(controls_frame)
        zoom_frame.grid(row=0, column=2, padx=(10, 0), pady=2)
        zoom_out_button = ttk.Button(zoom_frame,text="-",width=2,command=lambda: self.change_map_zoom_mult(1 / 1.25))
        zoom_out_button.pack(side=tk.LEFT)
        self.map_zoom_label = ttk.Label(zoom_frame, text="100%", width=5, anchor=tk.CENTER)
        self.map_zoom_label.pack(side=tk.LEFT, padx=2)
        zoom_in_button = ttk.Button(zoom_frame,text="+",width=2,command=lambda: self.change_map_zoom_mult(1.25))
        zoom_in_button.pack(side=tk.LEFT)
        zoom_reset_button = ttk.Button(zoom_frame, text="Reset", width=5, command=lambda: self.set_map_zoom(1.0))
        zoom_reset_button.pack(side=tk.LEFT, padx=(5, 0))
        self.map_coords_label = ttk.Label(controls_frame, text="ST Coords: -, -", width=15)
        self.map_coords_label.grid(row=0, column=3, padx=(10, 5), sticky="w")

        win_controls_frame = ttk.Frame(map_area_frame)
        win_controls_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        win_view_check = ttk.Checkbutton(win_controls_frame,text="Show Window View",variable=self.show_window_view,command=self.toggle_window_view)
        win_view_check.grid(row=0, column=0, padx=5, sticky="w")
        win_w_label = ttk.Label(win_controls_frame, text="Width:")
        win_w_label.grid(row=0, column=1, padx=(10, 0))
        self.win_view_w_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_w, width=4)
        self.win_view_w_entry.grid(row=0, column=2)
        win_h_label = ttk.Label(win_controls_frame, text="Height:")
        win_h_label.grid(row=0, column=3, padx=(5, 0))
        self.win_view_h_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_h, width=4)
        self.win_view_h_entry.grid(row=0, column=4)
        win_apply_button = ttk.Button(win_controls_frame,text="Apply Size",command=self.apply_window_size_from_entries)
        win_apply_button.grid(row=0, column=5, padx=5)
        self.win_view_w_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())
        self.win_view_h_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())

        grid_controls_frame = ttk.Frame(map_area_frame)
        grid_controls_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        st_grid_check = ttk.Checkbutton(grid_controls_frame,text="Show Supertile Grid (Press 'G' to Cycle Colors)",variable=self.show_supertile_grid,command=self.toggle_supertile_grid)
        st_grid_check.grid(row=0, column=0, padx=5, sticky="w")
        
        map_area_frame.update_idletasks() 
        controls_frame_width = controls_frame.winfo_reqwidth()
        win_controls_frame_width = win_controls_frame.winfo_reqwidth()
        grid_controls_frame_width = grid_controls_frame.winfo_reqwidth()
        self.map_controls_min_width = max(controls_frame_width, win_controls_frame_width, grid_controls_frame_width) + 10 
        self.debug(f"[DEBUG] create_map_editor_widgets: Calculated map_controls_min_width = {self.map_controls_min_width}")

        map_canvas_frame = ttk.LabelFrame(map_area_frame, text="Map")
        map_canvas_frame.grid(row=3, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_canvas_frame.grid_rowconfigure(0, weight=1)
        map_canvas_frame.grid_columnconfigure(0, weight=1)
        self.map_hbar = ttk.Scrollbar(map_canvas_frame, orient=tk.HORIZONTAL)
        self.map_vbar = ttk.Scrollbar(map_canvas_frame, orient=tk.VERTICAL)
        self.map_canvas = tk.Canvas(map_canvas_frame,bg="black", xscrollcommand=self.map_hbar.set,yscrollcommand=self.map_vbar.set)
        self.map_hbar.config(command=self.map_canvas.xview)
        self.map_vbar.config(command=self.map_canvas.yview)
        self.map_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.map_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.map_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        self.map_canvas.bind("<Configure>", self._on_map_canvas_configure)

        palette_area_frame.grid_rowconfigure(0, weight=1)
        palette_area_frame.grid_columnconfigure(0, weight=1)
        st_selector_frame = ttk.LabelFrame(palette_area_frame, text="Supertile Palette (Click to select supertile to draw map)")
        st_selector_frame.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0,5))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)
        padding = 1 
        min_one_supertile_preview_width = (self.supertile_grid_width * TILE_WIDTH) + (2 * padding)
        min_one_supertile_preview_width = max(32, min_one_supertile_preview_width) 
        self.map_supertile_selector_canvas = tk.Canvas(st_selector_frame,bg="lightgrey", scrollregion=(0, 0, 1, 1), width=min_one_supertile_preview_width)
        map_st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        map_st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)

        # --- Modified scrollbar commands for map_supertile_selector_canvas ---
        def map_st_sel_canvas_xview_wrapper(*args):
            self.debug(f"[DEBUG] Map Editor - Supertile Palette XScrollbar: args={args}")
            self.map_supertile_selector_canvas.xview(*args)
            # Potentially trigger redraw if lazy loading images horizontally
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

        def map_st_sel_canvas_yview_wrapper(*args):
            self.debug(f"[DEBUG] Map Editor - Supertile Palette YScrollbar: args={args}")
            self.map_supertile_selector_canvas.yview(*args)
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

        self.map_supertile_selector_canvas.config(xscrollcommand=map_st_sel_hbar.set, yscrollcommand=map_st_sel_vbar.set)
        map_st_sel_hbar.config(command=map_st_sel_canvas_xview_wrapper) # Use wrapper
        map_st_sel_vbar.config(command=map_st_sel_canvas_yview_wrapper) # Use wrapper
        # --- End of modification ---

        self.map_supertile_selector_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        map_st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        self.map_supertile_select_label = ttk.Label(palette_area_frame, text=f"Selected Supertile for Painting: {selected_supertile_for_map}")
        self.map_supertile_select_label.grid(row=1, column=0, sticky=tk.W, pady=(0, 0))
        self.map_supertile_selector_canvas.bind("<Button-1>", self.handle_map_supertile_selector_click)
        self.map_supertile_selector_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.map_supertile_selector_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.map_supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")
        
        self.map_editor_palette_pane_container.bind("<Configure>", self._on_palette_pane_configure_for_redraw_only)
        self.map_paned_window.bind("<ButtonRelease-1>", self._enforce_palette_min_width_on_release)

    # --- Use this as the SINGLE definition for setting up bindings ---
    def _setup_map_canvas_bindings(self):
        """Sets up ALL event bindings for the map canvas and related root bindings.
        Includes initial unbind step for robustness.
        """
        canvas = self.map_canvas

        # --- Unbind ALL PREVIOUSLY POTENTIAL MAP CANVAS BINDINGS ---
        canvas.unbind("<Button-1>")
        canvas.unbind("<B1-Motion>")
        canvas.unbind("<ButtonRelease-1>")
        canvas.unbind("<Button-3>")
        canvas.unbind("<Control-ButtonPress-1>")
        canvas.unbind("<Control-B1-Motion>")
        canvas.unbind("<Shift-ButtonPress-1>") 
        canvas.unbind("<Shift-B1-Motion>") 
        canvas.unbind("<Shift-ButtonRelease-1>") 
        canvas.unbind("<Control-MouseWheel>")
        canvas.unbind("<Control-Button-4>")
        canvas.unbind("<Control-Button-5>")
        canvas.unbind("<FocusIn>")
        canvas.unbind("<FocusOut>")
        canvas.unbind("<KeyPress-w>")
        canvas.unbind("<KeyPress-a>")
        canvas.unbind("<KeyPress-s>")
        canvas.unbind("<KeyPress-d>")
        canvas.unbind("<KeyPress-W>")
        canvas.unbind("<KeyPress-A>")
        canvas.unbind("<KeyPress-S>")
        canvas.unbind("<KeyPress-D>")
        canvas.unbind("<KeyPress-Escape>") 
        canvas.unbind("<Enter>")
        canvas.unbind("<Leave>")
        canvas.unbind("<Motion>")
        canvas.unbind("<MouseWheel>")
        canvas.unbind("<Button-4>")
        canvas.unbind("<Button-5>")
        # --- End Unbind ---

        # --- Mouse Button 1 (Primary) - Checks Shift/Ctrl internally ---
        canvas.bind("<Button-1>", self.handle_map_click_or_drag_start)
        canvas.bind("<B1-Motion>", self.handle_map_drag)
        canvas.bind("<ButtonRelease-1>", self.handle_map_drag_release)

        # --- Mouse Button 3 (Right-Click for Selection) ---
        canvas.bind("<Button-3>", self.handle_map_canvas_right_click)

        # --- Panning (Ctrl + Mouse Button 1) - Checks Shift internally ---
        canvas.bind("<Control-ButtonPress-1>", self.handle_pan_start)
        canvas.bind("<Control-B1-Motion>", self.handle_pan_motion) 

        # --- Selection (Shift + Mouse Button 1) ---
        canvas.bind("<Shift-ButtonPress-1>", self.handle_map_selection_start)
        canvas.bind("<Shift-B1-Motion>", self.handle_map_selection_motion)
        canvas.bind("<Shift-ButtonRelease-1>", self.handle_map_selection_release)

        # --- Zooming (Ctrl + Mouse Wheel) ---
        canvas.bind("<Control-MouseWheel>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-4>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-5>", self.handle_map_zoom_scroll)
        
        # --- Standard Scrolling (No Modifiers + Mouse Wheel) ---
        canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        canvas.bind("<Button-4>", self._on_mousewheel_scroll)  
        canvas.bind("<Button-5>", self._on_mousewheel_scroll)  

        # --- Keyboard ---
        canvas.bind("<FocusIn>", lambda e: self.map_canvas.focus_set())
        canvas.bind("<FocusOut>", lambda e: self._update_map_cursor())
        canvas.bind("<KeyPress-w>", self.handle_map_keypress)
        canvas.bind("<KeyPress-a>", self.handle_map_keypress)
        canvas.bind("<KeyPress-s>", self.handle_map_keypress)
        canvas.bind("<KeyPress-d>", self.handle_map_keypress)
        canvas.bind("<KeyPress-W>", self.handle_map_keypress)
        canvas.bind("<KeyPress-A>", self.handle_map_keypress)
        canvas.bind("<KeyPress-S>", self.handle_map_keypress)
        canvas.bind("<KeyPress-D>", self.handle_map_keypress)
        canvas.bind("<KeyPress-Escape>", self.handle_map_escape)

        # --- Modifier Key State Tracking (Bound to root window) ---
        self.root.bind("<KeyPress-Control_L>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyPress-Control_R>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyRelease-Control_L>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyRelease-Control_R>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyPress-Shift_L>", self.handle_shift_press, add="+")
        self.root.bind("<KeyPress-Shift_R>", self.handle_shift_press, add="+")
        self.root.bind("<KeyRelease-Shift_L>", self.handle_shift_release, add="+")
        self.root.bind("<KeyRelease-Shift_R>", self.handle_shift_release, add="+")

        # --- Mouse Enter/Leave/Motion Canvas (for cursor updates) ---
        canvas.bind("<Enter>", self.handle_canvas_enter)
        canvas.bind("<Leave>", self.handle_canvas_leave)
        canvas.bind("<Motion>", self._update_map_cursor_and_coords)

        # --- Scrollbar Interaction (Update map canvas AND minimap) ---
        if hasattr(self, "map_hbar") and self.map_hbar:
            self.map_hbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_hbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event) 
        if hasattr(self, "map_vbar") and self.map_vbar:
            self.map_vbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_vbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event)

    # --- Drawing Functions ---
    def update_all_displays(self, changed_level="all"):
        """Updates UI elements ONLY for the currently VISIBLE tab,
        based on the level of change indicated by changed_level.
        Also handles global updates like palette if necessary.
        """
        # Get current visible tab index (safer way)
        current_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab = self.notebook.select()
                if selected_tab:
                    current_tab_index = self.notebook.index(selected_tab)
        except tk.TclError:
            print("Warning: Could not get current tab index in update_all_displays.")
            return  # Avoid errors if notebook state is weird

        # --- Always handle Palette changes first, as they affect look of all tabs ---
        palette_changed = changed_level in ["all", "palette"]
        if palette_changed:
            # Update the palette editor widgets regardless of visibility
            # (They are cheap to update and data source for others)
            self.draw_current_palette()
            self.update_palette_info_labels()
            # Cache invalidation for palette changes is handled by the caller
            # (e.g., handle_rgb_apply, reset_palette...)

        # --- Update widgets ONLY for the VISIBLE tab ---

        # Palette Editor Tab (Index 0)
        if current_tab_index == 0:
            # Widgets already updated above if palette_changed is True.
            # No other data changes directly affect only this tab's display.
            self.debug("[DEBUG]Updating Palette Tab (Visible)")

        # Tile Editor Tab (Index 1)
        elif current_tab_index == 1:
            # Update if tile data changed OR palette changed (affects colors)
            if changed_level in ["all", "tile_select", "tile_edit"] or palette_changed:
                self.debug(f"[DEBUG]Updating Tile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_editor_canvas()
                self.draw_attribute_editor()
                self.draw_palette()  # Uses active_msx_palette
                self.draw_tileset_viewer(
                    self.tileset_canvas, current_tile_index
                )  # Main viewer
                self.update_tile_info_label()
                recalc_usage = changed_level != 'tile_edit'
                self._update_selected_tile_info_panel(update_usage_counts=recalc_usage)

        # Supertile Editor Tab (Index 2)
        elif current_tab_index == 2:
            # Update if supertile data changed, underlying tile data changed, OR palette changed
            if changed_level in ["all", "supertile", "tile_select", "tile_edit"] or palette_changed:
                self.debug(f"[DEBUG]Updating Supertile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_supertile_definition_canvas()  # Uses tiles & palette
                self.draw_tileset_viewer(
                    self.st_tileset_canvas, selected_tile_for_supertile
                )  # Uses tiles & palette
                self.draw_supertile_selector(
                    self.supertile_selector_canvas, current_supertile_index
                )  # Uses tiles & palette
                self.update_supertile_info_labels()
                # We intentionally DO NOT update self.map_supertile_selector_canvas here.

        # Map Editor Tab (Index 3)
        elif current_tab_index == 3:
            # Update if map data changed, underlying supertile/tile data changed, OR palette changed
            if changed_level in ["all", "map", "supertile", "tile_select", "tile_edit"] or palette_changed:
                self.debug(f"[DEBUG]Updating Map Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                # Map canvas redraw is complex, redraw if map changed OR dependencies changed
                self.draw_map_canvas()  # Handles overlays, uses ST/Tiles/Palette
                self.draw_supertile_selector(
                    self.map_supertile_selector_canvas, selected_supertile_for_map
                )  # Uses ST/Tiles/Palette
                self.update_map_info_labels()  # Update size/zoom/window entries
                self.draw_minimap()  # Uses Map/ST/Tiles/Palette

    # ... (draw_editor_canvas, draw_attribute_editor, draw_palette unchanged) ...
    def draw_editor_canvas(self):
        self.editor_canvas.delete("all")
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        pattern = tileset_patterns[current_tile_index]
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            for c in range(TILE_WIDTH):
                try:
                    pixel_val = pattern[r][c]
                except IndexError:
                    pixel_val = 0
                color = fg_color if pixel_val == 1 else bg_color
                x1 = c * EDITOR_PIXEL_SIZE
                y1 = r * EDITOR_PIXEL_SIZE
                x2 = x1 + EDITOR_PIXEL_SIZE
                y2 = y1 + EDITOR_PIXEL_SIZE
                self.editor_canvas.create_rectangle(
                    x1, y1, x2, y2, fill=color, outline="darkgrey", width=1
                )

    def draw_attribute_editor(self):
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color_hex = self.active_msx_palette[fg_idx]
                bg_color_hex = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color_hex, bg_color_hex = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            self.attr_fg_labels[r].config(
                bg=fg_color_hex, fg=get_contrast_color(fg_color_hex)
            )
            self.attr_bg_labels[r].config(
                bg=bg_color_hex, fg=get_contrast_color(bg_color_hex)
            )

    def draw_palette(self):  # Renamed draw_palette to this for clarity
        """Draws the 16-color selector palette in the Tile Editor tab."""
        canvas = self.tile_editor_palette_canvas
        canvas.delete("all")
        size = PALETTE_SQUARE_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]  # Use active palette
            outline_color = "red" if i == selected_color_index else "grey"
            outline_width = 2 if i == selected_color_index else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_sel_{i}",
            )

    # --- vvv Palette Editor Drawing vvv ---
    def draw_current_palette(self):
        canvas = self.current_palette_canvas
        canvas.delete("all")
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]
            outline_color = "red" if i == self.selected_palette_slot else "grey"
            outline_width = 3 if i == self.selected_palette_slot else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_slot_{i}",
            )

    def draw_512_picker(self):
        canvas = self.msx2_picker_canvas
        canvas.delete("all")
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        for i in range(512):
            row, col = divmod(i, cols)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            hex_color = msx2_512_colors_hex[i]
            r, g, b = msx2_512_colors_rgb7[i]
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=hex_color,
                outline="grey",
                width=1,
                tags=(f"msx2_picker_{i}", f"msx2_rgb_{r}_{g}_{b}"),
            )

    def update_palette_info_labels(self):
        slot = self.selected_palette_slot
        if 0 <= slot < 16:
            color_hex = self.active_msx_palette[slot]
            rgb7 = (-1, -1, -1)
            try:
                # Find the corresponding 3-bit RGB values for the hex color
                idx512 = msx2_512_colors_hex.index(color_hex)
                rgb7 = msx2_512_colors_rgb7[idx512]
            except ValueError:
                pass # Color is not in the standard MSX2 512 set

            # Update text labels
            self.selected_slot_label.config(text=f"Slot: {slot}")
            self.selected_slot_rgb_label.config(
                text=f"RGB: {color_hex} ({rgb7[0]},{rgb7[1]},{rgb7[2]})"
            )
            self.rgb_r_var.set(str(rgb7[0]) if rgb7[0] != -1 else "?")
            self.rgb_g_var.set(str(rgb7[1]) if rgb7[1] != -1 else "?")
            self.rgb_b_var.set(str(rgb7[2]) if rgb7[2] != -1 else "?")
            
            # Draw the color on the new preview canvas
            if hasattr(self, 'selected_color_preview_canvas'):
                canvas = self.selected_color_preview_canvas
                canvas.delete("all")
                canvas_width = canvas.winfo_width()
                canvas_height = canvas.winfo_height()
                # Ensure the canvas has a valid size before drawing
                if canvas_width > 1 and canvas_height > 1:
                    canvas.create_rectangle(
                        0, 0, canvas_width, canvas_height, 
                        fill=color_hex, 
                        outline=color_hex # Use same color for outline to avoid border
                    )
        
            if hasattr(self, 'selected_color_usage_label'):
                _, line_refs, tile_refs = self._calculate_single_color_usage(slot)
                self.selected_color_usage_label.config(text=f"Used in {line_refs} lines, in {tile_refs} tiles.")
        else:
            # Clear info if no valid slot is selected
            self.selected_slot_label.config(text="Slot: -")
            self.selected_slot_rgb_label.config(text="RGB: -")
            self.rgb_r_var.set("")
            self.rgb_g_var.set("")
            self.rgb_b_var.set("")
            if hasattr(self, 'selected_color_preview_canvas'):
                self.selected_color_preview_canvas.delete("all")
            if hasattr(self, 'selected_color_usage_label'):
                self.selected_color_usage_label.config(text="Usage: N/A")

    def draw_tileset_viewer(self, canvas, highlighted_tile_index):
        """Draws tileset viewer, highlighting selected, dragged, or unused tile."""
        # Check if drag is active and involves a tile from *any* tileset viewer
        is_dragging_tile = self.drag_active and self.drag_item_type == "tile"
        dragged_tile_index = self.drag_start_index if is_dragging_tile else -1

        try:
            canvas.delete("all")
            padding = 1
            size = VIEWER_TILE_SIZE
            max_rows = math.ceil(num_tiles_in_set / NUM_TILES_ACROSS)
            canvas_height = max(1, max_rows * (size + padding) + padding)  
            canvas_width = max(
                1, NUM_TILES_ACROSS * (size + padding) + padding
            )  
            str_scroll = f"0 0 {float(canvas_width)} {float(canvas_height)}"

            # Safely get current scroll region
            current_scroll = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                if isinstance(current_scroll_val, tuple):
                    current_scroll = " ".join(map(str, current_scroll_val))
                else:
                    current_scroll = str(current_scroll_val)
            except tk.TclError:
                # Canvas might not be fully ready
                pass

            # Update scrollregion if needed
            if current_scroll != str_scroll:
                canvas.config(scrollregion=(0, 0, canvas_width, canvas_height))

            # Draw each tile
            for i in range(num_tiles_in_set):
                tile_r, tile_c = divmod(i, NUM_TILES_ACROSS)
                base_x = tile_c * (size + padding) + padding
                base_y = tile_r * (size + padding) + padding

                # Get cached image
                img = self.create_tile_image(i, size)
                canvas.create_image(
                    base_x,
                    base_y,
                    image=img,
                    anchor=tk.NW,
                    tags=(f"tile_img_{i}", "tile_image"),
                )

                # Determine outline style
                outline_color = "grey" 
                outline_width = 1
                if i == dragged_tile_index: # Highest priority: item being dragged
                    outline_color = "yellow" 
                    outline_width = 3
                elif i == highlighted_tile_index: # Next priority: current selection
                    outline_color = "red"
                    outline_width = 2
                elif i in self.marked_unused_tiles: # Then, check for unused highlight
                    outline_color = "blue" # Blue for unused
                    outline_width = 3 # Bold blue (width 3)

                # Draw the border rectangle
                bx1 = max(0, base_x - padding / 2)
                by1 = max(0, base_y - padding / 2)
                bx2 = base_x + size + padding / 2
                by2 = base_y + size + padding / 2
                canvas.create_rectangle(
                    bx1,
                    by1,
                    bx2,
                    by2,
                    outline=outline_color,
                    width=outline_width,
                    tags=f"tile_border_{i}",
                )

        except tk.TclError as e:
            # Catch errors if the canvas is destroyed during redraw
            print(f"TclError during draw_tileset_viewer: {e}")
        except Exception as e:
            print(f"Unexpected error during draw_tileset_viewer: {e}")

    def update_tile_info_label(self):
        # This label now only shows the total count
        self.tile_info_label.config(text=f"Tiles: {num_tiles_in_set}")

    def draw_supertile_definition_canvas(self):
        canvas = self.supertile_def_canvas
        canvas.delete("all")
        if not (0 <= current_supertile_index < num_supertiles):
            return

        definition = supertiles_data[current_supertile_index]
        
        # Ensure definition has expected structure based on current project dimensions
        # This is a safeguard. Data should ideally be consistent.
        if not definition or len(definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(definition[0]) != self.supertile_grid_width)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} definition dimensions mismatch in draw_supertile_definition_canvas.")
            # Optionally draw an error indicator on the canvas
            canvas_w = canvas.winfo_width()
            canvas_h = canvas.winfo_height()
            canvas.create_text(canvas_w/2, canvas_h/2, text="Dim Mismatch!", fill="red", anchor="center")
            return

        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32x32 pixels)
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 

        for r_def in range(self.supertile_grid_height):
            for c_def in range(self.supertile_grid_width):
                try:
                    tile_idx = definition[r_def][c_def]
                except IndexError: # Should be caught by the check above, but for safety
                    self.debug(f"[DEBUG]Error drawing ST def: index out of bounds for ST {current_supertile_index} at {r_def},{c_def}")
                    tile_idx = 0 # Default to tile 0 on error

                base_x = c_def * mini_tile_display_size
                base_y = r_def * mini_tile_display_size
                
                img = self.create_tile_image(tile_idx, mini_tile_display_size)
                canvas.create_image(
                    base_x, base_y, image=img, anchor=tk.NW, tags=f"def_tile_{r_def}_{c_def}"
                )
                canvas.create_rectangle(
                    base_x, base_y, base_x + mini_tile_display_size, base_y + mini_tile_display_size, outline="grey"
                )
    
    def draw_supertile_selector(self, canvas, highlighted_supertile_index):
        is_dragging_supertile = self.drag_active and self.drag_item_type == "supertile"
        dragged_supertile_index = self.drag_start_index if is_dragging_supertile else -1

        try:
            if not canvas.winfo_exists():
                return
            canvas.delete("all") # Clear previous items
            
            item_pixel_w = self.supertile_grid_width * TILE_WIDTH
            item_pixel_h = self.supertile_grid_height * TILE_HEIGHT
            padding = 1 

            if item_pixel_w <= 0 or item_pixel_h <= 0:
                self.debug(f"[DEBUG] draw_supertile_selector: Invalid item_pixel_w/h ({item_pixel_w}x{item_pixel_h}). Aborting.")
                return

            actual_canvas_width = canvas.winfo_width()
            if actual_canvas_width <= 1: 
                 # Canvas not yet sized, reschedule.
                 # Ensure we don't get into an infinite after loop if it never gets size.
                 # Add a counter or a flag if this becomes an issue.
                 canvas.after(100, lambda: self.draw_supertile_selector(canvas, highlighted_supertile_index))
                 return
            
            self.debug(f"[DEBUG] draw_supertile_selector: Actual Canvas Width: {actual_canvas_width}, Item Pixel W: {item_pixel_w}")

            # Calculate how many items can fit, ensuring at least one if possible.
            if item_pixel_w + 2 * padding > actual_canvas_width : # Not even one fits with padding on both sides
                items_across = 0 # Or 1 if you want to force one and let it clip/be tiny
                if item_pixel_w <= actual_canvas_width : # Fits without padding
                    items_across = 1
                # else: it's wider than canvas, items_across remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                items_across = (actual_canvas_width - padding) // (item_pixel_w + padding)
            
            items_across = max(1, items_across) # Ensure at least 1 item is planned if possible, even if it overflows slightly
                                                # or if the canvas is very narrow. If item_pixel_w itself is > canvas_width,
                                                # it will still draw 1 item that will be clipped by the canvas viewport.

            self.debug(f"[DEBUG] draw_supertile_selector: Calculated items_across: {items_across}")

            num_logical_rows = math.ceil(num_supertiles / items_across) if items_across > 0 else num_supertiles
            # Scrollregion width should be based on the calculated items_across to fit them snugly
            scroll_content_width = (items_across * item_pixel_w) + ((items_across + 1) * padding)
            scroll_content_height = (num_logical_rows * item_pixel_h) + ((num_logical_rows + 1) * padding)
            scroll_content_width = max(1.0, float(scroll_content_width))
            scroll_content_height = max(1.0, float(scroll_content_height))

            str_scroll = f"0 0 {scroll_content_width} {scroll_content_height}"
            current_scroll_val_str = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                current_scroll_val_str = " ".join(map(str, current_scroll_val)) if isinstance(current_scroll_val, tuple) else str(current_scroll_val)
            except tk.TclError: pass

            if current_scroll_val_str != str_scroll :
                try:
                    canvas.config(scrollregion=(0, 0, scroll_content_width, scroll_content_height))
                    self.debug(f"[DEBUG] draw_supertile_selector: Scrollregion set to: {scroll_content_width}x{scroll_content_height}")
                except tk.TclError: self.debug("[DEBUG] draw_supertile_selector: TclError setting scrollregion."); return

            # Optimized drawing for visible rows (same as before)
            view_y1 = canvas.canvasy(0)
            view_y2 = canvas.canvasy(canvas.winfo_height())
            # For a vertically scrolling list, start_draw_col is always 0, end_draw_col is items_across
            start_draw_row = max(0, int(view_y1 // (item_pixel_h + padding)))
            end_draw_row = min(num_logical_rows, int(math.ceil(view_y2 / (item_pixel_h + padding))))
            # Ensure at least one row is attempted if there's content, and end_draw_row covers partials
            if num_logical_rows > 0 and end_draw_row == start_draw_row and view_y2 > view_y1:
                 end_draw_row = max(end_draw_row, start_draw_row +1) # Ensure at least one iteration if content exists and view is valid
            end_draw_row = min(num_logical_rows, end_draw_row) # Clamp to actual rows

            self.debug(f"[DEBUG] draw_supertile_selector: Drawing rows {start_draw_row} to {end_draw_row-1}")


            for r_grid in range(start_draw_row, end_draw_row):
                for c_grid in range(items_across):
                    st_idx = r_grid * items_across + c_grid
                    if st_idx >= num_supertiles: break

                    base_x = (c_grid * (item_pixel_w + padding)) + padding
                    base_y = (r_grid * (item_pixel_h + padding)) + padding

                    img = self.create_supertile_image(st_idx, item_pixel_w, item_pixel_h) 
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_image(
                        base_x, base_y, image=img, anchor=tk.NW, tags=(f"st_img_{st_idx}", "st_image")
                    )

                    outline_color = "grey"; outline_width = 1
                    if st_idx == dragged_supertile_index: outline_color = "yellow"; outline_width = 3
                    elif st_idx == highlighted_supertile_index: outline_color = "red"; outline_width = 2
                    elif st_idx in self.marked_unused_supertiles: outline_color = "blue"; outline_width = 3
                    
                    bx1 = base_x - (padding / 2 if padding > 0 else 0.5) 
                    by1 = base_y - (padding / 2 if padding > 0 else 0.5)
                    bx2 = base_x + item_pixel_w + (padding / 2 if padding > 0 else 0.5)
                    by2 = base_y + item_pixel_h + (padding / 2 if padding > 0 else 0.5)
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_rectangle(
                        bx1, by1, bx2, by2, outline=outline_color, width=outline_width, tags=f"st_border_{st_idx}"
                    )
                if st_idx >= num_supertiles -1 : break # Break outer loop if all STs processed
        except tk.TclError as e: self.debug(f"[DEBUG] TclError in draw_supertile_selector: {e}")
        except Exception as e: self.debug(f"[DEBUG] Unexpected error in draw_supertile_selector: {e}")

    def update_supertile_info_labels(self):
        self.supertile_def_info_label.config(
            text=f"Editing Supertile: {current_supertile_index}/{max(0, num_supertiles-1)}"
        )
        self.supertile_tile_select_label.config(
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}"
        )
        self.supertile_sel_info_label.config(text=f"Supertiles: {num_supertiles}")

    def draw_map_canvas(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return
        
        # Delete old canvas items first (specifically map content, not overlays yet)
        # The main image will be tagged "map_render_image", selection and grids are separate.
        canvas.delete("map_render_image") # Delete only the main rendered image for now

        self.debug(f"[DEBUG] draw_map_canvas: Start. Zoom: {self.map_zoom_level:.2f}")

        # --- 1. Calculate Sizes ---
        zoomed_tile_size = self.get_zoomed_tile_size() 
        if zoomed_tile_size <= 0: 
            self.debug("[DEBUG] draw_map_canvas: zoomed_tile_size <= 0. Aborting.")
            return

        zoomed_supertile_pixel_width, zoomed_supertile_pixel_height = self._get_zoomed_supertile_pixel_dims()
        if zoomed_supertile_pixel_width <= 0 or zoomed_supertile_pixel_height <= 0:
            self.debug("[DEBUG] draw_map_canvas: zoomed_supertile_pixel_width/height <= 0. Aborting.")
            return
        
        self.debug(f"[DEBUG] draw_map_canvas: Zoomed ST dims (WxH): {zoomed_supertile_pixel_width}x{zoomed_supertile_pixel_height}")


        # --- 2. Update Scroll Region (based on total map content size at current zoom) ---
        map_content_pixel_width_total = map_width * zoomed_supertile_pixel_width
        map_content_pixel_height_total = map_height * zoomed_supertile_pixel_height
        
        safe_scroll_width = max(1.0, float(map_content_pixel_width_total))
        safe_scroll_height = max(1.0, float(map_content_pixel_height_total))
        
        # Only update scrollregion if it actually changed to avoid unnecessary internal Tk processing
        current_scroll_region_str = ""
        try:
            sr = canvas.cget("scrollregion")
            if sr and isinstance(sr, str) and len(sr.split()) == 4: # Basic check for valid format
                current_scroll_region_str = sr
        except tk.TclError: pass # Canvas might not be fully ready on first call

        new_scroll_region_str = f"0 0 {safe_scroll_width} {safe_scroll_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                canvas.config(scrollregion=(0, 0, safe_scroll_width, safe_scroll_height))
                self.debug(f"[DEBUG] draw_map_canvas: Scrollregion set to {new_scroll_region_str}")
            except tk.TclError: 
                self.debug("[DEBUG] draw_map_canvas: TclError setting scrollregion.")
                return # Cannot proceed if scrollregion fails
        
        # --- 3. Get Viewport Info ---
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 0 or canvas_viewport_height <= 0:
            self.debug("[DEBUG] draw_map_canvas: Viewport width/height <= 0. Aborting.")
            return

        view_content_x1 = canvas.canvasx(0) # Top-left X of visible part of content
        view_content_y1 = canvas.canvasy(0) # Top-left Y of visible part of content
        self.debug(f"[DEBUG] draw_map_canvas: Viewport WxH: {canvas_viewport_width}x{canvas_viewport_height}, Content scroll: ({view_content_x1:.1f}, {view_content_y1:.1f})")


        # --- 4. Create/Resize Pillow Viewport Image Buffer ---
        # self.pil_map_viewport_image stores the Pillow Image
        # self.tk_map_photoimage stores the Tk PhotoImage for display (and keeps a reference)
        if self.pil_map_viewport_image is None or \
           self.pil_map_viewport_image.width != canvas_viewport_width or \
           self.pil_map_viewport_image.height != canvas_viewport_height:
            try:
                self.pil_map_viewport_image = Image.new('RGB', 
                                                        (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), 
                                                        canvas.cget("bg")) # Fill with canvas BG
                self.debug(f"[DEBUG] draw_map_canvas: Created/Resized self.pil_map_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except ValueError as e_pil_new:
                self.debug(f"[DEBUG] draw_map_canvas: Error creating pil_map_viewport_image: {e_pil_new}")
                return
        else:
            # Fill existing image with background color
            try:
                self.pil_map_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill: # Catch potential errors if canvas.cget("bg") is not a valid color for paste
                self.debug(f"[DEBUG] draw_map_canvas: Error filling pil_map_viewport_image: {e_fill}. Filling with black.")
                self.pil_map_viewport_image.paste("black", (0,0,canvas_viewport_width,canvas_viewport_height) )


        # --- 5. Determine Visible Supertile Range & Composite onto Pillow Viewport Image ---
        start_st_col = max(0, int(view_content_x1 // zoomed_supertile_pixel_width))
        start_st_row = max(0, int(view_content_y1 // zoomed_supertile_pixel_height))
        
        # End column/row (exclusive) needed to cover the viewport
        end_st_col = min(map_width, int(math.ceil((view_content_x1 + canvas_viewport_width) / zoomed_supertile_pixel_width)))
        end_st_row = min(map_height, int(math.ceil((view_content_y1 + canvas_viewport_height) / zoomed_supertile_pixel_height)))
        
        self.debug(f"[DEBUG] draw_map_canvas: Visible STs - Cols: {start_st_col}-{end_st_col-1}, Rows: {start_st_row}-{end_st_row-1}")

        rendered_st_count = 0
        for r_map in range(start_st_row, end_st_row):
            for c_map in range(start_st_col, end_st_col):
                if not (0 <= r_map < map_height and 0 <= c_map < map_width): # Should be redundant due to loop bounds
                    continue
                
                try:
                    supertile_idx = map_data[r_map][c_map]
                    
                    # Get the scaled Pillow Image for this supertile
                    pil_supertile_render = self.create_map_render_of_supertile(
                        supertile_idx, 
                        round(zoomed_supertile_pixel_width), # Pass rounded int sizes
                        round(zoomed_supertile_pixel_height)
                    )

                    if pil_supertile_render:
                        # Calculate paste position on the pil_map_viewport_image
                        # Target X,Y on the viewport image is the ST's content position MINUS the scroll offset
                        content_st_x = c_map * zoomed_supertile_pixel_width
                        content_st_y = r_map * zoomed_supertile_pixel_height
                        
                        paste_x_on_viewport_img = round(content_st_x - view_content_x1)
                        paste_y_on_viewport_img = round(content_st_y - view_content_y1)
                        
                        # Paste (Pillow handles clipping if ST partially outside viewport bounds for paste)
                        self.pil_map_viewport_image.paste(pil_supertile_render, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                        rendered_st_count +=1
                except IndexError:
                    self.debug(f"[DEBUG] draw_map_canvas: IndexError for map_data[{r_map}][{c_map}]")
                except Exception as e_render_st:
                    self.debug(f"[DEBUG] draw_map_canvas: Error rendering/pasting ST ({r_map},{c_map}): {e_render_st}")
        
        self.debug(f"[DEBUG] draw_map_canvas: Rendered {rendered_st_count} supertiles onto Pillow viewport image.")

        # --- 6. Convert Pillow Viewport Image to Tk PhotoImage and Display ---
        try:
            self.tk_map_photoimage = ImageTk.PhotoImage(self.pil_map_viewport_image)
        except Exception as e_photoimg:
            self.debug(f"[DEBUG] draw_map_canvas: Error converting PIL to Tk PhotoImage: {e_photoimg}")
            return

        # Place the single viewport image onto the canvas at the current scroll position
        # This ensures it aligns with other canvas items drawn using content coordinates.
        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1, 
                                    image=self.tk_map_photoimage, 
                                    anchor=tk.NW, 
                                    tags=("map_render_image", "all_map_content")) # New specific tag
        except tk.TclError as e_create_img:
            self.debug(f"[DEBUG] draw_map_canvas: TclError creating canvas image: {e_create_img}")


        # --- 7. Re-draw Overlays (Grid, Selection, Window View, Paste Preview) ---
        # These are drawn directly on the canvas, on top of the "map_render_image".
        # They need to be deleted and redrawn if their appearance depends on zoom or position.
        
        canvas.delete("supertile_grid") # Delete old grid lines
        if self.show_supertile_grid.get():
            grid_color = GRID_COLOR_CYCLE[self.grid_color_index]
            # Draw vertical lines
            for c_grid in range(map_width + 1):
                x_line = c_grid * zoomed_supertile_pixel_width
                if x_line >= view_content_x1 and x_line <= view_content_x1 + canvas_viewport_width + zoomed_supertile_pixel_width : # Optimization for visibility
                     canvas.create_line(x_line, 0, x_line, map_content_pixel_height_total, 
                                        fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            # Draw horizontal lines
            for r_grid in range(map_height + 1):
                y_line = r_grid * zoomed_supertile_pixel_height
                if y_line >= view_content_y1 and y_line <= view_content_y1 + canvas_viewport_height + zoomed_supertile_pixel_height: # Optimization
                    canvas.create_line(0, y_line, map_content_pixel_width_total, y_line,
                                       fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            if canvas.find_withtag("map_render_image"): # Ensure grid is above map image if both exist
                canvas.tag_raise("supertile_grid", "map_render_image")


        self._draw_selection_rectangle() # This deletes old and draws new selection_rect_id

        canvas.delete("window_view_item") # Delete all old window view components
        if self.show_window_view.get():
            # ... (Window View drawing logic - largely same, ensure coordinates are content coords) ...
            # (Make sure it uses zoomed_tile_size, window_view_tile_x/y/w/h for its calculations)
            # Example for main rectangle:
            win_px_start = self.window_view_tile_x * zoomed_tile_size
            win_py_start = self.window_view_tile_y * zoomed_tile_size
            win_pixel_width_total = self.window_view_tile_w.get() * zoomed_tile_size
            win_pixel_height_total = self.window_view_tile_h.get() * zoomed_tile_size
            win_color = GRID_COLOR_CYCLE[self.grid_color_index] # Or a dedicated window view color

            canvas.create_rectangle(win_px_start, win_py_start, 
                                    win_px_start + win_pixel_width_total, 
                                    win_py_start + win_pixel_height_total, 
                                    outline=win_color, width=2, tags=("window_view_rect", "window_view_item"))
            # ... (half-row shading and handles drawing, using content coordinates)
            if self.window_view_tile_h.get() == MAX_WIN_VIEW_HEIGHT_TILES: 
                half_tile_h_px_zoomed = zoomed_tile_size / 2
                dark_y1 = win_py_start + win_pixel_height_total - half_tile_h_px_zoomed
                dark_y2 = win_py_start + win_pixel_height_total
                canvas.create_rectangle(win_px_start, dark_y1, 
                                        win_px_start + win_pixel_width_total, dark_y2, 
                                        fill="gray50", stipple="gray50", outline="", tags=("window_view_overscan", "window_view_item"))
            
            handle_size = WIN_VIEW_HANDLE_SIZE; hs2 = handle_size // 2
            handle_fill = win_color
            handle_outline = "black" if win_color != "#000000" else "white"
            handles_coords = { 
                "nw": (win_px_start, win_py_start), 
                "n": (win_px_start + win_pixel_width_total / 2, win_py_start), 
                # ... all 8 handles ...
                "ne": (win_px_start + win_pixel_width_total, win_py_start),
                "w": (win_px_start, win_py_start + win_pixel_height_total / 2),
                "e": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total / 2),
                "sw": (win_px_start, win_py_start + win_pixel_height_total), 
                "s": (win_px_start + win_pixel_width_total / 2, win_py_start + win_pixel_height_total), 
                "se": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total),
            }
            for tag_handle, (cx_handle, cy_handle) in handles_coords.items():
                x1h, y1h, x2h, y2h = cx_handle - hs2, cy_handle - hs2, cx_handle + hs2, cy_handle + hs2
                canvas.create_rectangle(x1h, y1h, x2h, y2h, fill=handle_fill, outline=handle_outline, width=1, tags=("window_view_handle", f"handle_{tag_handle}", "window_view_item"))

            if canvas.find_withtag("map_render_image"): # Ensure window view is on top
                canvas.tag_raise("window_view_item", "map_render_image")
            if canvas.find_withtag("selection_rect"):
                canvas.tag_raise("window_view_item", "selection_rect") # Window view on top of selection
            if canvas.find_withtag("supertile_grid"):
                 canvas.tag_raise("window_view_item", "supertile_grid")


        # Paste preview should be drawn last if active
        # It deletes and redraws itself based on mouse position, handled by _update_map_cursor_and_coords
        # but we might need to trigger its redraw if it was previously cleared by canvas.delete("all")
        # This part is tricky - better to let its own handler manage it.
        # For now, ensure it's on top if it exists.
        if self.map_paste_preview_rect_id:
            canvas.tag_raise(self.map_paste_preview_rect_id)


        # --- 8. Update Zoom Label ---
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
        
        # canvas.update_idletasks() # Already called by the invoking function if needed (e.g. scroll/keypress handlers)
        self.debug("[DEBUG] draw_map_canvas: End.")

    def update_map_info_labels(self):
        self.map_size_label.config(text=f"{map_width} x {map_height}")
        self.map_supertile_select_label.config(
            text=f"Selected Supertile for Painting: {selected_supertile_for_map}"
        )
        # Update window size entries from state variables
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Ensure IntVar reflects internal state if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())
        # Zoom label updated in draw_map_canvas

    def on_tab_change(self, event):
        self._clear_marked_unused(trigger_redraw=False) # Clear marks on any tab change

        current_tab_index = -1 # Used for debugging or specific tab logic if needed later
        new_tab_index = -1
        selected_tab_widget = None # Store the actual widget of the selected tab

        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    new_tab_index = self.notebook.index(selected_tab_path)
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
        except tk.TclError:
            self.debug("[DEBUG] on_tab_change: TclError getting current tab info.")
            pass # Proceed with generic updates if tab info fails

        if self.map_paste_preview_rect_id: # Clear map paste preview if switching away or to map
            self._clear_paste_preview_rect()

        if selected_tab_widget == self.tab_palette_editor:
            self.update_palette_info_labels()

        # Always update all displays based on the newly selected tab's needs
        self.update_all_displays(changed_level="all") # This will draw the content of the new tab

        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()

        # Manage global key bindings or focus specific to the new tab
        try:
            self.root.unbind("<KeyPress-g>") # Unbind from any previous tab that might have used it
            self.root.unbind("<KeyPress-G>")
        except tk.TclError:
            pass # In case bindings weren't set

        if selected_tab_widget == self.tab_map_editor: # Check using the stored tab frame widget
            self.debug("[DEBUG] on_tab_change: Map Editor tab selected.")
            # Bind 'g' for grid color cycling only when map tab is active
            self.root.bind("<KeyPress-g>", self.handle_map_tab_keypress, add="+")
            self.root.bind("<KeyPress-G>", self.handle_map_tab_keypress, add="+")
            
            # Ensure canvas gets focus for keyboard events (pan, zoom hints, etc.)
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                # Use after_idle to ensure tab is fully visible and canvas can take focus
                self.root.after_idle(self.map_canvas.focus_set)

            # --- ADDED: Schedule enforcement of pane minimums ---
            def enforce_map_pane_minimums_after_tab_change():
                self.debug("[DEBUG] on_tab_change: Map tab visible, performing delayed pane minimum check.")
                # Check if map_paned_window actually exists and is visible now
                if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                    self._do_check_and_enforce_palette_min_width()
                else:
                    self.debug("[DEBUG] on_tab_change: Map paned window not ready for min width enforcement yet.")
            
            # Use after_idle to ensure PanedWindow and its panes have their geometry updated
            self.root.after_idle(enforce_map_pane_minimums_after_tab_change)
            # --- END ADDED ---

            # Draw paste preview if applicable (already handled by _update_map_cursor_and_coords on Motion/Enter)
            # but an explicit call here after tab switch might be desired if mouse is already over canvas.
            # For now, let motion/enter handle it.

        # Update cursor for the map canvas if it's the active tab, or reset otherwise
        # This is a general cursor update based on context.
        self.root.after_idle(self._update_map_cursor) # update_map_cursor checks for map_canvas focus

    # --- Palette Editor Handlers ---
    def handle_current_palette_click(self, event):
        canvas = self.current_palette_canvas
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_slot = row * 4 + col
        if 0 <= clicked_slot < 16:
            if self.selected_palette_slot != clicked_slot:
                self.selected_palette_slot = clicked_slot
                self.draw_current_palette()  # Redraw highlight
                self.update_palette_info_labels()  # Update info display

    def handle_512_picker_click(self, event):
        if not (0 <= self.selected_palette_slot < 16):
            messagebox.showwarning("Palette Picker", "No active palette slot selected to apply color to.", parent=self.root)
            return
            
        canvas = self.msx2_picker_canvas
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS # Should be 32 as per MSX2_PICKER_COLS

        # Convert event coordinates to canvas coordinates (handles scrolling)
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        col = int(canvas_x // (size + padding))
        row = int(canvas_y // (size + padding))
        
        # Validate calculated col and row against picker dimensions
        if not (0 <= col < MSX2_PICKER_COLS and 0 <= row < MSX2_PICKER_ROWS):
            self.debug("512 Picker click outside valid grid.")
            return

        clicked_index_in_512_palette = row * MSX2_PICKER_COLS + col
        
        if 0 <= clicked_index_in_512_palette < 512:
            new_color_hex = msx2_512_colors_hex[clicked_index_in_512_palette]
            target_slot_in_active_palette = self.selected_palette_slot

            if self.active_msx_palette[target_slot_in_active_palette] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Redraw will be handled by update_all_displays
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot_in_active_palette] = new_color_hex
                self.debug(f"Set Active Palette Slot {target_slot_in_active_palette} to {new_color_hex} from 512 picker.")
                
                self.clear_all_caches() # Palette change affects all rendered items
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all") # "all" because palette affects everything
                
                self._request_color_usage_refresh()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()
        else:
            self.debug(f"512 Picker clicked_index {clicked_index_in_512_palette} out of 0-511 range.")

    def handle_rgb_apply(self):
        if not (0 <= self.selected_palette_slot < 16):
            messagebox.showwarning("RGB Apply", "No active palette slot selected.", parent=self.root)
            return
        try:
            r_val_str = self.rgb_r_var.get()
            g_val_str = self.rgb_g_var.get()
            b_val_str = self.rgb_b_var.get()

            if not (r_val_str and g_val_str and b_val_str): # Check for empty strings
                raise ValueError("RGB values cannot be empty.")

            r_val = int(r_val_str) 
            g_val = int(g_val_str) 
            b_val = int(b_val_str) 

            if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                raise ValueError("RGB values must be integers between 0 and 7.")
            
            new_color_hex = self._rgb7_to_hex(r_val, g_val, b_val)
            target_slot_in_active_palette = self.selected_palette_slot
            
            if self.active_msx_palette[target_slot_in_active_palette] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot_in_active_palette] = new_color_hex
                self.debug(f"Set Active Palette Slot {target_slot_in_active_palette} to {new_color_hex} via RGB input.")
                
                self.clear_all_caches()
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all") 
                
                self._request_color_usage_refresh()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

        except ValueError as e:
            messagebox.showerror("Invalid RGB Input", f"{e}", parent=self.root)
        except Exception as e_unexp: # Catch any other unexpected errors
            messagebox.showerror("Error Applying RGB", f"An unexpected error occurred: {e_unexp}", parent=self.root)
            self.debug(f"[DEBUG] Unexpected error in handle_rgb_apply: {e_unexp}")

    def reset_palette_to_default(self):
        confirm = messagebox.askokcancel(
            "Reset Palette",
            "Reset the active palette to the MSX2 default colors?\nThis will affect the appearance of all tiles and supertiles.",
            parent=self.root
        )
        if confirm:
            new_default_palette_hex = [] # Renamed for clarity
            for r_val, g_val, b_val in MSX2_RGB7_VALUES: 
                new_default_palette_hex.append(self._rgb7_to_hex(r_val, g_val, b_val))
            
            if self.active_msx_palette != new_default_palette_hex:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                self._mark_project_modified()
                self.active_msx_palette = list(new_default_palette_hex) # Ensure it's a new list copy
                self.selected_palette_slot = 0 # Reset selection in palette editor
                
                global selected_color_index # Access global for tile editor palette
                selected_color_index = WHITE_IDX # Reset tile editor's color selection
                
                self.clear_all_caches()
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all") # "all" due to palette change
                
                self._request_color_usage_refresh()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()
                
                self.debug("Palette reset to MSX2 defaults.")
            else:
                self.debug("Palette is already set to MSX2 defaults. No changes made.")
                # No need to show info if no change, but could if desired.
                # messagebox.showinfo("Palette Reset", "Palette is already the MSX2 default.", parent=self.root)

    # --- Tile Editor Handlers ---
    def handle_editor_click(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        self.is_currently_painting_tile = True 
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE

        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if r >= len(tileset_patterns[current_tile_index]) or c >= len(tileset_patterns[current_tile_index][r]):
                self.debug(f"Editor click out of pattern bounds for tile {current_tile_index} at {r},{c}")
                last_drawn_pixel = (r, c)
                return

            pixel_value_to_set = 1 if event.num == 1 else 0
            
            if tileset_patterns[current_tile_index][r][c] != pixel_value_to_set:
                # Clear marks first and check if a redraw is needed for them.
                marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)
                
                self._mark_project_modified()
                tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                self.invalidate_tile_cache(current_tile_index)

                # If marks were cleared, we must do a full redraw to remove their highlights.
                # Otherwise, we can do a more efficient, targeted live update.
                if marks_were_cleared:
                    self.update_all_displays(changed_level="all")
                else:
                    self.update_all_displays(changed_level="tile_edit")
                
                self._request_color_usage_refresh() 
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

            last_drawn_pixel = (r, c)

    def handle_editor_drag(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        self.is_currently_painting_tile = True 
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE

        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if (r, c) != last_drawn_pixel: # Only draw if mouse moved to a new pixel cell
                if r >= len(tileset_patterns[current_tile_index]) or c >= len(tileset_patterns[current_tile_index][r]):
                    self.debug(f"Editor drag out of pattern bounds for tile {current_tile_index} at {r},{c}")
                    last_drawn_pixel = (r, c)
                    return

                pixel_value_to_set = -1 # Default to no change
                if event.state & 0x100: # Left button drag
                    pixel_value_to_set = 1
                elif event.state & 0x400: # Right button drag
                    pixel_value_to_set = 0
                
                if (pixel_value_to_set != -1 and
                    tileset_patterns[current_tile_index][r][c] != pixel_value_to_set):
                    
                    marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)

                    self._mark_project_modified()
                    tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                    self.invalidate_tile_cache(current_tile_index)

                    if marks_were_cleared:
                        self.update_all_displays(changed_level="all")
                    else:
                        self.update_all_displays(changed_level="tile_edit")
                        
                    self._request_color_usage_refresh()
                    self._request_tile_usage_refresh()
                    self._request_supertile_usage_refresh()

                last_drawn_pixel = (r, c)

    def handle_tile_editor_palette_click(self, event):
        global selected_color_index
        canvas = self.tile_editor_palette_canvas
        size = PALETTE_SQUARE_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_index = row * 4 + col
        if 0 <= clicked_index < 16:
            if selected_color_index != clicked_index:
                selected_color_index = clicked_index
                self.draw_palette()  # Redraw this palette only

    def set_row_color(self, row, fg_or_bg):
        global tileset_colors, current_tile_index, selected_color_index # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        if not (0 <= selected_color_index < 16): # Validate selected palette index
            messagebox.showwarning("Set Row Color", "No valid color selected from palette.", parent=self.root)
            return
            
        if 0 <= row < TILE_HEIGHT:
            if row >= len(tileset_colors[current_tile_index]):
                self.debug(f"Error: Row {row} out of bounds for tile {current_tile_index} color data.")
                return

            current_fg_idx, current_bg_idx = tileset_colors[current_tile_index][row]
            changed = False
            
            if fg_or_bg == "fg" and current_fg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): 
                    pass 
                tileset_colors[current_tile_index][row] = (selected_color_index, current_bg_idx)
                changed = True
            elif fg_or_bg == "bg" and current_bg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): 
                    pass 
                tileset_colors[current_tile_index][row] = (current_fg_idx, selected_color_index)
                changed = True
            
            if changed:
                self._mark_project_modified()
                self.invalidate_tile_cache(current_tile_index) # This also invalidates dependent STs

                if self.marked_unused_tiles or self.marked_unused_supertiles:
                    self.update_all_displays(changed_level="all")
                else:
                    # A color change requires a 'tile' level update, not a 'live_edit' one
                    self.update_all_displays(changed_level="tile_edit")
                    
                self._request_color_usage_refresh()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

    def handle_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False 
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0 
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id) # Use current canvas
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x 
            self.drag_press_y = event.y 
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def flip_tile_horizontal(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        # Clear marks if any, and redraw if marks were present
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all") 

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            new_pattern[r] = current_pattern[r][::-1]
        tileset_patterns[current_tile_index] = new_pattern
        
        self.invalidate_tile_cache(current_tile_index)
        # If marks were not cleared above, do a targeted update
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile_edit")
        self._mark_project_modified()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        print(f"Tile {current_tile_index} flipped horizontally.")

    def flip_tile_vertical(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        tileset_patterns[current_tile_index].reverse()
        tileset_colors[current_tile_index].reverse()
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile_edit")
        self._mark_project_modified()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        print(f"Tile {current_tile_index} flipped vertically.")

    def rotate_tile_90cw(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0 for _ in range(TILE_WIDTH)] for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            for c in range(TILE_WIDTH):
                new_pattern[c][(TILE_HEIGHT - 1) - r] = current_pattern[r][c]
        tileset_patterns[current_tile_index] = new_pattern
        tileset_colors[current_tile_index] = [
            (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
        ]  
        
        self._mark_project_modified()
        messagebox.showinfo(
            "Rotation Complete", "Tile rotated.\nRow colors have been reset to default."
        )
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile_edit")
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        print(f"Tile {current_tile_index} rotated 90 CW (colors reset).")

    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        # Ensure data structures are as expected
        if not (len(tileset_patterns[current_tile_index]) == TILE_HEIGHT and 
                len(tileset_colors[current_tile_index]) == TILE_HEIGHT):
            self.debug(f"Error: Tile {current_tile_index} data is malformed. Cannot shift up.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        
        # Store the first row
        first_pattern_row = current_pattern[0][:] # Create a copy of the row
        first_color_row = current_colors[0]      # Tuple, so it's already a copy effectively

        # Shift rows up
        for i in range(TILE_HEIGHT - 1):
            current_pattern[i] = current_pattern[i + 1]
            current_colors[i] = current_colors[i + 1]
        
        # Place the first row at the bottom
        current_pattern[TILE_HEIGHT - 1] = first_pattern_row
        current_colors[TILE_HEIGHT - 1] = first_color_row
        
        self._mark_project_modified()
        self.invalidate_tile_cache(current_tile_index)
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="tile_edit")
            
        self._request_color_usage_refresh()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        
        self.debug(f"Tile {current_tile_index} shifted up.")

    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        if not (len(tileset_patterns[current_tile_index]) == TILE_HEIGHT and 
                len(tileset_colors[current_tile_index]) == TILE_HEIGHT):
            self.debug(f"Error: Tile {current_tile_index} data is malformed. Cannot shift down.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        
        # Store the last row
        last_pattern_row = current_pattern[TILE_HEIGHT - 1][:] # Create a copy
        last_color_row = current_colors[TILE_HEIGHT - 1]

        # Shift rows down
        for i in range(TILE_HEIGHT - 1, 0, -1):
            current_pattern[i] = current_pattern[i - 1]
            current_colors[i] = current_colors[i - 1]
            
        # Place the last row at the top
        current_pattern[0] = last_pattern_row
        current_colors[0] = last_color_row
        
        self._mark_project_modified()
        self.invalidate_tile_cache(current_tile_index)
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="tile_edit")
            
        self._request_color_usage_refresh() 
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE
        
        self.debug(f"Tile {current_tile_index} shifted down.")

    def shift_tile_left(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_pattern = tileset_patterns[current_tile_index]
        # Validate pattern structure
        if not (isinstance(current_pattern, list) and 
                len(current_pattern) == TILE_HEIGHT and
                all(isinstance(row, list) and len(row) == TILE_WIDTH for row in current_pattern)):
            self.debug(f"Error: Tile {current_tile_index} pattern data is malformed. Cannot shift left.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
        
        for r_idx_shift in range(TILE_HEIGHT):
            row_data = current_pattern[r_idx_shift]
            first_pixel_val = 0 
            if TILE_WIDTH > 0: # Should always be true based on constants
                first_pixel_val = row_data[0]
            
            for c_idx_shift in range(TILE_WIDTH - 1):
                row_data[c_idx_shift] = row_data[c_idx_shift + 1]
            
            if TILE_WIDTH > 0:
                row_data[TILE_WIDTH - 1] = first_pixel_val
        
        self._mark_project_modified()
        self.invalidate_tile_cache(current_tile_index)
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="tile_edit")
            
        # Color usage not directly affected by pixel pattern shift unless interpretation changes
        # self._request_color_usage_refresh() # Not strictly needed for only pattern shift
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        
        self.debug(f"Tile {current_tile_index} shifted left.")

    def shift_tile_right(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set # Using globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_pattern = tileset_patterns[current_tile_index]
        if not (isinstance(current_pattern, list) and 
                len(current_pattern) == TILE_HEIGHT and
                all(isinstance(row, list) and len(row) == TILE_WIDTH for row in current_pattern)):
            self.debug(f"Error: Tile {current_tile_index} pattern data is malformed. Cannot shift right.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
        
        for r_idx_shift_r in range(TILE_HEIGHT):
            row_data = current_pattern[r_idx_shift_r]
            last_pixel_val = 0
            if TILE_WIDTH > 0:
                last_pixel_val = row_data[TILE_WIDTH - 1]
            
            for c_idx_shift_r in range(TILE_WIDTH - 1, 0, -1):
                row_data[c_idx_shift_r] = row_data[c_idx_shift_r - 1]
            
            if TILE_WIDTH > 0:
                row_data[0] = last_pixel_val
        
        self._mark_project_modified()
        self.invalidate_tile_cache(current_tile_index)
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="tile_edit")
            
        # self._request_color_usage_refresh() # Not strictly needed for only pattern shift
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE
        
        self.debug(f"Tile {current_tile_index} shifted right.")

    # --- Supertile Editor Handlers ---
    def handle_st_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def handle_supertile_def_click(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            messagebox.showwarning("Place Tile", "Please select a valid tile first.")
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile in the editor
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_display_size <= 0 or not canvas.winfo_exists():
            return

        # Calculate col and row in the definition grid based on pixel size of mini-tiles
        col = event.x // mini_tile_display_size
        row = event.y // mini_tile_display_size

        # Reset drag state
        self.last_placed_supertile_cell = None

        # _place_tile_in_supertile will use self.supertile_grid_width/height for its internal bounds check
        placed = self._place_tile_in_supertile(row, col)

        if placed:
            self.last_placed_supertile_cell = (row, col)

    def handle_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    # --- Map Editor Handlers ---
    def handle_map_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def _paint_map_cell(self, canvas_x, canvas_y):
        global map_data, last_painted_map_cell, selected_supertile_for_map

        zoomed_st_w, zoomed_st_h = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_w <= 0 or zoomed_st_h <= 0:
            return

        c_map = int(canvas_x // zoomed_st_w)
        r_map = int(canvas_y // zoomed_st_h)

        if not (0 <= r_map < map_height and 0 <= c_map < map_width):
            return

        current_cell_id = (r_map, c_map)
        try:
            current_data_val = map_data[r_map][c_map]
        except IndexError:
            self.debug(f"  ERROR: IndexError accessing map_data[{r_map}][{c_map}]. Map size: {map_width}x{map_height}")
            return

        if current_cell_id != last_painted_map_cell: 
            if current_data_val != selected_supertile_for_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Redraw will happen via update_all_displays if needed by other factors

                self._mark_project_modified()
                map_data[r_map][c_map] = selected_supertile_for_map 
                
                self.draw_map_canvas() 
                self.draw_minimap()    
                self._request_supertile_usage_refresh() # ADD THIS LINE

            last_painted_map_cell = current_cell_id

    # --- Map Grid/Window Event Handlers ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()
        self.root.update_idletasks()
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES  # Use constant
            if not (min_w <= new_w <= max_w and min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Size",
                    f"Window width must be {min_w}-{max_w}, height {min_h}-{max_h}.",
                )
                # Reset entries to current state if invalid
                return

            # If size changed, redraw the map
            # (IntVar should already hold the value, no need to set self.window_view_tile_w/h directly)
            self.draw_map_canvas()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size() # Base tile (8x8 MSX) zoomed size
        if zoomed_tile_size <= 0:
            return

        delta_x = current_canvas_x - self.drag_start_x
        delta_y = current_canvas_y - self.drag_start_y

        delta_tile_x = round(delta_x / zoomed_tile_size)
        delta_tile_y = round(delta_y / zoomed_tile_size)

        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y
        
        # Max window position is based on total map tiles, not supertile grid directly here
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_tile_x_win = total_map_tiles_w - self.window_view_tile_w.get()
        max_tile_y_win = total_map_tiles_h - self.window_view_tile_h.get()
        
        # Ensure max is not negative if window is larger than map (should be prevented by other logic)
        max_tile_x_win = max(0, max_tile_x_win)
        max_tile_y_win = max(0, max_tile_y_win)

        clamped_tx = max(0, min(new_tx, max_tile_x_win))
        clamped_ty = max(0, min(new_ty, max_tile_y_win))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap during window drag

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th

        current_tile_x = round(current_canvas_x / zoomed_tile_size)
        current_tile_y = round(current_canvas_y / zoomed_tile_size)

        new_tx = start_tx
        new_ty = start_ty
        new_tw = start_tw
        new_th = start_th
        handle = self.window_view_resize_handle

        if "w" in handle:
            new_tx = min(current_tile_x, start_tx + start_tw - 1)
            new_tw = start_tw + (start_tx - new_tx)
        elif "e" in handle:
            new_tw = max(1, current_tile_x - start_tx + 1)

        if "n" in handle:
            new_ty = min(current_tile_y, start_ty + start_th - 1)
            new_th = start_th + (start_ty - new_ty)
        elif "s" in handle:
            new_th = max(1, current_tile_y - start_ty + 1)

        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        if "w" in handle and clamped_tw != new_tw:
            new_tx = start_tx + start_tw - clamped_tw
        if "n" in handle and clamped_th != new_th:
            new_ty = start_ty + start_th - clamped_th
        
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_map_tile_x_for_win = total_map_tiles_w
        max_map_tile_y_for_win = total_map_tiles_h
        
        clamped_tx = max(0, min(new_tx, max_map_tile_x_for_win - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y_for_win - clamped_th))
        
        # Final check if clamping position changed dimensions again
        final_tw = min(clamped_tw, max_map_tile_x_for_win - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y_for_win - clamped_ty)
        final_tw = max(1, final_tw) # Ensure min width of 1
        final_th = max(1, final_th) # Ensure min height of 1


        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw # Use final_tw/th
            or self.window_view_tile_h.get() != final_th
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)
            self.window_view_tile_h.set(final_th)
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        if not self.show_window_view.get():
            return

        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height
        
        # Max top-left position for the window view
        max_win_pos_x = total_map_tiles_w - current_w
        max_win_pos_y = total_map_tiles_h - current_h
        
        # Ensure max is not negative if window is larger than map
        max_win_pos_x = max(0, max_win_pos_x)
        max_win_pos_y = max(0, max_win_pos_y)

        clamped_tx = max(0, min(new_tx, max_win_pos_x))
        clamped_ty = max(0, min(new_ty, max_win_pos_y))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus (WASD, G)."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "g":  # MODIFIED CHECK
            self.cycle_grid_color()
            return "break"  # Prevent other 'g' bindings
        elif self.show_window_view.get():  # Only move window if visible
            moved = False
            if key == "w":
                self.move_window_view_keyboard(0, -1)
                moved = True
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)
                moved = True
            elif key == "s":
                self.move_window_view_keyboard(0, 1)
                moved = True
            elif key == "d":
                self.move_window_view_keyboard(1, 0)
                moved = True

            if moved:
                return "break"

    # --- Map Zoom Handlers ---
    def handle_map_zoom_scroll(self, event):
        # Handles Ctrl+MouseWheel zooming, centered on cursor, with dynamic factor.
        canvas = self.map_canvas
        current_zoom = self.map_zoom_level # Get current zoom level

        # Determine dynamic zoom factor based on current_zoom
        factor = 0.0
        zoom_direction_in = (event.num == 4 or event.delta > 0) # True if zooming in

        if current_zoom < 0.25: # Zoomed out
            factor = 1.75 if zoom_direction_in else 1 / 1.75
        elif current_zoom < 0.75: # Zoomed out
            factor = 1.5 if zoom_direction_in else 1 / 1.5
        elif current_zoom < 1.5:  # Near 100%
            factor = 1.25 if zoom_direction_in else 1 / 1.25
        elif current_zoom < 3.0:  # Zoomed in
            factor = 1.15 if zoom_direction_in else 1 / 1.15
        else: # Very zoomed in
            factor = 1.1 if zoom_direction_in else 1 / 1.1
        
        if factor == 0.0: # Should not happen with the logic above, but as a safe guard
             self.debug("[DEBUG] handle_map_zoom_scroll: Factor is 0, aborting zoom.")
             return

        self.debug(f"[DEBUG] handle_map_zoom_scroll: Current zoom={current_zoom:.3f}, DirectionIn={zoom_direction_in}, Calculated factor={factor:.3f}")

        # Get mouse position relative to canvas content (scrolled coords)
        # These are the content coordinates of the point to keep fixed.
        zoom_x_canvas_content = canvas.canvasx(event.x)
        zoom_y_canvas_content = canvas.canvasy(event.y)

        # Perform zoom centered on the cursor using the determined factor
        # The zoom_map_at_point function already contains the logic to check
        # if the new zoom level will result in a visual change.
        self.zoom_map_at_point(factor, zoom_x_canvas_content, zoom_y_canvas_content)

    def change_map_zoom_mult(self, factor):
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        # Get current canvas view center
        cx = canvas.canvasx(canvas.winfo_width() / 2)
        cy = canvas.canvasy(canvas.winfo_height() / 2)
        # Zoom towards the center
        self.zoom_map_at_point(factor, cx, cy)

    def set_map_zoom(self, new_zoom_level):
        # Sets absolute zoom level, centered on current canvas center.
        min_zoom, max_zoom = 0.2, 6.0  # Definitive min_zoom
        
        try:
            requested_zoom_float = float(new_zoom_level)
        except ValueError:
            self.debug(f"[DEBUG] set_map_zoom: Invalid new_zoom_level '{new_zoom_level}'. Cannot convert to float.")
            return

        # Clamp the requested zoom to min/max bounds immediately
        safe_target_zoom = max(min_zoom, min(max_zoom, requested_zoom_float))
        
        current_actual_zoom = self.map_zoom_level

        self.debug(f"[DEBUG] set_map_zoom: Requested={requested_zoom_float:.4f}, SafeClampedTarget={safe_target_zoom:.4f}, CurrentActual={current_actual_zoom:.4f}")

        # Check if a significant change is even requested after clamping
        if abs(current_actual_zoom - safe_target_zoom) > 1e-9: 
            # Calculate the factor needed to get from current_actual_zoom to safe_target_zoom
            factor = 1.0
            if abs(current_actual_zoom) > 1e-9: # Avoid division by zero
                factor = safe_target_zoom / current_actual_zoom
            elif abs(safe_target_zoom) > 1e-9: # If current is ~0, but target isn't, it's a large change
                 # Factor doesn't make sense here, zoom_map_at_point will handle it by directly setting to potential_new_zoom_float
                 # We can pass a factor that will result in safe_target_zoom,
                 # or let zoom_map_at_point handle it if current_actual_zoom is too small for factor.
                 # The call to zoom_map_at_point will use its internal current_zoom_float.
                 # The factor is relative to *that*.
                 pass # zoom_map_at_point will effectively set it to safe_target_zoom via its own logic

            self.debug(f"[DEBUG] set_map_zoom: Factor to apply (approx): {factor:.4f}")
            
            canvas = self.map_canvas
            if not canvas or not canvas.winfo_exists(): return

            center_x_content = canvas.canvasx(canvas.winfo_width() / 2)
            center_y_content = canvas.canvasy(canvas.winfo_height() / 2)
            self.debug(f"[DEBUG] set_map_zoom: Centering on content coords: ({center_x_content:.2f}, {center_y_content:.2f})")
            
            # Call zoom_map_at_point. It will calculate its own potential_new_zoom_float
            # based on its current_zoom_float and the passed factor.
            # This potential_new_zoom_float should end up being very close to our safe_target_zoom.
            self.zoom_map_at_point(factor, center_x_content, center_y_content)
        else:
            # Zoom level is already very close to target, ensure UI label is accurate based on the actual state
            self.debug(f"[DEBUG] set_map_zoom: No significant change needed or already at target. Current zoom: {self.map_zoom_level*100:.1f}%")
            if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
                try:
                    self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
                except tk.TclError: pass

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size (base 8x8) based on zoom."""
        # Base size for 100% zoom is 8 pixels per tile edge
        zoomed_size = 8 * self.map_zoom_level
        # Ensure minimum size of 1 pixel
        return max(1, int(zoomed_size))

    def zoom_map_at_point(self, factor, zoom_x_canvas, zoom_y_canvas):
        # Zooms the map by 'factor', keeping the content point (zoom_x_canvas, zoom_y_canvas)
        # stationary relative to the viewport's top-left edge.
        # zoom_x_canvas and zoom_y_canvas are expected to be canvas *content* coordinates.

        canvas = self.map_canvas
        if not canvas or not canvas.winfo_exists(): # Check canvas existence early
            self.debug("[DEBUG] zoom_map_at_point: Canvas does not exist. Aborting.")
            return

        current_zoom_float = self.map_zoom_level 
        
        min_zoom, max_zoom = 0.2, 6.0 # Definitive min_zoom
        
        # Calculate potential new zoom after applying factor
        calculated_val_after_factor = current_zoom_float * factor
        # Apply clamping
        potential_new_zoom_float = max(min_zoom, min(max_zoom, calculated_val_after_factor))
        
        self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation Start ---")
        self.debug(f"[DEBUG] zoom_map_at_point: current_zoom_float={current_zoom_float:.4f}, factor={factor:.4f}")
        self.debug(f"[DEBUG] zoom_map_at_point: val_after_factor={calculated_val_after_factor:.4f}")
        self.debug(f"[DEBUG] zoom_map_at_point: potential_new_zoom_float (after all clamps min={min_zoom}, max={max_zoom})={potential_new_zoom_float:.4f}")

        base_display_size = TILE_WIDTH # Assuming TILE_WIDTH is the unscaled pixel size (e.g., 8)
        current_int_display_tile_size = max(1, int(base_display_size * current_zoom_float))
        potential_new_int_display_tile_size = max(1, int(base_display_size * potential_new_zoom_float))

        # Update the UI label with the (potentially clamped) new zoom level immediately
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            try:
                self.map_zoom_label.config(text=f"{int(potential_new_zoom_float * 100)}%")
            except tk.TclError: pass # Ignore if label is being destroyed

        # Determine if a full redraw is warranted
        force_redraw_due_to_int_size_change = (current_int_display_tile_size != potential_new_int_display_tile_size)
        
        relative_zoom_change_threshold = 0.03 # e.g., 3% change
        significant_relative_float_change = False
        if current_zoom_float > 1e-9: # Avoid division by zero for relative change
            if abs(potential_new_zoom_float - current_zoom_float) / current_zoom_float > relative_zoom_change_threshold:
                significant_relative_float_change = True
        elif abs(potential_new_zoom_float - current_zoom_float) > (relative_zoom_change_threshold * min_zoom): # Use absolute for very small current_zoom
             significant_relative_float_change = True


        # Check if the change is just floating point noise / too small to matter visually if int size doesn't change
        is_just_noise_or_too_small_without_int_change = abs(potential_new_zoom_float - current_zoom_float) < 1e-7

        if not force_redraw_due_to_int_size_change and \
           not significant_relative_float_change and \
           is_just_noise_or_too_small_without_int_change:
            # Only update internal float zoom if it's not just noise, to keep label consistent
            if not is_just_noise_or_too_small_without_int_change and abs(potential_new_zoom_float - current_zoom_float) > 1e-9 :
                 self.map_zoom_level = potential_new_zoom_float
            self.debug(f"[DEBUG] zoom_map_at_point: No significant visual change expected. Zoom for label: {potential_new_zoom_float*100:.1f}%. Actual self.map_zoom_level: {self.map_zoom_level*100:.1f}%. Skipping full redraw.")
            self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation End (Skipped Redraw) ---")
            return
        
        self.debug(f"[DEBUG] zoom_map_at_point: Proceeding with redraw. Old actual zoom: {current_zoom_float*100:.1f}%, New target zoom: {potential_new_zoom_float*100:.1f}%")
        self.debug(f"[DEBUG] zoom_map_at_point: Old int size: {current_int_display_tile_size}, New int size: {potential_new_int_display_tile_size}")
        self.debug(f"[DEBUG] zoom_map_at_point: SignificantRelFloatChange: {significant_relative_float_change}, ForceIntSizeChange: {force_redraw_due_to_int_size_change}")

        # Update the actual application zoom level state
        old_zoom_for_scale_calc = current_zoom_float # Use the float value before it's updated by self.map_zoom_level
        self.map_zoom_level = potential_new_zoom_float # This is the new definitive zoom level
        
        scale_change = 1.0 # Default if old zoom was zero or too small
        if abs(old_zoom_for_scale_calc) > 1e-9 : # Avoid division by zero or huge scale_change from tiny old_zoom
            scale_change = self.map_zoom_level / old_zoom_for_scale_calc
        elif abs(self.map_zoom_level) > 1e-9 : # If old zoom was ~0 but new one isn't, it's essentially a fresh scale
            pass # scale_change remains 1.0 which means no relative scaling for scroll adjustment, absolute positioning will take over

        self.debug(f"[DEBUG] zoom_map_at_point: self.map_zoom_level NOW = {self.map_zoom_level:.4f}, scale_change = {scale_change:.4f}")

        # --- Scroll adjustment logic to keep zoom_x_canvas, zoom_y_canvas fixed ---
        # (zoom_x_canvas, zoom_y_canvas) are the content coordinates of the point under the cursor (or center)
        
        current_view_x1 = canvas.canvasx(0) # Content X at left edge of viewport BEFORE scroll
        current_view_y1 = canvas.canvasy(0) # Content Y at top edge of viewport BEFORE scroll

        # The point (zoom_x_canvas, zoom_y_canvas) is currently at screen offset:
        # screen_offset_x = zoom_x_canvas - current_view_x1
        # screen_offset_y = zoom_y_canvas - current_view_y1
        # After zoom, we want this same screen_offset to correspond to the new scaled content point.
        # new_content_point_x = zoom_x_canvas * scale_change (This is conceptual, coordinates don't just multiply)
        # The new scroll position (target_new_view_x1) should be such that:
        # target_new_view_x1 + screen_offset_x = (new position of zoom_x_canvas after scaling effect)
        # A common formula: target_scroll = fixed_point_content_coord - (screen_offset_of_fixed_point / new_zoom_level_relative_to_screen_pixels)
        # Simplified: keep the relative position of zoom_x_canvas within the viewport the same.
        # screen_offset_x / viewport_width_old_zoom = (zoom_x_canvas * scale_change - target_new_view_x1) / viewport_width_new_zoom
        # This is still more complex than needed if we use the formula:
        target_new_view_x1 = zoom_x_canvas - ((zoom_x_canvas - current_view_x1) / scale_change) if abs(scale_change) > 1e-9 else current_view_x1
        target_new_view_y1 = zoom_y_canvas - ((zoom_y_canvas - current_view_y1) / scale_change) if abs(scale_change) > 1e-9 else current_view_y1
        
        # --- Recalculate total map dimensions AT THE NEW self.map_zoom_level ---
        new_zoomed_st_w, new_zoomed_st_h = self._get_zoomed_supertile_pixel_dims() # Uses current self.map_zoom_level
        map_total_pixel_width_new_zoom = map_width * new_zoomed_st_w
        map_total_pixel_height_new_zoom = map_height * new_zoomed_st_h
        
        safe_map_total_w = max(1.0, float(map_total_pixel_width_new_zoom))
        safe_map_total_h = max(1.0, float(map_total_pixel_height_new_zoom))

        target_frac_x = target_new_view_x1 / safe_map_total_w if safe_map_total_w > 0 else 0.0
        target_frac_y = target_new_view_y1 / safe_map_total_h if safe_map_total_h > 0 else 0.0

        canvas_widget_width = canvas.winfo_width()
        canvas_widget_height = canvas.winfo_height()

        # Calculate max fraction to prevent scrolling beyond content edges
        max_frac_x = 0.0
        if safe_map_total_w > canvas_widget_width:
            max_frac_x = (safe_map_total_w - canvas_widget_width) / safe_map_total_w
        
        max_frac_y = 0.0
        if safe_map_total_h > canvas_widget_height:
            max_frac_y = (safe_map_total_h - canvas_widget_height) / safe_map_total_h
        
        final_frac_x = max(0.0, min(target_frac_x, max_frac_x))
        final_frac_y = max(0.0, min(target_frac_y, max_frac_y))
        
        self.debug(f"[DEBUG] zoom_map_at_point: Scroll Adjust: target_new_view=({target_new_view_x1:.2f},{target_new_view_y1:.2f}), "
                   f"target_frac=({target_frac_x:.4f},{target_frac_y:.4f}), max_frac=({max_frac_x:.4f},{max_frac_y:.4f}), final_frac=({final_frac_x:.4f},{final_frac_y:.4f})")

        # Apply the scroll before drawing
        # Only call xview_moveto/yview_moveto if the canvas scrollable area is larger than the viewport
        if safe_map_total_w > 0: # and safe_map_total_w > canvas_widget_width: # Optional: only if scrollable
            canvas.xview_moveto(final_frac_x)
        if safe_map_total_h > 0: # and safe_map_total_h > canvas_widget_height: # Optional
            canvas.yview_moveto(final_frac_y)
        
        self.draw_map_canvas() 
        self.draw_minimap()
        self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation End (Redraw Performed) ---")

    # --- File Menu Commands ---
    # ... (new_project, save/load tileset/supertile/map remain mostly unchanged,
    #      ensure new_project resets new state like grid toggles, window view) ...
    def new_project(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        global supertiles_data, current_supertile_index, num_supertiles, selected_tile_for_supertile
        global map_data, map_width, map_height, selected_supertile_for_map, last_painted_map_cell
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data
        global selected_color_index 

        confirm_new = True
        if self.project_modified:
            confirm_new = messagebox.askokcancel(
                "New Project", "Discard all current unsaved changes and start new?", parent=self.root
            )

        if confirm_new:
            new_dim_w_str = simpledialog.askstring(
                "New Supertile Width",
                "Enter supertile grid width (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_width)
            )
            if new_dim_w_str is None: return 
            try:
                new_dim_w = int(new_dim_w_str)
                if not (1 <= new_dim_w <= 32):
                    messagebox.showerror("Invalid Width", "Width must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Width must be a whole number.", parent=self.root)
                return

            new_dim_h_str = simpledialog.askstring(
                "New Supertile Height",
                "Enter supertile grid height (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_height)
            )
            if new_dim_h_str is None: return 
            try:
                new_dim_h = int(new_dim_h_str)
                if not (1 <= new_dim_h <= 32):
                    messagebox.showerror("Invalid Height", "Height must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Height must be a whole number.", parent=self.root)
                return

            # --- Gather states of currently open usage windows BEFORE destroying them ---
            self.debug("[DEBUG] New Project: Gathering current usage window states before reset.")
            self._gather_current_open_window_states()
            # --- End Gather ---

            # --- Destroy existing usage windows ---
            if self.color_usage_window and tk.Toplevel.winfo_exists(self.color_usage_window):
                self.color_usage_window.destroy() # This will call its _on_close, updating its 'is_open' to False
            self.color_usage_window = None
            
            if self.tile_usage_window and tk.Toplevel.winfo_exists(self.tile_usage_window):
                self.tile_usage_window.destroy()
            self.tile_usage_window = None

            if self.supertile_usage_window and tk.Toplevel.winfo_exists(self.supertile_usage_window):
                self.supertile_usage_window.destroy()
            self.supertile_usage_window = None
            # --- End Destroy ---

            self.supertile_grid_width = new_dim_w
            self.supertile_grid_height = new_dim_h
            self.debug(f"New project: Supertile dimensions set to {self.supertile_grid_width}W x {self.supertile_grid_height}H.")

            self._clear_marked_unused(trigger_redraw=False)

            tileset_patterns = [
                [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
            ]
            tileset_colors = [
                [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
                for _ in range(MAX_TILES)
            ]
            current_tile_index = 0
            num_tiles_in_set = 1
            selected_tile_for_supertile = 0

            supertiles_data = [
                [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                for _st in range(MAX_SUPERTILES)
            ]
            current_supertile_index = 0
            num_supertiles = 1
            selected_supertile_for_map = 0

            map_width = DEFAULT_MAP_WIDTH
            map_height = DEFAULT_MAP_HEIGHT
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
            last_painted_map_cell = None

            tile_clipboard_pattern = None
            tile_clipboard_colors = None
            supertile_clipboard_data = None 
            self.map_clipboard_data = None

            self.active_msx_palette = []
            for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
                 self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
            self.selected_palette_slot = 0
            selected_color_index = WHITE_IDX

            self.map_zoom_level = 1.0
            self.show_supertile_grid.set(False)
            self.show_window_view.set(False)
            self.grid_color_index = 1 
            self.window_view_tile_x = 0
            self.window_view_tile_y = 0
            self.window_view_tile_w.set(DEFAULT_WIN_VIEW_WIDTH_TILES)
            self.window_view_tile_h.set(DEFAULT_WIN_VIEW_HEIGHT_TILES)
            self.current_mouse_action = None
            self.window_view_resize_handle = None

            self._clear_map_selection()
            self._clear_paste_preview_rect()
            self.is_shift_pressed = False
            self.is_ctrl_pressed = False

            self.current_project_base_path = None
            self.project_modified = False 
            self._update_window_title()

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            
            self._reconfigure_supertile_definition_canvas() 
            
            self.update_all_displays(changed_level="all")
            self._trigger_minimap_reconfigure() 
            
            self._update_editor_button_states()
            self._update_edit_menu_state()
            self._update_supertile_rotate_button_state() 
            
            try:
                if self.notebook and self.notebook.winfo_exists():
                    selected_tab_path = self.notebook.select()
                    if selected_tab_path and self.notebook.nametowidget(selected_tab_path) == self.tab_map_editor:
                        if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                            self.root.after_idle(self.map_canvas.focus_set)
            except tk.TclError: pass
            
            # --- Re-apply usage window states AFTER new project setup ---
            self.debug("[DEBUG] New Project: Re-applying initial usage window states.")
            self._apply_initial_usage_window_states()
            # --- End Re-apply ---

            # These refresh calls will now only act if the windows were reopened by _apply_initial_usage_window_states
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

    def save_palette(self, filepath=None):
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Pal", # UPDATED Extension
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("All Files", "*.*")], # UPDATED Description and Extension
                title="Save SC4 Palette As...", # UPDATED Title
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                if len(self.active_msx_palette) != 16:
                    self.debug("ERROR: Active palette length is not 16 during save!")
                    if filepath is None:
                        messagebox.showerror(
                            "Palette Error",
                            "Internal Error: Active palette does not contain 16 colors.",
                        )
                    return False

                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)

                for i in range(16):
                    hex_color = self.active_msx_palette[i]
                    r, g, b = self._hex_to_rgb7(hex_color)
                    packed_bytes = struct.pack("BBB", r, g, b)
                    f.write(packed_bytes)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Palette saved successfully to {os.path.basename(save_path)}",
                )
            return True

        except Exception as e:
            messagebox.showerror(
                "Save Palette Error",
                f"Failed to save palette file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_palette(self, filepath=None): # MODIFIED: Removed is_part_of_project_load
        load_path = filepath
        if not load_path:
            # This block for interactive "Open Palette..." via menu
            load_path = filedialog.askopenfilename(
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("Old MSX Palette File", "*.msxpal"), ("All Files", "*.*")], 
                title="Open SC4 Palette",
                parent=self.root
            )
            if not load_path:
                return False

        try:
            expected_color_data_size = 16 * 3  
            new_palette_hex_from_file = [] 
            
            try:
                file_size = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            is_new_format_with_reserved_bytes = False
            expected_size_new = RESERVED_BYTES_COUNT + expected_color_data_size 
            expected_size_old = expected_color_data_size 

            if file_size == expected_size_new:
                is_new_format_with_reserved_bytes = True
            elif file_size == expected_size_old:
                is_new_format_with_reserved_bytes = False 
            else:
                raise ValueError(
                    f"Invalid file size for palette. Expected {expected_size_old} (old) or {expected_size_new} (new) bytes, got {file_size}."
                )

            with open(load_path, "rb") as f:
                if is_new_format_with_reserved_bytes:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("EOF while reading reserved bytes from new format palette file.")
                
                palette_data_bytes = f.read(expected_color_data_size)
                if len(palette_data_bytes) < expected_color_data_size:
                    raise EOFError(
                        f"Not enough data for palette colors. Expected {expected_color_data_size}, got {len(palette_data_bytes)}."
                    )

                for i in range(16):
                    offset = i * 3
                    if offset + 3 > len(palette_data_bytes): 
                        raise struct.error("Not enough bytes in color data block for unpacking.")
                    r_val, g_val, b_val = struct.unpack_from("BBB", palette_data_bytes, offset)

                    if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                        self.debug(
                            f"Warning: Invalid RGB ({r_val},{g_val},{b_val}) at slot {i} in '{os.path.basename(load_path)}'. Clamping."
                        )
                        r_val = max(0, min(7, r_val))
                        g_val = max(0, min(7, g_val))
                        b_val = max(0, min(7, b_val))
                    hex_color = self._rgb7_to_hex(r_val, g_val, b_val)
                    new_palette_hex_from_file.append(hex_color)
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Palette file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm_load = True
            if filepath is None: # Only ask confirm if interactive open
                confirm_load = messagebox.askokcancel(
                    "Load Palette",
                    "Replace the current active palette with data from this file?",
                    parent=self.root
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self.active_msx_palette = list(new_palette_hex_from_file)
                self.selected_palette_slot = 0
                global selected_color_index 
                selected_color_index = WHITE_IDX
                
                # UI updates and cache clears only if NOT part of project load (i.e., interactive)
                if filepath is None: 
                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._request_color_usage_refresh()
                    self._request_tile_usage_refresh()
                    self._request_supertile_usage_refresh() # Palette change affects ST previews
                    
                    try: 
                        if self.notebook and self.notebook.winfo_exists() and self.tab_palette_editor.winfo_exists():
                             self.notebook.select(self.tab_palette_editor)
                    except tk.TclError: pass
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded palette from {os.path.basename(load_path)}",
                        parent=self.root
                    )
                    self._mark_project_modified()
                return True
            else:
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}", parent=self.root)
            return False
        except (struct.error, ValueError, EOFError) as e:
            messagebox.showerror(
                "Open Palette Error",
                f"Invalid data, size, or format in palette file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Palette Error",
                f"Failed to open or parse palette file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
            return False

    def save_tileset(self, filepath=None):
        global num_tiles_in_set, tileset_patterns, tileset_colors # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Tiles",
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Save Tileset As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                tiles_to_write_count = num_tiles_in_set

                header_byte_value = 0 if tiles_to_write_count == 256 else tiles_to_write_count
                if not (0 <= header_byte_value <= 255):
                    self.debug(f"[DEBUG] save_tileset: Invalid header_byte_value {header_byte_value} for num_tiles_in_set {tiles_to_write_count}")
                    raise ValueError(f"Calculated header byte value {header_byte_value} is out of 0-255 range.")
                
                num_byte_header = struct.pack("B", header_byte_value)
                f.write(num_byte_header)

                # --- ADDED: Write reserved bytes after the header ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---

                # --- Write ALL pattern data first ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_patterns): 
                        self.debug(f"[DEBUG] save_tileset: Warning - num_tiles_in_set ({tiles_to_write_count}) > len(tileset_patterns). Stopping pattern write at tile {i}.")
                        # Pad remaining patterns for this block if this happens, to keep file structure valid
                        # This assumes we must write pattern data for all 'tiles_to_write_count'
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                f.write(struct.pack("B", 0)) # Write blank pattern row
                        break 
                    pattern = tileset_patterns[i]
                    for r in range(TILE_HEIGHT):
                        byte_val = 0
                        if r < len(pattern):
                            row_pattern = pattern[r]
                            for c in range(TILE_WIDTH):
                                if c < len(row_pattern) and row_pattern[c] == 1:
                                    byte_val = byte_val | (1 << (7 - c))
                        pattern_byte = struct.pack("B", byte_val)
                        f.write(pattern_byte)
                
                # --- Then, write ALL color data ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_colors):
                        self.debug(f"[DEBUG] save_tileset: Warning - num_tiles_in_set ({tiles_to_write_count}) > len(tileset_colors). Stopping color write at tile {i}.")
                        # Pad remaining colors for this block
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                default_color_byte = ((WHITE_IDX & 0x0F) << 4) | (BLACK_IDX & 0x0F)
                                f.write(struct.pack("B", default_color_byte))
                        break
                    colors = tileset_colors[i]
                    for r in range(TILE_HEIGHT):
                        fg_idx, bg_idx = (WHITE_IDX, BLACK_IDX) 
                        if r < len(colors):
                           fg_idx, bg_idx = colors[r]
                        
                        safe_fg_idx = max(0, min(15, fg_idx))
                        safe_bg_idx = max(0, min(15, bg_idx))

                        color_byte_val = ((safe_fg_idx & 0x0F) << 4) | (safe_bg_idx & 0x0F)
                        color_byte = struct.pack("B", color_byte_val)
                        f.write(color_byte)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Tileset saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Tileset Error",
                f"Failed to save tileset file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_tileset(self, filepath=None):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, selected_tile_for_supertile # Using globals
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Open Tileset",
            )
        if not load_path:
            return False

        try:
            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                num_tiles_header_byte_val = f.read(1)
                if not num_tiles_header_byte_val:
                    raise ValueError("File empty or missing tile count header byte.")
                
                header_value = struct.unpack("B", num_tiles_header_byte_val)[0]
                loaded_num_tiles = 256 if header_value == 0 else header_value

                if not (1 <= loaded_num_tiles <= MAX_TILES):
                    raise ValueError(
                        f"Invalid tile count derived from file: {loaded_num_tiles} (must be 1-{MAX_TILES})"
                    )

                # Calculate expected sizes for old and new formats
                # Pattern data: loaded_num_tiles * TILE_HEIGHT bytes
                # Color data: loaded_num_tiles * TILE_HEIGHT bytes
                expected_data_block_size = (loaded_num_tiles * TILE_HEIGHT) + (loaded_num_tiles * TILE_HEIGHT)
                expected_total_size_new_format = 1 + RESERVED_BYTES_COUNT + expected_data_block_size
                expected_total_size_old_format = 1 + expected_data_block_size

                has_reserved_bytes_to_read = False
                if file_size_check == expected_total_size_new_format:
                    has_reserved_bytes_to_read = True
                    self.debug(f"Info: Tileset file '{os.path.basename(load_path)}' matches new format size (with reserved bytes).")
                elif file_size_check == expected_total_size_old_format:
                    has_reserved_bytes_to_read = False
                    self.debug(f"Info: Tileset file '{os.path.basename(load_path)}' matches old format size (no reserved bytes).")
                else:
                    raise ValueError(
                        f"Tileset file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for {loaded_num_tiles} tiles. Expected {expected_total_size_old_format} (old format) "
                        f"or {expected_total_size_new_format} (new format)."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format tileset file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from tileset file.")
                # If not has_reserved_bytes_to_read, file pointer is correct for old format.

                new_patterns = [
                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]
                new_colors = [
                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]

                bytes_per_tile_pattern = TILE_HEIGHT
                total_pattern_bytes_to_read = loaded_num_tiles * bytes_per_tile_pattern
                
                all_pattern_data_bytes = f.read(total_pattern_bytes_to_read)
                if len(all_pattern_data_bytes) < total_pattern_bytes_to_read:
                    raise EOFError(f"EOF while reading pattern data block. Expected {total_pattern_bytes_to_read}, got {len(all_pattern_data_bytes)}.")

                current_byte_offset_pattern = 0
                for i in range(loaded_num_tiles):
                    tile_pattern_bytes = all_pattern_data_bytes[current_byte_offset_pattern : current_byte_offset_pattern + bytes_per_tile_pattern]
                    if len(tile_pattern_bytes) < bytes_per_tile_pattern: # Should not happen if total read was enough
                        tile_pattern_bytes += bytes(bytes_per_tile_pattern - len(tile_pattern_bytes))
                        
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_pattern_bytes[r_idx]
                        for c in range(TILE_WIDTH):
                            pixel_bit = (byte_val >> (7 - c)) & 1
                            new_patterns[i][r_idx][c] = pixel_bit
                    current_byte_offset_pattern += bytes_per_tile_pattern
                
                bytes_per_tile_colors = TILE_HEIGHT
                total_color_bytes_to_read = loaded_num_tiles * bytes_per_tile_colors

                all_color_data_bytes = f.read(total_color_bytes_to_read)
                if len(all_color_data_bytes) < total_color_bytes_to_read:
                    raise EOFError(f"EOF while reading color data block. Expected {total_color_bytes_to_read}, got {len(all_color_data_bytes)}.")

                current_byte_offset_colors = 0
                for i in range(loaded_num_tiles):
                    tile_color_bytes = all_color_data_bytes[current_byte_offset_colors : current_byte_offset_colors + bytes_per_tile_colors]
                    if len(tile_color_bytes) < bytes_per_tile_colors: # Should not happen
                         tile_color_bytes += bytes(bytes_per_tile_colors - len(tile_color_bytes))

                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        if not (0 <= fg_idx < 16 and 0 <= bg_idx < 16):
                            new_colors[i][r_idx] = (WHITE_IDX, BLACK_IDX)
                        else:
                            new_colors[i][r_idx] = (fg_idx, bg_idx)
                    current_byte_offset_colors += bytes_per_tile_colors
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Tileset file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm = True
            if filepath is None:
                confirm = messagebox.askokcancel(
                    "Load Tileset",
                    f"Replace current tileset with {loaded_num_tiles} tile(s) from this file?",
                )

            if confirm:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Redraw handled by update_all_displays
                
                # Ensure global lists are ready (should be MAX_TILES long from init)
                for i in range(loaded_num_tiles):
                    tileset_patterns[i] = new_patterns[i]
                    tileset_colors[i] = new_colors[i]
                # If fewer tiles loaded than currently in set, clear out the rest
                if num_tiles_in_set > loaded_num_tiles:
                    for i in range(loaded_num_tiles, num_tiles_in_set):
                        tileset_patterns[i] = [[0] * TILE_WIDTH for _r_clear in range(TILE_HEIGHT)]
                        tileset_colors[i] = [(WHITE_IDX, BLACK_IDX) for _r_clear in range(TILE_HEIGHT)]
                
                num_tiles_in_set = loaded_num_tiles
                
                current_tile_index = max(
                    0, min(current_tile_index, num_tiles_in_set - 1)
                )
                selected_tile_for_supertile = max(
                    0, min(selected_tile_for_supertile, num_tiles_in_set - 1)
                )

                self.clear_all_caches()
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()
                self._update_edit_menu_state()
                self._request_color_usage_refresh()

                if filepath is None:
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_tile_editor.winfo_exists():
                            self.notebook.select(self.tab_tile_editor)
                    except tk.TclError:
                        self.debug("[DEBUG] open_tileset: TclError selecting tile editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_tiles_in_set} tiles from {os.path.basename(load_path)}",
                    )
                if filepath is None: # Only mark modified if opened interactively
                    self._mark_project_modified()
                return True
            else: # User cancelled confirmation dialog
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e: # ValueError includes our custom size/format checks
            messagebox.showerror(
                "Open Tileset Error",
                f"Invalid data, size, or format in tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Tileset Error",
                f"Failed to open or parse tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_supertiles(self, filepath=None):
        global num_supertiles, supertiles_data # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Super",
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Save Supertiles As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # --- MODIFIED: Write count of supertiles (hybrid 1-byte/3-byte) ---
                # num_supertiles is the actual count (1 to MAX_SUPERTILES)
                if 1 <= num_supertiles <= 255:
                    f.write(struct.pack("B", num_supertiles))
                elif 256 <= num_supertiles <= MAX_SUPERTILES: # MAX_SUPERTILES is now 65535
                    f.write(struct.pack("B", 0)) # Indicator byte
                    f.write(struct.pack(">H", num_supertiles)) # 2-byte unsigned short for actual count
                else:
                    # This case should not be reached if num_supertiles is always valid (e.g. 0 not allowed)
                    self.debug(f"[DEBUG] save_supertiles: Invalid num_supertiles value ({num_supertiles}) for saving.")
                    raise ValueError(f"num_supertiles ({num_supertiles}) out of expected range for saving.")
                # --- END MODIFIED ---
                
                # Write supertile grid dimensions (these remain 1 byte each)
                f.write(struct.pack("B", self.supertile_grid_width))
                f.write(struct.pack("B", self.supertile_grid_height))

                # --- ADDED: Write reserved bytes after headers and dimensions ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---
                
                tiles_per_definition = self.supertile_grid_width * self.supertile_grid_height
                if tiles_per_definition <= 0 and num_supertiles > 0 : # Defensive check for invalid grid dims
                    self.debug(f"[DEBUG] save_supertiles: Invalid supertile dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}), cannot save data.")
                    raise ValueError("Supertile dimensions are zero or negative, cannot save definition data.")

                # Write data for each supertile
                for i in range(num_supertiles): # Iterate up to the actual number of supertiles
                    if i >= len(supertiles_data): # Safety break
                        self.debug(f"[DEBUG] save_supertiles: Warning - num_supertiles ({num_supertiles}) > len(supertiles_data). Stopping ST data write at ST {i}.")
                        # Pad remaining ST definitions if this happens
                        for _ in range(num_supertiles - i):
                            for _ in range(tiles_per_definition):
                                f.write(struct.pack("B", 0)) # Write 0 for each tile index
                        break
                    
                    definition = supertiles_data[i]
                    
                    # Ensure definition matches project dimensions before writing
                    # Pad/truncate row or cells if necessary for robustness, though ideally data is consistent
                    for r_st in range(self.supertile_grid_height):
                        if r_st < len(definition): # Row exists
                            row_data = definition[r_st]
                            for c_st in range(self.supertile_grid_width):
                                tile_index_val = 0 # Default if cell missing
                                if c_st < len(row_data): # Cell exists
                                    tile_index_val = row_data[c_st]
                                # Ensure tile_index_val is within byte range (0-255) as it's packed as "B"
                                safe_tile_index_val = max(0, min(255, tile_index_val))
                                if tile_index_val != safe_tile_index_val:
                                    self.debug(f"[DEBUG] save_supertiles: Clamping tile index {tile_index_val} to {safe_tile_index_val} in ST {i} at ({r_st},{c_st}).")
                                f.write(struct.pack("B", safe_tile_index_val))
                        else: # Row missing, pad entire row with 0s
                            for _ in range(self.supertile_grid_width):
                                f.write(struct.pack("B", 0))
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Supertiles saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Supertile Error",
                f"Failed to save supertiles file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_supertiles(self, filepath=None, is_part_of_project_load=False): # Added is_part_of_project_load
        global supertiles_data, num_supertiles, current_supertile_index, selected_supertile_for_map, num_tiles_in_set 
        load_path = filepath
        if not load_path:
            # Only ask for file if not part of project load and no path given
            if not is_part_of_project_load:
                load_path = filedialog.askopenfilename(
                    filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                    title="Open Supertiles",
                )
            if not load_path: # If still no load_path (user cancelled or was project load with no path)
                return False

        try:
            loaded_grid_width_from_file = 0
            loaded_grid_height_from_file = 0
            loaded_num_st_from_file = 0
            temp_supertiles_data_from_file = []
            header_size_st_calc = 0 

            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                first_count_byte_val = f.read(1)
                if not first_count_byte_val:
                    raise ValueError("File empty or missing supertile count byte(s).")
                
                indicator_byte = struct.unpack("B", first_count_byte_val)[0]
                header_size_st_calc += 1 

                if indicator_byte == 0: 
                    count_bytes_short = f.read(2)
                    if len(count_bytes_short) < 2:
                        raise EOFError("EOF reading 2-byte supertile count after indicator.")
                    loaded_num_st_from_file = struct.unpack(">H", count_bytes_short)[0]
                    header_size_st_calc += 2 
                else: 
                    loaded_num_st_from_file = indicator_byte
                
                if not (0 <= loaded_num_st_from_file <= MAX_SUPERTILES):
                    raise ValueError(
                        f"Invalid supertile count in file: {loaded_num_st_from_file} (must be 0-{MAX_SUPERTILES})"
                    )
                
                dim_w_byte = f.read(1)
                dim_h_byte = f.read(1)
                if not dim_w_byte or not dim_h_byte:
                    raise EOFError("File missing supertile dimension bytes.")
                
                loaded_grid_width_from_file = struct.unpack("B", dim_w_byte)[0]
                loaded_grid_height_from_file = struct.unpack("B", dim_h_byte)[0]
                header_size_st_calc += 2 

                if not (1 <= loaded_grid_width_from_file <= 32 and 1 <= loaded_grid_height_from_file <= 32):
                    if loaded_num_st_from_file == 0 and loaded_grid_width_from_file == 0 and loaded_grid_height_from_file == 0:
                        pass 
                    else:
                        raise ValueError(f"Invalid supertile dimensions in file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")

                tiles_per_definition_calc = loaded_grid_width_from_file * loaded_grid_height_from_file
                expected_data_payload_size_st = loaded_num_st_from_file * tiles_per_definition_calc 
                
                expected_size_old_format_st = header_size_st_calc + expected_data_payload_size_st
                expected_size_new_format_st = header_size_st_calc + RESERVED_BYTES_COUNT + expected_data_payload_size_st

                has_reserved_bytes_to_read = False
                if file_size_check == expected_size_new_format_st:
                    has_reserved_bytes_to_read = True
                    self.debug(f"Info: Supertile file '{os.path.basename(load_path)}' matches new format size.")
                elif file_size_check == expected_size_old_format_st:
                    has_reserved_bytes_to_read = False
                    self.debug(f"Info: Supertile file '{os.path.basename(load_path)}' matches old format size.")
                else:
                    raise ValueError(
                        f"Supertile file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for {loaded_num_st_from_file} supertiles ({loaded_grid_width_from_file}x{loaded_grid_height_from_file}). "
                        f"Expected old: {expected_size_old_format_st}, Expected new: {expected_size_new_format_st}."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format supertile file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from supertile file.")

                if loaded_num_st_from_file > 0:
                    temp_supertiles_data_from_file = [
                        [[0 for _c in range(loaded_grid_width_from_file)] for _r in range(loaded_grid_height_from_file)]
                        for _st in range(loaded_num_st_from_file)
                    ]
                    
                    bytes_per_definition_read = tiles_per_definition_calc 

                    for i in range(loaded_num_st_from_file):
                        st_bytes_read = f.read(bytes_per_definition_read)
                        if len(st_bytes_read) < bytes_per_definition_read:
                            raise EOFError(f"EOF reading data for supertile {i}. Expected {bytes_per_definition_read}, got {len(st_bytes_read)}.")
                        
                        byte_idx_val = 0
                        for r_load in range(loaded_grid_height_from_file):
                            for c_load in range(loaded_grid_width_from_file):
                                tile_idx_read = st_bytes_read[byte_idx_val] 
                                byte_idx_val += 1
                                if not (0 <= tile_idx_read <= 255): 
                                    self.debug(f"Warning: Invalid Tile index byte {tile_idx_read} in Supertile {i} at [{r_load},{c_load}]. Resetting to 0.")
                                    temp_supertiles_data_from_file[i][r_load][c_load] = 0
                                else:
                                    temp_supertiles_data_from_file[i][r_load][c_load] = tile_idx_read
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Supertile file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm_load = True
            # Only ask for overall confirmation if it's a standalone open and not part of project load
            if not is_part_of_project_load and filepath is None: 
                confirm_load = messagebox.askokcancel(
                    "Load Supertiles",
                    f"Replace current supertiles with {loaded_num_st_from_file} definition(s) from this file?\n(File Dimensions: {loaded_grid_width_from_file}W x {loaded_grid_height_from_file}H)",
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass 

                # Dimension mismatch confirmation only for standalone open
                if not is_part_of_project_load and \
                   (self.supertile_grid_width != loaded_grid_width_from_file or \
                    self.supertile_grid_height != loaded_grid_height_from_file):
                    dim_confirm = messagebox.askokcancel(
                        "Dimension Mismatch",
                        f"Supertile dimensions in file ({loaded_grid_width_from_file}x{loaded_grid_height_from_file}) "
                        f"differ from current project ({self.supertile_grid_width}x{self.supertile_grid_height}).\n\n"
                        "Loading will change project's supertile dimensions. This may affect existing supertile data and map. Continue?",
                        icon="warning"
                    )
                    if not dim_confirm:
                        return False 
                
                # This block now executes if:
                # 1. It's part of project load (is_part_of_project_load=True), OR
                # 2. It's standalone, and user confirmed overall load, AND (if dimensions differed) user confirmed dimension change.
                # It means we are committed to adopting the file's dimensions if they are different.
                if self.supertile_grid_width != loaded_grid_width_from_file or \
                   self.supertile_grid_height != loaded_grid_height_from_file:
                    self.debug(f"[DEBUG] open_supertiles: Adopting ST dimensions from file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")
                    self.supertile_grid_width = loaded_grid_width_from_file
                    self.supertile_grid_height = loaded_grid_height_from_file
                    # Re-initialize global supertiles_data to the new dimensions, clearing old content.
                    # MAX_SUPERTILES is the capacity.
                    supertiles_data = [
                        [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                        for _st_init in range(MAX_SUPERTILES) 
                    ]
                    self.clear_all_caches() # Critical after dimension change
                    self._reconfigure_supertile_definition_canvas() # Update definition canvas size
                    # Note: map data is not "converted" here. It will be re-read by open_map if part of project load.
                    # If standalone, the existing map will now be interpreted with new ST cell sizes.
                
                # Apply loaded data
                for i in range(loaded_num_st_from_file):
                    if i < MAX_SUPERTILES: # Ensure we don't write past allocated global list
                        # temp_supertiles_data_from_file was created with file's dimensions
                        # And supertiles_data was just re-initialized to these same dimensions if they changed.
                        supertiles_data[i] = temp_supertiles_data_from_file[i]
                    else: break # Should not happen if loaded_num_st_from_file <= MAX_SUPERTILES
                
                # If fewer supertiles were loaded than currently exist in project (e.g. standalone load of smaller set)
                if num_supertiles > loaded_num_st_from_file:
                    for i in range(loaded_num_st_from_file, num_supertiles):
                        if i < MAX_SUPERTILES: # Ensure index is valid
                             supertiles_data[i] = [[0]*self.supertile_grid_width for _r_clear in range(self.supertile_grid_height)]

                num_supertiles = loaded_num_st_from_file
                if num_supertiles == 0 and MAX_SUPERTILES > 0 : # Ensure at least one ST if max allows
                    num_supertiles = 1 
                    if supertiles_data: # Should exist if MAX_SUPERTILES > 0
                         supertiles_data[0] = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                
                current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
                selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))
                
                max_valid_tile_idx = num_tiles_in_set - 1
                for st_idx_val in range(num_supertiles):
                    for r_val in range(self.supertile_grid_height):
                        for c_val in range(self.supertile_grid_width):
                            if supertiles_data[st_idx_val][r_val][c_val] > max_valid_tile_idx:
                                self.debug(f"Warning: Supertile {st_idx_val} [{r_val},{c_val}] references tile {supertiles_data[st_idx_val][r_val][c_val]}, "
                                           f"which is out of bounds for current tileset size ({num_tiles_in_set}). Resetting to 0.")
                                supertiles_data[st_idx_val][r_val][c_val] = 0

                self.supertile_image_cache.clear() 
                self.map_render_cache.clear()      
                self.invalidate_minimap_background_cache()
                
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()
                self._update_edit_menu_state()
                self._update_supertile_rotate_button_state() 

                if not is_part_of_project_load and filepath is None: # Message for standalone interactive open
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_supertile_editor.winfo_exists():
                            self.notebook.select(self.tab_supertile_editor)
                    except tk.TclError:
                         self.debug("[DEBUG] open_supertiles: TclError selecting supertile editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_supertiles} supertiles ({self.supertile_grid_width}x{self.supertile_grid_height}) from {os.path.basename(load_path)}",
                    )
                
                # Mark modified only for standalone interactive open, not for project load (project load handles its own flag)
                if not is_part_of_project_load and filepath is None: 
                    self._mark_project_modified()
                return True
            else: 
                return False # User cancelled confirmation dialog

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Invalid data, size, or format in supertile file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Failed to open or parse supertiles file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_map(self, filepath=None):
        global map_width, map_height, map_data, num_supertiles # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Map",
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Save Map As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write dimensions (Big-endian, 2 bytes each)
                dim_bytes = struct.pack(">HH", map_width, map_height)
                f.write(dim_bytes)

                # --- ADDED: Write reserved bytes after the header ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---

                # --- MODIFIED: Write map data with conditional index size ---
                # Determine if we need 1-byte or 2-byte indices for ST references
                # based on the current project's num_supertiles.
                # num_supertiles is the actual count (e.g., 1 to 65535)
                
                use_2_byte_indices_for_map = (num_supertiles > 255)
                if use_2_byte_indices_for_map:
                    self.debug(f"[DEBUG] save_map: Using 2-byte ST indices (num_supertiles={num_supertiles}).")
                else:
                    self.debug(f"[DEBUG] save_map: Using 1-byte ST indices (num_supertiles={num_supertiles}).")

                for r in range(map_height):
                    if r >= len(map_data): # Should not happen if map_data is consistent
                        self.debug(f"[DEBUG] save_map: map_height > len(map_data) at row {r}. Padding rest of map.")
                        # Pad remaining rows if data is inconsistent
                        for _pad_r in range(map_height - r):
                            for _pad_c in range(map_width):
                                if use_2_byte_indices_for_map:
                                    f.write(struct.pack(">H", 0))
                                else:
                                    f.write(struct.pack("B", 0))
                        break # Stop processing rows

                    row_data = map_data[r]
                    for c in range(map_width):
                        supertile_index_val = 0 # Default if cell data missing
                        if c < len(row_data):
                            supertile_index_val = row_data[c]
                        
                        if use_2_byte_indices_for_map:
                            # Ensure index is within 2-byte range (0-65535)
                            safe_supertile_index_val = max(0, min(65535, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                self.debug(f"[DEBUG] save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 2-byte save.")
                            index_bytes = struct.pack(">H", safe_supertile_index_val)
                            f.write(index_bytes)
                        else:
                            # Ensure index is within 1-byte range (0-255)
                            safe_supertile_index_val = max(0, min(255, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                self.debug(f"[DEBUG] save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 1-byte save (project ST count <= 255).")
                            index_byte = struct.pack("B", safe_supertile_index_val)
                            f.write(index_byte)
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Map saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Map Error",
                f"Failed to save map file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_map(self, filepath=None): # MODIFIED: Removed is_part_of_project_load
        global map_data, map_width, map_height, num_supertiles # Using globals
        load_path = filepath
        if not load_path:
            # This block is for interactive "Open Map..." via menu
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Open Map",
                parent=self.root
            )
            if not load_path:
                return False

        try:
            loaded_w_map = 0
            loaded_h_map = 0
            new_map_data_from_file_temp = [] 
            map_uses_2byte_indices_in_file = False
            header_size_map_calc = 4 

            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                dim_bytes = f.read(header_size_map_calc) 
                if len(dim_bytes) < header_size_map_calc:
                    raise ValueError("Invalid map header: not enough bytes for dimensions.")
                loaded_w_map, loaded_h_map = struct.unpack(">HH", dim_bytes)
                
                min_dim_map, max_dim_map = 1, 1024 
                if not (min_dim_map <= loaded_w_map <= max_dim_map and min_dim_map <= loaded_h_map <= max_dim_map):
                    raise ValueError(f"Invalid map dimensions in file: {loaded_w_map}x{loaded_h_map} (must be {min_dim_map}-{max_dim_map} per side)")

                num_cells_map = loaded_w_map * loaded_h_map
                expected_payload_1byte_indices = num_cells_map * 1
                expected_payload_2byte_indices = num_cells_map * 2
                
                expected_size_old_format_map = header_size_map_calc + expected_payload_1byte_indices
                expected_size_new_format_map_1byte = header_size_map_calc + RESERVED_BYTES_COUNT + expected_payload_1byte_indices
                expected_size_new_format_map_2byte = header_size_map_calc + RESERVED_BYTES_COUNT + expected_payload_2byte_indices

                has_reserved_bytes_to_read = False
                
                if file_size_check == expected_size_new_format_map_1byte:
                    has_reserved_bytes_to_read = True
                    map_uses_2byte_indices_in_file = False
                elif file_size_check == expected_size_new_format_map_2byte:
                    has_reserved_bytes_to_read = True
                    map_uses_2byte_indices_in_file = True
                elif file_size_check == expected_size_old_format_map:
                    has_reserved_bytes_to_read = False # Old format implies no reserved bytes
                    map_uses_2byte_indices_in_file = False # Old format implies 1-byte indices
                else:
                    raise ValueError(
                        f"Map file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for dimensions {loaded_w_map}x{loaded_h_map}. Expected old(1B-idx): {expected_size_old_format_map}, "
                        f"new(1B-idx): {expected_size_new_format_map_1byte}, or new(2B-idx): {expected_size_new_format_map_2byte}."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format map file.")
                
                new_map_data_from_file_temp = [[0 for _c in range(loaded_w_map)] for _r in range(loaded_h_map)]
                for r_map_load in range(loaded_h_map):
                    for c_map_load in range(loaded_w_map):
                        st_index_val_read = 0
                        if map_uses_2byte_indices_in_file:
                            idx_bytes = f.read(2)
                            if len(idx_bytes) < 2: raise EOFError(f"EOF reading 2-byte ST index at map ({r_map_load},{c_map_load}).")
                            st_index_val_read = struct.unpack(">H", idx_bytes)[0]
                        else: 
                            idx_byte = f.read(1)
                            if not idx_byte: raise EOFError(f"EOF reading 1-byte ST index at map ({r_map_load},{c_map_load}).")
                            st_index_val_read = struct.unpack("B", idx_byte)[0]
                        new_map_data_from_file_temp[r_map_load][c_map_load] = st_index_val_read
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Map file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")
            
            confirm_load_map = True
            if filepath is None: # Only ask confirmation if interactive
                confirm_load_map = messagebox.askokcancel("Load Map", "Replace current map with data from this file?", parent=self.root)

            if confirm_load_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                temp_project_map_data_final = [[0 for _c in range(loaded_w_map)] for _r in range(loaded_h_map)] # Renamed
                missing_supertile_indices_referenced = set()

                for r_val in range(loaded_h_map):
                    for c_val in range(loaded_w_map):
                        supertile_index_from_file = new_map_data_from_file_temp[r_val][c_val]
                        if not (0 <= supertile_index_from_file < num_supertiles): # Check against current project's num_supertiles
                            missing_supertile_indices_referenced.add(supertile_index_from_file)
                            temp_project_map_data_final[r_val][c_val] = 0 
                        else:
                            temp_project_map_data_final[r_val][c_val] = supertile_index_from_file
                
                map_width = loaded_w_map
                map_height = loaded_h_map
                map_data = temp_project_map_data_final # Assign to global

                if missing_supertile_indices_referenced and filepath is None: # Show warning only for interactive load
                    sorted_missing = sorted(list(missing_supertile_indices_referenced))
                    msg = "Warning: The loaded map references supertile indices that do not exist in the current project's supertile set.\n\n"
                    msg += f"Missing indices found: {', '.join(map(str, sorted_missing[:20]))}"
                    if len(sorted_missing) > 20: msg += "..."
                    msg += "\n\nThese map cells have been defaulted to use Supertile 0."
                    messagebox.showwarning("Map Load Warning", msg, parent=self.root)

                if filepath is None: # Interactive standalone open
                    self.map_render_cache.clear() # Clear map render cache
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all") 
                    self._trigger_minimap_reconfigure() 
                    self._request_supertile_usage_refresh() # Map data changed

                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_map_editor.winfo_exists():
                            self.notebook.select(self.tab_map_editor)
                    except tk.TclError: pass
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {map_width}x{map_height} map from {os.path.basename(load_path)}",
                        parent=self.root
                    )
                    self._mark_project_modified()
                return True
            else: 
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}", parent=self.root)
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Map Error",
                f"Invalid data, size, or format in map file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Map Error",
                f"Failed to open or parse map file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
            return False

    # --- Project Save/Load Methods ---

    def save_project(self):
        if self.current_project_base_path:
            base_path = self.current_project_base_path
            pal_path = base_path + ".SC4Pal" # UPDATED Extension
            til_path = base_path + ".SC4Tiles"
            sup_path = base_path + ".SC4Super"
            map_path = base_path + ".SC4Map"

            self.debug(f"[DEBUG] save_project: Saving to existing base path {base_path}")

            success = True
            if success:
                self.debug(f"[DEBUG] save_project: Saving palette to {pal_path}")
                success = self.save_palette(pal_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving tileset to {til_path}")
                success = self.save_tileset(til_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving supertiles to {sup_path}")
                success = self.save_supertiles(sup_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving map to {map_path}")
                success = self.save_map(map_path)

            if success:
                self.debug("[DEBUG] save_project: All components saved successfully.")
                self.project_modified = False
                self._update_window_title()
                return True
            else:
                self.debug("[DEBUG] save_project: One or more components failed to save.")
                # Consider showing a messagebox here if a component save fails during "Save Project"
                # For now, it just returns False and logs.
                return False
        else:
            self.debug("[DEBUG] save_project: No current_project_base_path, calling save_project_as.")
            return self.save_project_as()

    def save_project_as(self):
        base_path_from_dialog = filedialog.asksaveasfilename(
            title="Save Project As (Enter Base Name for Components)",
            filetypes=[("MSX Tile Forge Project", "*")], # Simplified filetype, user types name
            parent=self.root,
            # defaultextension can be tricky if user types an extension.
            # It's often better to let them type the base name and append extensions manually.
        )

        if not base_path_from_dialog:
            self.debug("[DEBUG] save_project_as: User cancelled 'Save As' dialog.")
            return False 

        # Ensure we have a clean base path without any user-typed extension
        # For example, if user types "myproject.til", true_base_path should be "myproject"
        true_base_path, user_typed_ext = os.path.splitext(base_path_from_dialog)
        if not true_base_path: # If input was just ".ext" or ""
            self.debug(f"[DEBUG] save_project_as: Invalid base name from dialog: '{base_path_from_dialog}'")
            messagebox.showerror("Save Error", "Invalid base name for project.", parent=self.root)
            return False
        # If user typed something like "myproject" (no ext), splitext gives ("myproject", "").
        # If user typed "myproject.txt", splitext gives ("myproject", ".txt"). We want "myproject".
        # The current logic is: true_base_path will be the part before the last dot.
        # If no dot, user_typed_ext will be empty, and true_base_path is the whole string. This is good.
        
        self.debug(f"[DEBUG] save_project_as: User selected/input: '{base_path_from_dialog}', True base path for components: '{true_base_path}'")

        pal_path = true_base_path + ".SC4Pal"   # UPDATED Extension
        til_path = true_base_path + ".SC4Tiles"
        sup_path = true_base_path + ".SC4Super"
        map_path = true_base_path + ".SC4Map"

        # Check if any of these files already exist and confirm overwrite for the set
        # This is a bit more complex for a project "Save As" because multiple files are involved.
        # A simple approach is to warn if *any* would overwrite and ask for global confirmation.
        existing_files_to_overwrite = []
        if os.path.exists(pal_path): existing_files_to_overwrite.append(os.path.basename(pal_path))
        if os.path.exists(til_path): existing_files_to_overwrite.append(os.path.basename(til_path))
        if os.path.exists(sup_path): existing_files_to_overwrite.append(os.path.basename(sup_path))
        if os.path.exists(map_path): existing_files_to_overwrite.append(os.path.basename(map_path))

        if existing_files_to_overwrite:
            confirm_msg = "One or more project component files already exist at this location:\n"
            confirm_msg += "\n".join(existing_files_to_overwrite)
            confirm_msg += "\n\nOverwrite these files?"
            if not messagebox.askokcancel("Confirm Overwrite", confirm_msg, icon="warning", parent=self.root):
                self.debug("[DEBUG] save_project_as: User cancelled overwrite of existing project files.")
                return False # User cancelled overwrite

        success = True
        # These individual save methods already handle their own success/failure.
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving palette to {pal_path}")
            success = self.save_palette(pal_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving tileset to {til_path}")
            success = self.save_tileset(til_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving supertiles to {sup_path}")
            success = self.save_supertiles(sup_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving map to {map_path}")
            success = self.save_map(map_path)

        if success:
            self.debug("[DEBUG] save_project_as: All components saved successfully.")
            self.current_project_base_path = true_base_path 
            self.project_modified = False
            self._update_window_title()
            return True
        else:
            self.debug("[DEBUG] save_project_as: One or more components failed to save.")
            messagebox.showerror(
                "Project Save Error", 
                "One or more project components failed to save. The project may be partially saved.", # Clarified message
                parent=self.root
            )
            # Don't set current_project_base_path if save wasn't fully successful.
            # Project might still be considered modified.
            return False
    
    def open_project(self):
        filepath = filedialog.askopenfilename(
            filetypes=[
                ("SC4 Palette File (*.SC4Pal)", "*.SC4Pal"),       
                ("MSX Tileset File (*.SC4Tiles)", "*.SC4Tiles"),  
                ("MSX Supertile File (*.SC4Super)", "*.SC4Super"),
                ("MSX Map File (*.SC4Map)", "*.SC4Map"),
                ("Old MSX Palette File (*.msxpal)", "*.msxpal"), 
                ("All Files", "*.*"),
            ],
            title="Open Project (Select Any Component File)",
            parent=self.root
        )
        if not filepath:
            return 

        directory = os.path.dirname(filepath)
        base_name_with_ext = os.path.basename(filepath)
        base_name, selected_ext = os.path.splitext(base_name_with_ext) 
        
        base_path = os.path.join(directory, base_name)

        pal_path_new = base_path + ".SC4Pal"
        pal_path_old = base_path + ".msxpal"
        
        actual_pal_path_to_load = None
        if os.path.exists(pal_path_new):
            actual_pal_path_to_load = pal_path_new
        elif os.path.exists(pal_path_old): 
            actual_pal_path_to_load = pal_path_old

        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        missing_files = []
        if actual_pal_path_to_load is None: 
            missing_files.append(f"{base_name}.SC4Pal (or .msxpal)")
        if not os.path.exists(til_path): missing_files.append(os.path.basename(til_path))
        if not os.path.exists(sup_path): missing_files.append(os.path.basename(sup_path))
        if not os.path.exists(map_path): missing_files.append(os.path.basename(map_path))

        if missing_files:
            messagebox.showerror("Open Project Error", 
                                 f"Cannot open project '{base_name}'.\nMissing component file(s):\n" + "\n".join(missing_files),
                                 parent=self.root)
            return

        if self.project_modified:
            confirm_discard = messagebox.askokcancel("Unsaved Changes", 
                                                     f"Discard current unsaved changes and open project '{base_name}'?", 
                                                     icon="warning", parent=self.root)
            if not confirm_discard:
                return
        
        # --- Gather states of currently open usage windows BEFORE destroying them ---
        self.debug("[DEBUG] Open Project: Gathering current usage window states before load.")
        self._gather_current_open_window_states()
        # --- End Gather ---

        # --- Destroy existing usage windows (as loading project will re-initialize data) ---
        if self.color_usage_window and tk.Toplevel.winfo_exists(self.color_usage_window):
            self.color_usage_window.destroy()
        self.color_usage_window = None
        if self.tile_usage_window and tk.Toplevel.winfo_exists(self.tile_usage_window):
            self.tile_usage_window.destroy()
        self.tile_usage_window = None
        if self.supertile_usage_window and tk.Toplevel.winfo_exists(self.supertile_usage_window):
            self.supertile_usage_window.destroy()
        self.supertile_usage_window = None
        # --- End Destroy ---
        
        self.is_ctrl_pressed = False
        self.is_shift_pressed = False
        self.current_mouse_action = None
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data 
        tile_clipboard_pattern = None
        tile_clipboard_colors = None
        supertile_clipboard_data = None 
        self.map_clipboard_data = None
        self._clear_map_selection()
        self._clear_paste_preview_rect()
        self._clear_marked_unused(trigger_redraw=False) 
        
        self.clear_all_caches() 
        self.invalidate_minimap_background_cache() 

        success = True
        self.debug(f"Loading project '{base_name}'...")
        
        if success: self.debug(f"  Loading palette: {actual_pal_path_to_load}"); success = self.open_palette(actual_pal_path_to_load)
        if success: self.debug(f"  Loading tileset: {til_path}"); success = self.open_tileset(til_path)
        if success: self.debug(f"  Loading supertiles: {sup_path}"); success = self.open_supertiles(sup_path, is_part_of_project_load=True) 
        if success: self.debug(f"  Loading map: {map_path}"); success = self.open_map(map_path)
        
        if success:
            self.project_modified = False 
            self.current_project_base_path = base_path 
            self._update_window_title()
            
            self._reconfigure_supertile_definition_canvas()

            def deferred_refresh_and_updates_after_project_load():
                self._perform_project_load_ui_updates() # This updates displays, menus, etc.
                # Re-apply usage window states AFTER project data is loaded and UI is stable
                self.debug("[DEBUG] Open Project: Re-applying initial usage window states post-load.")
                self._apply_initial_usage_window_states()
                # Request refresh for any windows that were just re-opened
                self._request_color_usage_refresh() 
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

            self.root.after_idle(deferred_refresh_and_updates_after_project_load) 
            self.debug(f"[DEBUG] open_project: Project '{base_name}' load sequence initiated. UI updates and usage refreshes deferred.")

        else: 
            messagebox.showerror("Project Open Error", 
                                 f"Failed to load one or more components for project '{base_name}'. The application state might be inconsistent.",
                                 parent=self.root)
            self.project_modified = True 
            self._update_window_title()
            self._reconfigure_supertile_definition_canvas() 
            
            def deferred_fail_refresh_and_updates_after_project_load():
                self.update_all_displays(changed_level="all") 
                self._update_edit_menu_state()
                self._update_editor_button_states()
                self._update_supertile_rotate_button_state()
                # Still try to apply window states even on partial load failure, using whatever config was loaded
                self.debug("[DEBUG] Open Project (Failed): Applying usage window states.")
                self._apply_initial_usage_window_states()
                self._request_color_usage_refresh() 
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

            self.root.after_idle(deferred_fail_refresh_and_updates_after_project_load)

    def _perform_project_load_ui_updates(self):
        """Helper method to perform UI updates after a project load and Tkinter idle cycle."""
        self.debug("[DEBUG] _perform_project_load_ui_updates: Starting deferred UI updates.")
        
        # Ensure the correct tab is selected (e.g., map editor - or a default)
        # If loading a project, perhaps default to the map editor or the palette editor.
        # For now, let's assume it might try to select the map editor.
        target_tab_after_load = self.tab_map_editor # Or self.tab_palette_editor
        try:
            if self.notebook and self.notebook.winfo_exists() and target_tab_after_load.winfo_exists():
                 self.notebook.select(target_tab_after_load)
                 self.debug(f"  [DEBUG] Switched to {target_tab_after_load.winfo_class()} tab after project load.")
            self.root.update_idletasks() # Allow tab switch to process
        except tk.TclError:
            self.debug("[DEBUG] _perform_project_load_ui_updates: TclError selecting default tab after load.")

        # Now update all displays; widgets should have their correct sizes.
        self.update_all_displays(changed_level="all")
        
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        
        # Specific updates for map if it's the active tab now
        is_map_tab_active = False
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
        except tk.TclError: pass

        if is_map_tab_active:
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                self.map_canvas.focus_set()
            self.draw_minimap() 
            if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                self._do_check_and_enforce_palette_min_width()
        
        self._update_map_cursor() 
        
        # --- Re-apply usage window states AFTER project data is loaded and UI is stable ---
        self.debug("[DEBUG] Project Load/New: Re-applying initial usage window states.")
        self._apply_initial_usage_window_states() # This will open windows as per config
        # --- End Re-apply ---
        
        # Request refresh for any windows that were just re-opened by the call above
        self._request_color_usage_refresh()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        
        self.debug("[DEBUG] _perform_project_load_ui_updates: Deferred UI updates complete.")

    # --- Edit Menu Commands ---

    def set_tileset_size(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        prompt = f"Enter number of tiles (1-{MAX_TILES}):"
        new_size_str = simpledialog.askstring(
            "Set Tileset Size", prompt, initialvalue=str(num_tiles_in_set)
        )

        if new_size_str:
            try:
                new_size = int(new_size_str)

                if not (1 <= new_size <= MAX_TILES):
                    messagebox.showerror(
                        "Invalid Size", f"Size must be between 1 and {MAX_TILES}."
                    )
                    return

                if new_size == num_tiles_in_set:
                    return

                reduced = new_size < num_tiles_in_set
                confirmed_resize = True # Renamed for clarity
                if reduced:
                    affected_supertiles_list = set() # Use a set to avoid duplicates
                    for del_idx_tile in range(new_size, num_tiles_in_set):
                        # _check_tile_usage uses self.supertile_grid_width/height internally
                        usage_list = self._check_tile_usage(del_idx_tile)
                        for st_idx_affected in usage_list:
                            affected_supertiles_list.add(st_idx_affected)

                    confirm_prompt_msg = f"Reducing size to {new_size} will discard tiles {new_size} to {num_tiles_in_set-1}."
                    if affected_supertiles_list:
                        confirm_prompt_msg += "\n\n*** WARNING! ***\nDiscarded tiles are used by Supertile(s):\n"
                        affected_list_sorted = sorted(list(affected_supertiles_list))
                        confirm_prompt_msg += ", ".join(map(str, affected_list_sorted[:10]))
                        if len(affected_list_sorted) > 10:
                            confirm_prompt_msg += "..."
                        confirm_prompt_msg += "\n\nReferences to discarded tiles in these Supertiles will be reset to Tile 0."

                    confirmed_resize = messagebox.askokcancel(
                        "Reduce Tileset Size", confirm_prompt_msg, icon="warning"
                    )

                if confirmed_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()

                    if reduced:
                        for del_idx_tile_loop in range(new_size, num_tiles_in_set):
                            # _update_supertile_refs_for_tile_change uses self.supertile_grid_width/height
                            self._update_supertile_refs_for_tile_change(
                                del_idx_tile_loop, "delete"
                            )
                            self._adjust_marked_indices_after_delete(self.marked_unused_tiles, del_idx_tile_loop)
                        for i in range(new_size, num_tiles_in_set):
                            self.invalidate_tile_cache(i) # Invalidate cache for tiles being removed from active set
                        
                        # Trim the lists
                        del tileset_patterns[new_size:]
                        del tileset_colors[new_size:]
                        # Ensure they are padded back to MAX_TILES if that's the desired behavior for fixed-size arrays
                        # For dynamic Python lists, this just shortens them.
                        # If MAX_TILES is a hard limit for array indexing elsewhere, pad them:
                        # while len(tileset_patterns) < MAX_TILES:
                        #     tileset_patterns.append([[0]*TILE_WIDTH for _r in range(TILE_HEIGHT)])
                        #     tileset_colors.append([(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)])


                    elif new_size > num_tiles_in_set: # Increasing size
                        # Add new blank tiles up to new_size, but not exceeding MAX_TILES
                        tiles_to_add = new_size - num_tiles_in_set
                        for _ in range(tiles_to_add):
                            if len(tileset_patterns) < MAX_TILES: # Check against actual list capacity
                                tileset_patterns.append(
                                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                                )
                                tileset_colors.append(
                                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                                )
                            else: # Should not happen if new_size <= MAX_TILES
                                break 
                    
                    num_tiles_in_set = new_size # Update the count of active tiles

                    current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
                    selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()

                    self._request_color_usage_refresh()
                    self._request_tile_usage_refresh()

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
                self.debug(f"[DEBUG]Error setting tileset size: {e}")

    def set_supertile_count(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map, supertiles_data

        prompt = f"Enter number of supertiles (1-{MAX_SUPERTILES}):"
        new_count_str = simpledialog.askstring(
            "Set Supertile Count", prompt, initialvalue=str(num_supertiles), parent=self.root
        )

        if new_count_str:
            try:
                new_count = int(new_count_str)

                if not (1 <= new_count <= MAX_SUPERTILES):
                    messagebox.showerror(
                        "Invalid Count",
                        f"Count must be between 1 and {MAX_SUPERTILES}.",
                        parent=self.root
                    )
                    return

                if new_count == num_supertiles:
                    return

                reduced_count = new_count < num_supertiles
                confirmed_st_resize = True
                if reduced_count:
                    affected_map_cells_list = []
                    for del_idx_st in range(new_count, num_supertiles):
                        usage_on_map = self._check_supertile_usage(del_idx_st)
                        affected_map_cells_list.extend(usage_on_map)

                    confirm_prompt_st = f"Reducing count to {new_count} will discard supertiles {new_count} to {num_supertiles-1}."
                    if affected_map_cells_list:
                        confirm_prompt_st += "\n\n*** WARNING! ***\nDiscarded supertiles are used on the Map."
                        confirm_prompt_st += (
                            "\n\nReferences on the Map will be reset to Supertile 0."
                        )

                    confirmed_st_resize = messagebox.askokcancel(
                        "Reduce Supertile Count", confirm_prompt_st, icon="warning", parent=self.root
                    )

                if confirmed_st_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()
                    data_structure_changed = False # To track if STs were added/removed

                    if reduced_count:
                        for del_idx_st_loop in range(new_count, num_supertiles):
                            self._update_map_refs_for_supertile_change(del_idx_st_loop, "delete")
                            self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, del_idx_st_loop)
                        
                        # Trim the supertiles_data list
                        if len(supertiles_data) > new_count: # Ensure we don't slice if already smaller
                            supertiles_data = supertiles_data[:new_count]
                        data_structure_changed = True
                        
                    elif new_count > num_supertiles: # Increasing count
                        st_to_add = new_count - num_supertiles
                        for _ in range(st_to_add):
                            if len(supertiles_data) < MAX_SUPERTILES:
                                supertiles_data.append(
                                    [[0] * self.supertile_grid_width for _r_add in range(self.supertile_grid_height)]
                                )
                                data_structure_changed = True
                            else: 
                                break # MAX_SUPERTILES limit hit during loop
                    
                    old_num_supertiles = num_supertiles
                    num_supertiles = len(supertiles_data) # Set from actual list length after ops
                    if num_supertiles != old_num_supertiles:
                        data_structure_changed = True


                    current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1 if num_supertiles > 0 else 0))
                    selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1 if num_supertiles > 0 else 0))

                    self.supertile_image_cache.clear()
                    self.map_render_cache.clear() # If map refs changed
                    self.invalidate_minimap_background_cache() # If map refs changed
                    
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()
                    self._update_supertile_rotate_button_state()
                    
                    if data_structure_changed: # If supertile list actually changed
                        self._request_tile_usage_refresh() # STs use tiles, their count/defs changed
                        self._request_supertile_usage_refresh() # ADD THIS LINE

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.", parent=self.root)
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}", parent=self.root)
                self.debug(f"[DEBUG]Error setting supertile count: {e}")

    def set_map_dimensions(self):
        global map_width, map_height, map_data # map_data is global

        prompt = "Enter new dimensions (Width x Height):"
        dims_str = simpledialog.askstring(
            "Set Map Dimensions", prompt, initialvalue=f"{map_width}x{map_height}", parent=self.root
        )

        if dims_str:
            try:
                parts = dims_str.lower().split("x")
                if len(parts) != 2:
                    raise ValueError("Format must be WidthxHeight")

                new_w_str = parts[0].strip()
                new_h_str = parts[1].strip()
                new_w = int(new_w_str)
                new_h = int(new_h_str)

                min_dim, max_dim = 1, 1024 # Example limits for map dimensions
                if not (min_dim <= new_w <= max_dim):
                    raise ValueError(f"Width must be between {min_dim} and {max_dim}")
                if not (min_dim <= new_h <= max_dim):
                    raise ValueError(f"Height must be between {min_dim} and {max_dim}")

                if new_w == map_width and new_h == map_height:
                    return  # No change

                reducing = new_w < map_width or new_h < map_height
                confirmed = True  
                if reducing:
                    confirm_prompt = "Reducing map size will discard data outside boundaries. Proceed?"
                    confirmed = messagebox.askokcancel("Resize Map", confirm_prompt, parent=self.root)

                if confirmed:
                    if self._clear_marked_unused(trigger_redraw=False):
                        # Redraw will be handled by update_all_displays
                        pass
                    self._mark_project_modified()
                    
                    new_map_data_temp = [[0 for _ in range(new_w)] for _ in range(new_h)] # Temporary new map data
                    
                    rows_to_copy = min(map_height, new_h)
                    cols_to_copy = min(map_width, new_w)
                    
                    for r_idx_map_dim in range(rows_to_copy): 
                        for c_idx_map_dim in range(cols_to_copy): 
                            if r_idx_map_dim < len(map_data) and c_idx_map_dim < len(map_data[r_idx_map_dim]): # Check bounds of old map_data
                                new_map_data_temp[r_idx_map_dim][c_idx_map_dim] = map_data[r_idx_map_dim][c_idx_map_dim]
                            # Else, new_map_data_temp cells remain 0 (default)

                    map_width = new_w
                    map_height = new_h
                    map_data = new_map_data_temp # Assign new map data

                    self.map_render_cache.clear() # Map dimensions changed, rendered STs may shift
                    self.invalidate_minimap_background_cache() # Minimap needs full redraw
                    
                    # Determine appropriate refresh level
                    if self.marked_unused_tiles or self.marked_unused_supertiles: # If marks were present (now cleared)
                        self.update_all_displays(changed_level="all")
                    else: # No marks involved, just map changed
                        self.update_all_displays(changed_level="map") # This will redraw map canvas
                    
                    self._trigger_minimap_reconfigure() # Ensure minimap aspect ratio is re-evaluated
                    self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE

            except ValueError as e:
                messagebox.showerror("Invalid Input", f"Error setting dimensions: {e}", parent=self.root)
            except Exception as e:
                messagebox.showerror(
                    "Error", f"An unexpected error occurred during map resize: {e}", parent=self.root
                )

    def clear_current_tile(self):
        global tileset_patterns, tileset_colors, current_tile_index, WHITE_IDX, BLACK_IDX, num_tiles_in_set # Globals
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Clear Tile", "No valid tile selected to clear.", parent=self.root)
            return
            
        prompt = f"Clear pattern and reset colors for Tile {current_tile_index}?"
        if messagebox.askokcancel("Clear Tile", prompt, parent=self.root):
            if self._clear_marked_unused(trigger_redraw=False):
                pass

            self._mark_project_modified()
            tileset_patterns[current_tile_index] = [
                [0] * TILE_WIDTH for _ in range(TILE_HEIGHT)
            ]
            tileset_colors[current_tile_index] = [
                (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
            ]
            self.invalidate_tile_cache(current_tile_index)

            if self.marked_unused_tiles or self.marked_unused_supertiles:
                self.update_all_displays(changed_level="all")
            else:
                self.update_all_displays(changed_level="tile_edit")
                
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            
            self.debug(f"Cleared Tile {current_tile_index}.")

    def clear_current_supertile(self):
        global supertiles_data, current_supertile_index # supertiles_data is global
        if not (0 <= current_supertile_index < num_supertiles):
            return
        prompt = f"Clear definition (set all to tile 0) for supertile {current_supertile_index}?"
        if messagebox.askokcancel("Clear Supertile", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            self._mark_project_modified()
            # Initialize with current project's supertile dimensions
            supertiles_data[current_supertile_index] = [
                [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            ]
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles): 
                self.update_all_displays(changed_level="supertile")
            else: 
                  self.update_all_displays(changed_level="all") # Use all if marks were cleared
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

    def clear_map(self):
        global map_data, map_width, map_height # map_data is global
        prompt = "Clear entire map (set all to supertile 0)?"
        if messagebox.askokcancel("Clear Map", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                # If marks were cleared, a more general redraw might be needed
                # update_all_displays will handle this if called
                pass

            self._mark_project_modified()
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)] # map_data is global
            self.invalidate_minimap_background_cache() # Map content changed

            # Determine appropriate refresh level
            if self.marked_unused_tiles or self.marked_unused_supertiles: # If marks were present (now cleared)
                self.update_all_displays(changed_level="all")
            else: # No marks involved, just map changed
                self.update_all_displays(changed_level="map")
            
            self._request_supertile_usage_refresh()

    def copy_current_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Copy Tile", "No valid tile selected.")
            return
        tile_clipboard_pattern = copy.deepcopy(tileset_patterns[current_tile_index])
        tile_clipboard_colors = copy.deepcopy(tileset_colors[current_tile_index])
        print(f"Tile {current_tile_index} copied.")
        self._update_edit_menu_state()

    def paste_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if tile_clipboard_pattern is None or tile_clipboard_colors is None:
            messagebox.showinfo("Paste Tile", "Tile clipboard is empty.")
            return
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Paste Tile", "No valid tile selected to paste onto.") 
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        self._mark_project_modified()
        tileset_patterns[current_tile_index] = copy.deepcopy(tile_clipboard_pattern)
        tileset_colors[current_tile_index] = copy.deepcopy(tile_clipboard_colors)
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile_edit")
        
        self._request_color_usage_refresh()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        
        print(f"Pasted onto Tile {current_tile_index}.")

    def copy_current_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Copy Supertile", "No valid supertile selected.")
            return
        
        # The clipboard will store a definition matching current project's ST dimensions
        supertile_clipboard_data = copy.deepcopy(
            supertiles_data[current_supertile_index] # supertiles_data is global
        )
        # Store dimensions with clipboard data for safer paste
        if hasattr(self, 'supertile_grid_width') and hasattr(self, 'supertile_grid_height'):
             # This is a good idea, but supertile_clipboard_data is just the list of lists currently.
             # To store dimensions, we'd need to change it to a dictionary:
             # self.supertile_clipboard_data_with_dims = {
             #    "width": self.supertile_grid_width,
             #    "height": self.supertile_grid_height,
             #    "data": copy.deepcopy(supertiles_data[current_supertile_index])
             # }
             # For now, sticking to existing global structure of supertile_clipboard_data.
             # Paste operation will assume clipboard data matches current project ST dimensions.
             pass

        print(f"Supertile {current_supertile_index} copied.")
        self._update_edit_menu_state()

    def paste_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if supertile_clipboard_data is None:
            messagebox.showinfo("Paste Supertile", "Supertile clipboard is empty.")
            return
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Paste Supertile", "No valid supertile selected to paste onto.")
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        try:
            if len(supertile_clipboard_data) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(supertile_clipboard_data[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0):
                supertiles_data[current_supertile_index] = copy.deepcopy(
                    supertile_clipboard_data 
                )
                self._mark_project_modified()
                self.invalidate_supertile_cache(current_supertile_index)
                self.invalidate_minimap_background_cache() # Map might change appearance
                if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                    self.update_all_displays(changed_level="supertile")
                else:
                    self.update_all_displays(changed_level="all") # Use all if marks cleared

                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

                print(f"Pasted onto Supertile {current_supertile_index}.")
            else:
                messagebox.showerror("Paste Error", "Supertile clipboard dimensions do not match current project supertile dimensions. Paste aborted.")
                if self.marked_unused_tiles or self.marked_unused_supertiles:
                     self.update_all_displays(changed_level="all")

        except Exception as e:
            messagebox.showerror("Paste Error", f"Could not paste supertile data due to structure mismatch or error: {e}")
            if self.marked_unused_tiles or self.marked_unused_supertiles:
                 self.update_all_displays(changed_level="all")

    # --- Zoom Methods ---
    def change_map_zoom_mult(self, factor):  # Renamed from change_map_zoom
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        view_x1, view_y1, view_x2, view_y2 = (
            canvas.xview()[0],
            canvas.yview()[0],
            canvas.xview()[1],
            canvas.yview()[1],
        )
        center_x_canvas = canvas.canvasx(
            (canvas.winfo_width() / 2)
        )  # Approximation of center
        center_y_canvas = canvas.canvasy((canvas.winfo_height() / 2))
        self.zoom_map_at_point(factor, center_x_canvas, center_y_canvas)

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size based on 8x8 base and zoom."""
        base_tile_size = 8  # 100% zoom = 8 pixels
        zoomed_size = base_tile_size * self.map_zoom_level
        return max(1, int(zoomed_size))  # Ensure at least 1 pixel

    # --- Scrolling Methods ---

    def scroll_viewers_to_tile(self, tile_index):
        """Scrolls the tileset viewers to make the specified tile index visible."""
        # Basic input validation
        if tile_index < 0:
            return

        # Define layout parameters
        padding = 1
        tile_size = VIEWER_TILE_SIZE
        items_per_row = NUM_TILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(tile_index, items_per_row)
        target_y = row * (tile_size + padding)

        # --- Scroll main viewer ---
        canvas_main = self.tileset_canvas
        try:
            # Get scroll region info (might be tuple or string)
            scroll_info_tuple = canvas_main.cget("scrollregion")
            # Convert to string and split for consistent parsing
            scroll_info = str(scroll_info_tuple).split()

            # Check if format is valid ("0 0 width height")
            if len(scroll_info) == 4:
                # Extract total height
                total_height = float(scroll_info[3])

                # Avoid division by zero
                if total_height > 0:
                    # Calculate scroll fraction
                    fraction = target_y / total_height
                    # Clamp fraction to valid range [0.0, 1.0]
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    # Perform the scroll
                    canvas_main.yview_moveto(clamped_fraction)
            # else: (Optional: handle invalid scrollregion format if needed)
            #     print(f"Warning: Invalid scrollregion format for main tileset viewer: {scroll_info}")

        except Exception as e:
            # Catch any error during scrolling
            print(f"Error scrolling main tileset viewer: {e}")

        # --- Scroll Supertile tab's viewer ---
        canvas_st = self.st_tileset_canvas
        try:
            scroll_info_st_tuple = canvas_st.cget("scrollregion")
            scroll_info_st = str(scroll_info_st_tuple).split()

            if len(scroll_info_st) == 4:
                total_height_st = float(scroll_info_st[3])

                if total_height_st > 0:
                    fraction_st = target_y / total_height_st
                    clamped_fraction_st = min(1.0, max(0.0, fraction_st))
                    canvas_st.yview_moveto(clamped_fraction_st)
            # else:
            #     print(f"Warning: Invalid scrollregion format for ST tileset viewer: {scroll_info_st}")

        except Exception as e:
            print(f"Error scrolling ST tileset viewer: {e}")

    def scroll_selectors_to_supertile(self, supertile_index):
        self.debug(f"\n[DEBUG] scroll_selectors_to_supertile: Attempting to ensure ST Index {supertile_index} is visible.")
        if supertile_index < 0:
            self.debug(f"  [DEBUG] Invalid supertile_index {supertile_index}. Aborting.")
            return

        canvases_to_scroll = []
        # Ensure we only try to scroll the selector that is currently visible (on the active tab)
        # This avoids unnecessary calculations and potential issues with non-mapped canvases.
        active_tab_widget = None
        if self.notebook and self.notebook.winfo_exists():
            try:
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    active_tab_widget = self.notebook.nametowidget(selected_tab_path)
            except tk.TclError:
                self.debug("  [DEBUG] TclError getting active tab. Cannot determine which selector to scroll.")
                return
        
        if active_tab_widget == self.tab_supertile_editor:
            if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                canvases_to_scroll.append({"widget": self.supertile_selector_canvas, "name": "SupertileTabSelector"})
        elif active_tab_widget == self.tab_map_editor:
            if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                canvases_to_scroll.append({"widget": self.map_supertile_selector_canvas, "name": "MapTabSelector"})
        
        if not canvases_to_scroll:
            self.debug("  [DEBUG] No relevant selector canvas is active/found to scroll.")
            return

        item_pixel_h_content = self.supertile_grid_height * TILE_HEIGHT
        item_pixel_w_content = self.supertile_grid_width * TILE_WIDTH
        padding = 1

        if item_pixel_w_content <= 0 or item_pixel_h_content <= 0:
            self.debug(f"  [DEBUG] Invalid item content pixel dimensions (W:{item_pixel_w_content}, H:{item_pixel_h_content}). Aborting.")
            return

        for canvas_info in canvases_to_scroll:
            canvas_widget = canvas_info["widget"]
            canvas_name = canvas_info["name"]
            self.debug(f"  [DEBUG] Processing scroll for: {canvas_name} to ST Index {supertile_index}")

            try:
                if not canvas_widget.winfo_ismapped():
                    self.debug(f"    [DEBUG] Canvas {canvas_name} is not mapped. Skipping scroll.")
                    continue

                canvas_widget.update_idletasks()
                actual_canvas_width = canvas_widget.winfo_width()
                canvas_viewport_height = canvas_widget.winfo_height() # Height of the visible part of the canvas
                self.debug(f"    [DEBUG] {canvas_name} - Actual Canvas Width: {actual_canvas_width}, Viewport Height: {canvas_viewport_height}")

                if actual_canvas_width <= 1 or canvas_viewport_height <= 1:
                    self.debug(f"    [DEBUG] {canvas_name} - Canvas dimensions too small. Skipping scroll.")
                    continue
                
                items_across_for_this_canvas = 0
                denominator_check = item_pixel_w_content + padding
                if denominator_check <= 0:
                    items_across_for_this_canvas = 1
                elif item_pixel_w_content + (2 * padding) > actual_canvas_width:
                    items_across_for_this_canvas = 0
                    if item_pixel_w_content <= actual_canvas_width:
                        items_across_for_this_canvas = 1
                else:
                    items_across_for_this_canvas = (actual_canvas_width - padding) // denominator_check
                items_across_for_this_canvas = max(1, items_across_for_this_canvas)
                self.debug(f"    [DEBUG] {canvas_name} - Calculated items_across: {items_across_for_this_canvas}")

                target_row, _ = divmod(supertile_index, items_across_for_this_canvas)
                target_item_y_top_content = target_row * (item_pixel_h_content + padding) + padding
                target_item_y_bottom_content = target_item_y_top_content + item_pixel_h_content
                self.debug(f"    [DEBUG] {canvas_name} - Target ST Index: {supertile_index}, Target Row: {target_row}")
                self.debug(f"    [DEBUG] {canvas_name} - Target Item Y Content (top/bottom): {target_item_y_top_content} / {target_item_y_bottom_content}")

                scroll_region_str_list = canvas_widget.cget("scrollregion")
                if not scroll_region_str_list: self.debug(f"    [DEBUG] {canvas_name} - Scrollregion is empty/None."); continue
                scroll_info_parts = str(scroll_region_str_list).split()
                if len(scroll_info_parts) != 4: self.debug(f"    [DEBUG] {canvas_name} - Invalid scrollregion format: {scroll_info_parts}."); continue
                
                total_content_height_in_scrollregion = float(scroll_info_parts[3])
                self.debug(f"    [DEBUG] {canvas_name} - Total Content Height in Scrollregion: {total_content_height_in_scrollregion}")

                if total_content_height_in_scrollregion <= 0: self.debug(f"    [DEBUG] {canvas_name} - Scrollregion height is zero or negative."); continue
                
                # --- Visibility Check ---
                # Get current viewport in content coordinates
                current_view_y1_content = canvas_widget.canvasy(0)
                current_view_y2_content = canvas_widget.canvasy(canvas_viewport_height)
                self.debug(f"    [DEBUG] {canvas_name} - Current Viewport Y (content coords): {current_view_y1_content:.2f} to {current_view_y2_content:.2f}")

                # Is the item already fully visible?
                # Add a small tolerance (e.g., 1 pixel) for floating point comparisons
                tolerance = 1 
                is_top_edge_visible = target_item_y_top_content >= (current_view_y1_content - tolerance)
                is_bottom_edge_visible = target_item_y_bottom_content <= (current_view_y2_content + tolerance)

                if is_top_edge_visible and is_bottom_edge_visible:
                    self.debug(f"    [DEBUG] {canvas_name} - Item {supertile_index} IS ALREADY FULLY VISIBLE. No scroll initiated.")
                else:
                    self.debug(f"    [DEBUG] {canvas_name} - Item {supertile_index} NOT fully visible (TopEdgeVis: {is_top_edge_visible}, BotEdgeVis: {is_bottom_edge_visible}). Proceeding with scroll calculation.")
                    # If item's top is above current view, scroll to bring its top to view_top
                    # If item's bottom is below current view, scroll to bring its bottom to view_bottom
                    # If item is larger than viewport, scroll to bring its top to view_top

                    target_scroll_y_content = target_item_y_top_content # Default: bring top of item to top of view

                    if target_item_y_bottom_content > current_view_y2_content and target_item_y_top_content > current_view_y1_content:
                        # If item's bottom is below view AND its top is also below (or at) view_top (i.e., item is mostly below)
                        # Scroll to make item's bottom align with viewport bottom
                        target_scroll_y_content = target_item_y_bottom_content - canvas_viewport_height
                    
                    # target_scroll_y_content is the desired content Y coordinate for the top of the viewport
                    fraction = target_scroll_y_content / total_content_height_in_scrollregion
                    clamped_fraction = min(1.0, max(0.0, fraction))
                
                    self.debug(f"    [DEBUG] {canvas_name} - Calculated scroll fraction: {fraction:.4f}, Clamped fraction: {clamped_fraction:.4f}")
                    
                    # Only call yview_moveto if the new fraction is different enough from the current one
                    current_y_view_fractions = canvas_widget.yview()
                    if abs(current_y_view_fractions[0] - clamped_fraction) > (1 / total_content_height_in_scrollregion) : # Only if change is > 1 pixel approx
                        self.debug(f"    [DEBUG] {canvas_name} - Current yview_frac[0]={current_y_view_fractions[0]:.4f}. Calling yview_moveto({clamped_fraction:.4f}).")
                        canvas_widget.yview_moveto(clamped_fraction)
                    else:
                        self.debug(f"    [DEBUG] {canvas_name} - Calculated scroll fraction {clamped_fraction:.4f} is too close to current yview_frac[0]={current_y_view_fractions[0]:.4f}. Scroll yview_moveto SKIPPED.")


            except tk.TclError as e_scroll:
                self.debug(f"    [DEBUG] {canvas_name} - TclError during scroll: {e_scroll}")
            except Exception as e_scroll_generic:
                self.debug(f"    [DEBUG] {canvas_name} - Unexpected error during scroll: {e_scroll_generic}")
        self.debug(f"[DEBUG] scroll_selectors_to_supertile: Finished processing for ST Index {supertile_index}\n")

    # --- vvv NEW Grid/Window Handlers vvv ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide window view
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
            valid = True
            if not (min_w <= new_w <= max_w):
                messagebox.showerror(
                    "Invalid Width", f"Window width must be {min_w}-{max_w}."
                )
                valid = False
            if not (min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Height", f"Window height must be {min_h}-{max_h}."
                )
                valid = False

            if not valid:
                # Reset entries to current state if invalid
                self._update_window_size_vars_from_state()  # Use internal helper
                return

            # If size changed (or even if not, just redraw for simplicity)
            self._clamp_window_view_position()  # Ensure position is valid for new size
            self.draw_map_canvas()
            self.draw_minimap()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:  # Handles non-integer input in IntVars
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
            self._update_window_size_vars_from_state()  # Reset on error
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")
            self._update_window_size_vars_from_state()

    def _update_window_size_vars_from_state(self):
        """Internal helper to set IntVars from the state variables."""
        # Needed because the IntVars are bound to entries, direct setting is best
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Trigger update if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())

    def _clamp_window_view_position(self):
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        # Max top-left position for the window view
        max_tile_x_clamp = total_map_tiles_w - current_w
        max_tile_y_clamp = total_map_tiles_h - current_h

        # Ensure max is not negative
        max_tile_x_clamp = max(0, max_tile_x_clamp)
        max_tile_y_clamp = max(0, max_tile_y_clamp)
        
        self.window_view_tile_x = max(0, min(self.window_view_tile_x, max_tile_x_clamp))
        self.window_view_tile_y = max(0, min(self.window_view_tile_y, max_tile_y_clamp))

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        """Moves the window view by dx, dy TILE steps."""
        if not self.show_window_view.get():
            return  # Only move if visible

        # Calculate new target position
        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        # Clamp within map bounds (recalculate max based on current size)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update if position changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "c":
            self.cycle_grid_color()
        elif self.show_window_view.get():  # Only move window if visible
            if key == "w":
                self.move_window_view_keyboard(0, -1)  # Move up
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)  # Move left
            elif key == "s":
                self.move_window_view_keyboard(0, 1)  # Move down
            elif key == "d":
                self.move_window_view_keyboard(1, 0)  # Move right

    # --- Window View Drag/Resize Handlers ---
    def _get_handle_at(self, canvas_x, canvas_y):
        """Checks if the click is on a resize handle, returns handle tag ('nw', 'n', etc.) or None."""
        if not self.show_window_view.get():
            return None
        # Find items tagged 'window_view_handle' near the click
        search_radius = WIN_VIEW_HANDLE_SIZE  # Search slightly larger than handle
        items = self.map_canvas.find_overlapping(
            canvas_x - search_radius,
            canvas_y - search_radius,
            canvas_x + search_radius,
            canvas_y + search_radius,
        )
        for item_id in items:
            tags = self.map_canvas.gettags(item_id)
            if "window_view_handle" in tags:
                for t in tags:
                    if t.startswith("handle_"):
                        return t.split("_")[1]  # Return 'nw', 'n', etc.
        return None  # No handle found

    def _is_inside_window_view(self, canvas_x, canvas_y):
        """Checks if the click is inside the window view rectangle bounds."""
        if not self.show_window_view.get():
            return False
        zoomed_tile_size = self.get_zoomed_tile_size()
        win_px = self.window_view_tile_x * zoomed_tile_size
        win_py = self.window_view_tile_y * zoomed_tile_size
        win_pw = self.window_view_tile_w.get() * zoomed_tile_size
        win_ph = self.window_view_tile_h.get() * zoomed_tile_size
        return (
            win_px <= canvas_x < win_px + win_pw
            and win_py <= canvas_y < win_py + win_ph
        )

    def handle_map_click_or_drag_start(self, event):
        """Handles initial NON-CTRL click: determines action (paint/window drag/resize).
        Sets up state AND performs the initial paint action if applicable.
        Also clears map selection if starting a paint/window action.
        """
        global last_painted_map_cell

        # --- Check for active modifiers that override this handler ---
        if self.is_shift_pressed:
            self.debug("[DEBUG]Shift pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if ctrl_pressed_at_click:
            self.debug("[DEBUG]Ctrl pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        if self.current_mouse_action is not None:
            self.debug(f"[DEBUG]Warning: Button-1 pressed while action '{self.current_mouse_action}' active.")
            return "break"
        # --- End Modifier Check ---

        # --- Clear previous selection when starting a new action ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        canvas = self.map_canvas
        canvas.focus_set()
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        action_determined = None
        handle = self._get_handle_at(canvas_x, canvas_y)

        # Determine action based on click location
        if handle and self.show_window_view.get():
            action_determined = "window_resizing"
            self.current_mouse_action = action_determined
            self.window_view_resize_handle = handle
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self.drag_start_win_tw = self.window_view_tile_w.get()
            self.drag_start_win_th = self.window_view_tile_h.get()

        elif (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            action_determined = "window_dragging"
            self.current_mouse_action = action_determined
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y

        else:  # Painting case
            action_determined = "painting"
            self.current_mouse_action = action_determined
            last_painted_map_cell = None  # Reset for this paint sequence
            self._paint_map_cell(canvas_x, canvas_y)  # Perform first paint

        self._update_map_cursor()  # Update cursor based on the determined action

        return "break"

    def handle_map_drag(self, event):
        """Handles motion for non-panning actions (paint, window drag/resize)."""

        # Ignore if panning or no suitable action is set from Button-1 press
        # This prevents interference if Ctrl was pressed *after* Button-1 was down but before motion.
        if self.current_mouse_action not in [
            "painting",
            "window_dragging",
            "window_resizing",
        ]:
            return  # Don't handle if not in a valid non-pan drag state

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Perform action based on the current state
        if self.current_mouse_action == "painting":
            self._paint_map_cell(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_dragging":
            self._do_window_move_drag(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_resizing":
            self._do_window_resize_drag(canvas_x, canvas_y)

        return "break"  # Prevent other B1-Motion bindings

    def handle_map_drag_release(self, event):
        """Handles mouse button release: ends the current action (paint, pan, window ops)."""
        global last_painted_map_cell  # Ensure global is accessible
        action_at_release = self.current_mouse_action

        last_painted_map_cell = None  # Stop continuous paint if it was happening

        # Reset the current action state FIRST
        self.current_mouse_action = None

        # Perform any finalization based on the action that just finished
        if action_at_release == "panning":
            pass  # No explicit action needed, scan_dragto stopped with motion

        elif action_at_release == "window_dragging":
            # Position is already snapped during drag, just update minimap (done below)
            pass

        elif action_at_release == "window_resizing":
            # Clamp final position and update entries/IntVar state just in case
            self._clamp_window_view_position()
            self._update_window_size_vars_from_state()  # Sync IntVars post-resize
            self.window_view_resize_handle = None
            # Redraw needed to finalize visual state and ensure entries match
            self.draw_map_canvas()  # Redraw map canvas to remove potential temp visuals

        elif action_at_release == "painting":
            pass  # No specific finalization needed

        self._update_map_cursor()
        self.draw_minimap()

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window movement during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        delta_x_pixels = current_canvas_x - self.drag_start_x
        delta_y_pixels = current_canvas_y - self.drag_start_y

        # Calculate movement in TILE units, snapping to grid
        # Use floor for consistent snapping direction
        delta_tile_x = math.floor(delta_x_pixels / zoomed_tile_size)
        delta_tile_y = math.floor(delta_y_pixels / zoomed_tile_size)

        # Calculate potential new top-left TILE coordinate
        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y

        # Clamp position within map bounds (using current W/H)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update state and redraw ONLY if position actually changes
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window resize during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        # Starting state in TILE units
        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th
        start_br_tx = start_tx + start_tw  # Bottom-right tile X (exclusive)
        start_br_ty = start_ty + start_th  # Bottom-right tile Y (exclusive)

        # Current mouse position snapped to TILE grid
        current_tile_x = math.floor(current_canvas_x / zoomed_tile_size)
        current_tile_y = math.floor(current_canvas_y / zoomed_tile_size)

        # Calculate new potential corners based on handle
        new_tx = start_tx
        new_ty = start_ty
        new_br_tx = start_br_tx
        new_br_ty = start_br_ty
        handle = self.window_view_resize_handle

        # Adjust based on handle dragged
        if "n" in handle:
            new_ty = current_tile_y
        if "s" in handle:
            new_br_ty = current_tile_y + 1  # +1 because BR is exclusive
        if "w" in handle:
            new_tx = current_tile_x
        if "e" in handle:
            new_br_tx = current_tile_x + 1

        # Ensure top-left is never beyond bottom-right
        new_tx = min(new_tx, new_br_tx - 1)  # Ensure width >= 1
        new_ty = min(new_ty, new_br_ty - 1)  # Ensure height >= 1
        new_br_tx = max(new_br_tx, new_tx + 1)
        new_br_ty = max(new_br_ty, new_ty + 1)

        # Calculate new width and height in tiles
        new_tw = new_br_tx - new_tx
        new_th = new_br_ty - new_ty

        # Clamp dimensions to allowed limits
        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        # Adjust position if clamping changed dimensions, preserving the fixed corner/edge
        if "n" in handle and clamped_th != new_th:
            new_ty = new_br_ty - clamped_th
        if "w" in handle and clamped_tw != new_tw:
            new_tx = new_br_tx - clamped_tw
        if "s" in handle:
            new_br_ty = (
                new_ty + clamped_th
            )  # Recalculate needed? No, height is clamped.
        if "e" in handle:
            new_br_tx = new_tx + clamped_tw

        # Clamp position to stay within map boundaries
        max_map_tile_x = map_width * SUPERTILE_GRID_DIM
        max_map_tile_y = map_height * SUPERTILE_GRID_DIM
        clamped_tx = max(0, min(new_tx, max_map_tile_x - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y - clamped_th))

        # Final check if clamping position changed dimensions again (shouldn't drastically)
        final_tw = min(clamped_tw, max_map_tile_x - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y - clamped_ty)

        # Update state only if position or size changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw
            or self.window_view_tile_h.get() != final_th
        ):
            #
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)  # Update IntVars
            self.window_view_tile_h.set(final_th)
            # self._update_window_size_vars_from_state() # Update entries
            self.draw_map_canvas()  # Redraw to show resize
            self.draw_minimap()

    # --- Minimap Methods ---

    def toggle_minimap(self):
        """Opens/raises the resizable minimap window."""
        if self.minimap_window is None or not tk.Toplevel.winfo_exists(
            self.minimap_window
        ):
            self.minimap_window = tk.Toplevel(self.root)
            self.minimap_window.title("Minimap")
            # Set initial size, but allow resizing
            self.minimap_window.geometry(
                f"{MINIMAP_INITIAL_WIDTH}x{MINIMAP_INITIAL_HEIGHT}"
            )
            # self.minimap_window.resizable(False, False) # REMOVE or set True

            self.minimap_canvas = tk.Canvas(
                self.minimap_window, bg="dark slate gray", highlightthickness=0
            )
            # Make canvas fill the resizable window
            self.minimap_canvas.pack(fill=tk.BOTH, expand=True)  # MODIFIED pack options
            self.minimap_window.protocol("WM_DELETE_WINDOW", self._on_minimap_close)
            self.minimap_window.bind("<Configure>", self._on_minimap_configure)

            # Initial draw (will use initial geometry)
            # Need to ensure canvas has dimensions before first draw
            self.minimap_window.update_idletasks()  # Process geometry requests
            self.draw_minimap()
        else:
            self.minimap_window.lift()
            self.minimap_window.focus_set()

    def _on_minimap_close(self):
        """Handles the closing of the minimap window."""
        if self.minimap_window:
            self.minimap_window.destroy()  # Destroy the window
        self.minimap_window = None  # Reset state variable
        self.minimap_canvas = None

    def draw_minimap(self):
        if self.minimap_window is None or self.minimap_canvas is None:
            return
        if not tk.Toplevel.winfo_exists(self.minimap_window):
            self._on_minimap_close()
            return

        canvas_mm = self.minimap_canvas # Renamed
        canvas_mm.delete("all")

        current_minimap_w_px = canvas_mm.winfo_width()
        current_minimap_h_px = canvas_mm.winfo_height()
        if current_minimap_w_px <= 1 or current_minimap_h_px <= 1:
            return

        if (
            self.minimap_background_cache is None
            or self.minimap_bg_rendered_width != current_minimap_w_px
            or self.minimap_bg_rendered_height != current_minimap_h_px
        ):
            self.minimap_background_cache = self._create_minimap_background_image(
                current_minimap_w_px, current_minimap_h_px
            )

        if self.minimap_background_cache:
            canvas_mm.create_image(
                0, 0, image=self.minimap_background_cache, anchor=tk.NW, tags="minimap_bg_image"
            )
        else:
            canvas_mm.create_rectangle(
                0, 0, current_minimap_w_px, current_minimap_h_px, fill="gray10"
            )

        # Total map dimensions in base MSX pixels
        map_total_msx_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_total_msx_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT
        
        if map_total_msx_pixel_w <= 0 or map_total_msx_pixel_h <= 0:
            return

        scale_x_overlay = current_minimap_w_px / map_total_msx_pixel_w
        scale_y_overlay = current_minimap_h_px / map_total_msx_pixel_h
        scale_overlay = min(scale_x_overlay, scale_y_overlay)

        scaled_map_content_w_overlay = map_total_msx_pixel_w * scale_overlay
        scaled_map_content_h_overlay = map_total_msx_pixel_h * scale_overlay
        offset_x_overlay_render = (current_minimap_w_px - scaled_map_content_w_overlay) / 2
        offset_y_overlay_render = (current_minimap_h_px - scaled_map_content_h_overlay) / 2

        try:
            main_map_canvas = self.map_canvas # Renamed
            scroll_x_fractions = main_map_canvas.xview()
            scroll_y_fractions = main_map_canvas.yview()

            # Total BASE map dimensions in MSX pixels (same as map_total_msx_pixel_w/h above)
            # This is what the scroll fractions are relative to.
            # map_total_base_msx_w = map_width * self.supertile_grid_width * TILE_WIDTH
            # map_total_base_msx_h = map_height * self.supertile_grid_height * TILE_HEIGHT
            # No need to recalculate, use map_total_msx_pixel_w/h

            if map_total_msx_pixel_w > 0 and map_total_msx_pixel_h > 0:
                map_viewport_msx_px_x1 = scroll_x_fractions[0] * map_total_msx_pixel_w
                map_viewport_msx_px_y1 = scroll_y_fractions[0] * map_total_msx_pixel_h
                map_viewport_msx_px_x2 = scroll_x_fractions[1] * map_total_msx_pixel_w
                map_viewport_msx_px_y2 = scroll_y_fractions[1] * map_total_msx_pixel_h

                vp_x1_draw = offset_x_overlay_render + map_viewport_msx_px_x1 * scale_overlay
                vp_y1_draw = offset_y_overlay_render + map_viewport_msx_px_y1 * scale_overlay
                vp_x2_draw = offset_x_overlay_render + map_viewport_msx_px_x2 * scale_overlay
                vp_y2_draw = offset_y_overlay_render + map_viewport_msx_px_y2 * scale_overlay

                canvas_mm.create_rectangle(
                    vp_x1_draw, vp_y1_draw, vp_x2_draw, vp_y2_draw,
                    outline=self.MINIMAP_VIEWPORT_COLOR, width=2, tags="minimap_viewport"
                )
        except Exception as e:
            self.debug(f"[DEBUG]Error drawing minimap viewport: {e}")
            pass

        if self.show_window_view.get():
            try:
                win_tx_mm = self.window_view_tile_x # In base tiles
                win_ty_mm = self.window_view_tile_y
                win_tw_mm = self.window_view_tile_w.get()
                win_th_mm = self.window_view_tile_h.get()

                # Window view dimensions in MSX pixels
                win_map_msx_px1 = win_tx_mm * TILE_WIDTH
                win_map_msx_py1 = win_ty_mm * TILE_HEIGHT
                win_map_msx_px2 = win_map_msx_px1 + (win_tw_mm * TILE_WIDTH)
                win_map_msx_py2 = win_map_msx_py1 + (win_th_mm * TILE_HEIGHT)

                wv_x1_draw = offset_x_overlay_render + win_map_msx_px1 * scale_overlay
                wv_y1_draw = offset_y_overlay_render + win_map_msx_py1 * scale_overlay
                wv_x2_draw = offset_x_overlay_render + win_map_msx_px2 * scale_overlay
                wv_y2_draw = offset_y_overlay_render + win_map_msx_py2 * scale_overlay

                canvas_mm.create_rectangle(
                    wv_x1_draw, wv_y1_draw, wv_x2_draw, wv_y2_draw,
                    outline=self.MINIMAP_WIN_VIEW_COLOR, width=2, dash=(4, 4), tags="minimap_window_view"
                )
            except Exception as e:
                self.debug(f"[DEBUG]Error drawing minimap window view: {e}")
                pass

    def _on_minimap_configure(self, event):
        """Callback when the minimap window is resized/moved."""
        # We only care about size changes for redrawing
        # Basic debouncing: wait a short time after the last configure event
        # before redrawing to avoid excessive calls during drag-resizing.
        debounce_ms = 150  # Adjust as needed (milliseconds)

        # Cancel any pending redraw timer
        if self.minimap_resize_timer is not None:
            self.root.after_cancel(self.minimap_resize_timer)

        # Schedule a new redraw after the debounce period
        self.minimap_resize_timer = self.root.after(
            debounce_ms, self._redraw_minimap_after_resize
        )

    def _redraw_minimap_after_resize(self):
        self.minimap_resize_timer = None 

        if not self.minimap_window or not tk.Toplevel.winfo_exists(self.minimap_window):
            return

        if self._minimap_resizing_internally:
            return

        try:
            current_width_mm_cfg = self.minimap_window.winfo_width()
            current_height_mm_cfg = self.minimap_window.winfo_height()

            # Map aspect ratio based on total MSX pixels
            map_total_msx_pixel_w_cfg = map_width * self.supertile_grid_width * TILE_WIDTH
            map_total_msx_pixel_h_cfg = map_height * self.supertile_grid_height * TILE_HEIGHT

            if map_total_msx_pixel_h_cfg <= 0 or map_total_msx_pixel_w_cfg <= 0 or \
               current_width_mm_cfg <= 1 or current_height_mm_cfg <= 1:
                self.invalidate_minimap_background_cache()
                self.draw_minimap()
                return

            map_aspect_ratio_cfg = map_total_msx_pixel_w_cfg / map_total_msx_pixel_h_cfg
            ideal_height_cfg = int(round(current_width_mm_cfg / map_aspect_ratio_cfg))

            if abs(current_height_mm_cfg - ideal_height_cfg) > 1: # Allow 1px tolerance
                self._minimap_resizing_internally = True
                new_geometry_cfg = f"{current_width_mm_cfg}x{ideal_height_cfg}"
                self.debug(f"[DEBUG]Minimap Configure: Forcing aspect ratio. New geometry: {new_geometry_cfg}")
                self.minimap_window.geometry(new_geometry_cfg)
                self.root.after(50, setattr, self, "_minimap_resizing_internally", False)
                # Redraw will be triggered by the geometry change causing another <Configure>
                return 
        except Exception as e:
            self.debug(f"[DEBUG]Error during minimap aspect ratio enforcement: {e}")
            self._minimap_resizing_internally = False # Ensure flag is reset

        self.debug(f"[DEBUG]Minimap Configure: Aspect ratio OK or no change needed. Redrawing.")
        self.invalidate_minimap_background_cache()
        self.draw_minimap()

    def _trigger_minimap_reconfigure(self):
        """Forces the minimap to re-evaluate its size and aspect ratio if it exists."""
        if self.minimap_window and tk.Toplevel.winfo_exists(self.minimap_window):
            # A simple way to trigger <Configure> is to slightly change the size
            # We can just call the resize logic directly though.
            print("Map dimensions changed, triggering minimap aspect check/redraw.")
            # Reset the resize timer to avoid duplicate calls if configure is also pending
            if self.minimap_resize_timer is not None:
                self.root.after_cancel(self.minimap_resize_timer)
                self.minimap_resize_timer = None
            # Directly call the logic that handles resizing and drawing
            self._redraw_minimap_after_resize()

    def invalidate_minimap_background_cache(self):
        """Clears the cached minimap background image."""
        self.minimap_background_cache = None
        # Reset rendered size trackers too
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0

    def _create_minimap_background_image(self, target_width_mm, target_height_mm): # Renamed params
        if target_width_mm <= 0 or target_height_mm <= 0:
            return None

        minimap_img_bg = tk.PhotoImage(width=target_width_mm, height=target_height_mm) # Renamed
        
        # Base map pixel dimensions (MSX pixels, assuming TILE_WIDTH/HEIGHT are base tile MSX pixels)
        map_base_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_base_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT

        if map_base_pixel_w <= 0 or map_base_pixel_h <= 0:
            self.debug("[DEBUG]Warning: Invalid base map pixel dimensions for minimap background.")
            minimap_img_bg.put("black", to=(0, 0, target_width_mm, target_height_mm))
            # Update cache trackers even for fallback
            self.minimap_bg_rendered_width = target_width_mm
            self.minimap_bg_rendered_height = target_height_mm
            self.minimap_background_cache = minimap_img_bg
            return minimap_img_bg

        scale_x_mm = target_width_mm / map_base_pixel_w
        scale_y_mm = target_height_mm / map_base_pixel_h
        scale_mm = min(scale_x_mm, scale_y_mm)
        
        scaled_map_content_w = map_base_pixel_w * scale_mm
        scaled_map_content_h = map_base_pixel_h * scale_mm
        offset_x_mm_render = (target_width_mm - scaled_map_content_w) / 2
        offset_y_mm_render = (target_height_mm - scaled_map_content_h) / 2
        
        bg_fill_color_mm = "#000000" # Black for letter/pillarbox

        for y_pix_mm in range(target_height_mm):
            row_hex_colors_mm = []
            for x_pix_mm in range(target_width_mm):
                pixel_color_hex_mm = bg_fill_color_mm

                if (offset_x_mm_render <= x_pix_mm < offset_x_mm_render + scaled_map_content_w and
                    offset_y_mm_render <= y_pix_mm < offset_y_mm_render + scaled_map_content_h):

                    map_src_base_x = (x_pix_mm - offset_x_mm_render) / max(1e-9, scale_mm)
                    map_src_base_y = (y_pix_mm - offset_y_mm_render) / max(1e-9, scale_mm)

                    map_src_base_x = max(0, min(map_base_pixel_w - 1, map_src_base_x))
                    map_src_base_y = max(0, min(map_base_pixel_h - 1, map_src_base_y))

                    map_pixel_col_src = int(map_src_base_x)
                    map_pixel_row_src = int(map_src_base_y)

                    # Pixels per supertile width/height
                    pixels_per_st_w = self.supertile_grid_width * TILE_WIDTH
                    pixels_per_st_h = self.supertile_grid_height * TILE_HEIGHT
                    if pixels_per_st_w <=0 : pixels_per_st_w = 1 # Avoid div by zero
                    if pixels_per_st_h <=0 : pixels_per_st_h = 1


                    st_col_mm = map_pixel_col_src // pixels_per_st_w
                    st_row_mm = map_pixel_row_src // pixels_per_st_h

                    tile_col_in_st_mm = (map_pixel_col_src % pixels_per_st_w) // TILE_WIDTH
                    tile_row_in_st_mm = (map_pixel_row_src % pixels_per_st_h) // TILE_HEIGHT
                    
                    pixel_col_in_tile_mm = map_pixel_col_src % TILE_WIDTH
                    pixel_row_in_tile_mm = map_pixel_row_src % TILE_HEIGHT
                    
                    try:
                        # Ensure st_row_mm, st_col_mm are within map_data bounds
                        if 0 <= st_row_mm < map_height and 0 <= st_col_mm < map_width:
                            supertile_idx_mm = map_data[st_row_mm][st_col_mm]
                            if 0 <= supertile_idx_mm < num_supertiles:
                                # Ensure definition structure is valid for current ST dimensions
                                st_def_mm = supertiles_data[supertile_idx_mm]
                                if st_def_mm and len(st_def_mm) == self.supertile_grid_height and \
                                   (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(st_def_mm[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) and \
                                   0 <= tile_row_in_st_mm < self.supertile_grid_height and \
                                   0 <= tile_col_in_st_mm < self.supertile_grid_width:

                                    tile_idx_mm = st_def_mm[tile_row_in_st_mm][tile_col_in_st_mm]
                                    if 0 <= tile_idx_mm < num_tiles_in_set:
                                        # Check bounds for tile pattern/color access
                                        if 0 <= pixel_row_in_tile_mm < TILE_HEIGHT and \
                                           0 <= pixel_col_in_tile_mm < TILE_WIDTH:
                                            pattern_val_mm = tileset_patterns[tile_idx_mm][pixel_row_in_tile_mm][pixel_col_in_tile_mm]
                                            fg_idx_mm, bg_idx_mm = tileset_colors[tile_idx_mm][pixel_row_in_tile_mm]
                                            
                                            # Validate palette indices
                                            if not (0 <= fg_idx_mm < len(self.active_msx_palette) and \
                                                    0 <= bg_idx_mm < len(self.active_msx_palette)):
                                                self.debug(f"[DEBUG]Warning: Invalid palette indices ({fg_idx_mm}, {bg_idx_mm}) in minimap render.")
                                                fg_idx_mm = WHITE_IDX; bg_idx_mm = BLACK_IDX # Fallback

                                            fg_color_mm = self.active_msx_palette[fg_idx_mm]
                                            bg_color_mm = self.active_msx_palette[bg_idx_mm]
                                            pixel_color_hex_mm = fg_color_mm if pattern_val_mm == 1 else bg_color_mm
                                        else: pixel_color_hex_mm = INVALID_TILE_COLOR # pixel in tile out of bounds
                                    else: pixel_color_hex_mm = INVALID_TILE_COLOR # tile_idx_mm out of bounds
                                else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # ST def structure issue or tile in ST out of bounds
                            else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # supertile_idx_mm out of bounds
                        else: pixel_color_hex_mm = "#808080" # Grey for outside map supertile grid
                    except IndexError:
                        pixel_color_hex_mm = "#FF0000" # Bright Red for major error
                
                row_hex_colors_mm.append(pixel_color_hex_mm)

            try:
                minimap_img_bg.put("{" + " ".join(row_hex_colors_mm) + "}", to=(0, y_pix_mm))
            except tk.TclError:
                self.debug(f"[DEBUG]Warning [Minimap BG]: TclError put row {y_pix_mm}: {e}")
                if row_hex_colors_mm:
                    minimap_img_bg.put(row_hex_colors_mm[0], to=(0, y_pix_mm, target_width_mm, y_pix_mm + 1))

        self.debug("[DEBUG]Minimap background generated.")
        self.minimap_bg_rendered_width = target_width_mm
        self.minimap_bg_rendered_height = target_height_mm
        self.minimap_background_cache = minimap_img_bg
        return minimap_img_bg

    def _update_window_title(self):
        """Updates the main window title based on the current project path."""
        base_title = "MSX Tile Forge"
        modifier = "*" if self.project_modified else ""

        if self.current_project_base_path:
            # Extract just the filename part
            project_name = os.path.basename(self.current_project_base_path)
            self.root.title(
                f"{base_title} - {project_name}{modifier}"
            )  # Prepend modifier
        else:
            self.root.title(f"{base_title} - Untitled{modifier}")  # Prepend modifier

    def _update_map_cursor(self):
        """Sets the map canvas cursor based on current action and modifier keys."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        new_cursor = ""  # Default arrow cursor

        # Determine cursor based on the active operation FIRST
        if self.current_mouse_action == "panning":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_dragging":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_resizing":
            new_cursor = "sizing"  # Generic resize
        elif self.map_selection_active:  # NEW: Selection in progress
            new_cursor = "crosshair"
        # --- Modifier key hints (if NO mouse action is active) ---
        elif self.is_ctrl_pressed:
            try:  # Check location for hinting
                canvas_x = self.map_canvas.canvasx(
                    self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                )
                canvas_y = self.map_canvas.canvasy(
                    self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                )
                handle = (
                    self._get_handle_at(canvas_x, canvas_y)
                    if self.show_window_view.get()
                    else None
                )
                if handle:
                    new_cursor = "sizing"  # Hint resize
                elif (
                    self._is_inside_window_view(canvas_x, canvas_y)
                    and self.show_window_view.get()
                ):
                    new_cursor = "fleur"  # Hint window drag
                else:
                    new_cursor = "hand2"  # Hint panning
            except tk.TclError:
                new_cursor = "hand2"  # Default hint for Ctrl pressed
        elif self.is_shift_pressed:  # NEW: Shift held, no action -> hint selection
            new_cursor = "crosshair"
        # --- Default action (if no action and no relevant modifier) ---
        else:
            new_cursor = "pencil"  # Default paint cursor

        # Only change the cursor if it's different
        try:
            current_cursor = self.map_canvas.cget("cursor")
            if current_cursor != new_cursor:
                self.map_canvas.config(cursor=new_cursor)
        except tk.TclError:
            pass

    def handle_ctrl_press(self, event):
        """Handles Control key press."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state and cursor if Ctrl wasn't already considered pressed
            if not self.is_ctrl_pressed:
                self.is_ctrl_pressed = True
                # Update cursor only if no mouse action is currently happening
                # If a mouse button is down, let the existing action determine cursor
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_ctrl_release(self, event):
        """Handles Control key release. Stops panning if active."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state if Ctrl was actually considered pressed
            if self.is_ctrl_pressed:
                self.is_ctrl_pressed = False
                # If panning was the current action, stop it.
                # Window dragging/resizing continues until mouse release even if Ctrl comes up.
                if self.current_mouse_action == "panning":
                    self.current_mouse_action = None
                self._update_map_cursor()

    def handle_pan_start(self, event):
        """Handles the start of panning (Ctrl + Left Click) OR window dragging with Ctrl."""
        # --- Check for Shift modifier ---
        if self.is_shift_pressed:
            self.debug("[DEBUG]Shift pressed, ignoring Ctrl-Button-1 for pan/window drag.")
            return "break"
        # --- End Shift Check ---

        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if not ctrl_pressed_at_click or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # --- Clear previous selection when starting pan/window drag ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        if (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            self.current_mouse_action = "window_dragging"
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self._update_map_cursor()
        else:
            # Initiate PANNING
            self.current_mouse_action = "panning"
            canvas.scan_mark(event.x, event.y)
            self._update_map_cursor()

        return "break"

    def handle_pan_motion(self, event):
        """Handles mouse motion during panning OR window dragging with Ctrl."""
        if self.current_mouse_action not in ["panning", "window_dragging"]:
            return

        canvas = self.map_canvas

        if self.current_mouse_action == "panning":
            canvas.scan_dragto(event.x, event.y, gain=1)
            # After scan_dragto, the view has changed, so redraw the map content
            self.draw_map_canvas() # <<< ADDED THIS LINE
            self.draw_minimap()    # Minimap was already being updated

        elif self.current_mouse_action == "window_dragging":
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)
            self._do_window_move_drag(canvas_x, canvas_y) # This calls draw_map_canvas internally if needed

        return "break"

    def handle_canvas_enter(self, event):
        """Handles mouse entering the canvas area."""
        # Set cursor based on current state
        self._update_map_cursor()

        # --- >> ADDED: Draw paste preview on enter if applicable << ---
        if event.widget == self.map_canvas:
            is_map_tab_active = False
            if self.notebook and self.notebook.winfo_exists():
                try:
                     selected_tab_index = self.notebook.index(self.notebook.select())
                     if selected_tab_index == 3: # Map Editor tab index
                         is_map_tab_active = True
                except tk.TclError:
                    pass # Ignore if notebook not ready

            # Draw preview if map tab active and clipboard has data
            if is_map_tab_active and self.map_clipboard_data:
                self._draw_paste_preview_rect(event=event)

    def handle_canvas_leave(self, event):
        """Handles mouse leaving the canvas area."""
        # Reset cursor to default when leaving, unless an action is in progress
        if self.current_mouse_action is None:
            # Only reset if the specific widget leaving is the map canvas
            if event.widget == self.map_canvas:
                try:
                    if self.map_canvas.winfo_exists():
                        self.map_canvas.config(cursor="")
                except tk.TclError:
                    pass # Ignore if destroyed

        # Reset coordinate display when mouse leaves map canvas
        if event.widget == self.map_canvas and hasattr(self, "map_coords_label"):
            self.map_coords_label.config(text="ST Coords: -, -")

        # Clear paste preview when leaving map canvas
        if event.widget == self.map_canvas:
            self._clear_paste_preview_rect()

    def _update_edit_menu_state(self):
        if not self.edit_menu:
            self.debug("[DEBUG] _update_edit_menu_state: self.edit_menu is None. Aborting.")
            return
        if not tk.Menu.winfo_exists(self.edit_menu): # Check if menu widget still exists
            self.debug("[DEBUG] _update_edit_menu_state: self.edit_menu widget no longer exists. Aborting.")
            return

        self.debug(f"[DEBUG] _update_edit_menu_state: Attempting to update. Copy index: {self.copy_menu_item_index}, Paste index: {self.paste_menu_item_index}")

        if self.copy_menu_item_index == -1 or self.paste_menu_item_index == -1:
            self.debug("[DEBUG] _update_edit_menu_state: Stored menu item indices are -1. Aborting.")
            return

        # --- ADD MORE DEBUGGING HERE ---
        if self.debug_enabled: 
            try:
                actual_copy_type = self.edit_menu.type(self.copy_menu_item_index)
                actual_paste_type = self.edit_menu.type(self.paste_menu_item_index)
                self.debug(f"[DEBUG] _update_edit_menu_state: Actual type of item at copy_menu_item_index ({self.copy_menu_item_index}) is '{actual_copy_type}'")
                self.debug(f"[DEBUG] _update_edit_menu_state: Actual type of item at paste_menu_item_index ({self.paste_menu_item_index}) is '{actual_paste_type}'")

                num_items_now = self.edit_menu.index(tk.END) # This can be None if menu is empty
                if num_items_now is not None:
                    self.debug(f"[DEBUG] _update_edit_menu_state: Total items in edit_menu NOW: {num_items_now + 1}")
                    for i in range(num_items_now + 1):
                        item_type_str = self.edit_menu.type(i)
                        item_label_str = 'N/A'
                        if item_type_str == 'command':
                            item_label_str = self.edit_menu.entrycget(i, 'label')
                        elif item_type_str == 'cascade':
                             item_label_str = self.edit_menu.entrycget(i, 'label') + " (Cascade)"
                        # Add other types if necessary (checkbutton, radiobutton, separator)
                        self.debug(f"  [DEBUG] _update_edit_menu_state: Item {i}: Type='{item_type_str}', Label='{item_label_str}'")
                else:
                    self.debug("[DEBUG] _update_edit_menu_state: edit_menu.index(tk.END) is None (menu might be empty or not fully formed).")


            except tk.TclError as e_debug_update:
                self.debug(f"[DEBUG] _update_edit_menu_state: TclError during debug print: {e_debug_update}")
        # --- END MORE DEBUGGING ---

        selected_tab_index = 0 
        try:
            if self.notebook and self.notebook.winfo_exists():
                current_selection = self.notebook.select()
                if current_selection:
                    selected_tab_index = self.notebook.index(current_selection)
        except tk.TclError:
            selected_tab_index = 0 

        can_copy = False
        can_paste = False
        copy_label = "Copy"
        paste_label = "Paste"

        if selected_tab_index == 1: 
            copy_label = "Copy Tile"
            paste_label = "Paste Tile"
            can_copy = 0 <= current_tile_index < num_tiles_in_set
            can_paste = (
                tile_clipboard_pattern is not None
                and 0 <= current_tile_index < num_tiles_in_set
            )

        elif selected_tab_index == 2: 
            copy_label = "Copy Supertile"
            paste_label = "Paste Supertile"
            can_copy = 0 <= current_supertile_index < num_supertiles
            can_paste = (
                supertile_clipboard_data is not None
                and 0 <= current_supertile_index < num_supertiles
            )

        elif selected_tab_index == 3: 
            copy_label = "Copy Map Region"
            paste_label = "Paste Map Region"
            can_copy = (
                self.map_selection_start_st is not None
                and self.map_selection_end_st is not None
            )
            can_paste = self.map_clipboard_data is not None

        else: 
            self.debug(f"[DEBUG] _update_edit_menu_state: Tab index is {selected_tab_index}. Setting Copy/Paste disabled.")
            copy_label = "Copy"
            paste_label = "Paste"
            can_copy = False
            can_paste = False

        copy_state = tk.NORMAL if can_copy else tk.DISABLED
        paste_state = tk.NORMAL if can_paste else tk.DISABLED

        try:
            # Re-check types just before configuring, in case the debug prints above are misleading due to timing
            current_copy_type_final_check = self.edit_menu.type(self.copy_menu_item_index)
            current_paste_type_final_check = self.edit_menu.type(self.paste_menu_item_index)

            if current_copy_type_final_check == "command":
                self.edit_menu.entryconfig(
                    self.copy_menu_item_index, state=copy_state, label=copy_label
                )
            else:
                self.debug(f"[DEBUG] _update_edit_menu_state FINAL CHECK ERROR: Item at copy index {self.copy_menu_item_index} is type '{current_copy_type_final_check}', not 'command'.")


            if current_paste_type_final_check == "command":
                self.edit_menu.entryconfig(
                    self.paste_menu_item_index, state=paste_state, label=paste_label
                )
            else:
                self.debug(f"[DEBUG] _update_edit_menu_state FINAL CHECK ERROR: Item at paste index {self.paste_menu_item_index} is type '{current_paste_type_final_check}', not 'command'.")


        except tk.TclError as e:
            self.debug(f"[DEBUG] _update_edit_menu_state: TclError during entryconfig: {e}")
            pass
        except Exception as e:
            self.debug(f"[DEBUG] _update_edit_menu_state: UNEXPECTED ERROR during menu update: {e}")
            pass

    def handle_generic_copy(self):
        """Handles the generic 'Copy' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return # Cannot determine active tab

        # Clear map clipboard and preview ONLY if copy action is NOT for map region
        if active_tab_index != 3:
            # Check if map clipboard actually needs clearing before doing work
            if self.map_clipboard_data is not None:
                self.map_clipboard_data = None
                self._clear_paste_preview_rect()
                # Update menu state since map paste is now disabled
                self._update_edit_menu_state() # Update only if clipboard was cleared

        # Perform copy based on active tab
        if active_tab_index == 1:  # Tile Editor Tab
            self.copy_current_tile()
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.copy_current_supertile()
        elif active_tab_index == 3:  # Map Editor Tab
            norm_coords = self._get_normalized_selection_st()
            if norm_coords: # If a selection exists, perform the copy
                min_c, min_r, max_c, max_r = norm_coords
                sel_w = max_c - min_c + 1
                sel_h = max_r - min_r + 1
                copied_data = []
                for r_idx in range(min_r, max_r + 1):
                    row_data = []
                    for c_idx in range(min_c, max_c + 1):
                        if 0 <= r_idx < map_height and 0 <= c_idx < map_width:
                            row_data.append(map_data[r_idx][c_idx])
                        else:
                            row_data.append(0)  # Append default if outside map
                    copied_data.append(row_data)

                # Set the map clipboard
                self.map_clipboard_data = {
                    "width": sel_w,
                    "height": sel_h,
                    "data": copied_data,
                }
                # Clear selection visual/state after successful copy
                self._clear_map_selection()
                # Explicitly clear any old paste preview visual
                self._clear_paste_preview_rect()
                # Redraw map canvas to remove selection rectangle
                self.draw_map_canvas()
                # Update menu state (enables Paste)
                self._update_edit_menu_state()
                # Attempt to draw the *new* paste preview based on current mouse pos
                try:
                    pointer_x = self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                    pointer_y = self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                    if (0 <= pointer_x < self.map_canvas.winfo_width() and
                        0 <= pointer_y < self.map_canvas.winfo_height()):
                        canvas_x = self.map_canvas.canvasx(pointer_x)
                        canvas_y = self.map_canvas.canvasy(pointer_y)
                        self._draw_paste_preview_rect(canvas_coords=(canvas_x, canvas_y))
                except Exception:
                     pass # Ignore errors getting pointer position

            # else: # If no selection exists, simply do nothing for the map clipboard
            #    print("Copy Map Region: No selection active.") # Optional info message

    def handle_generic_paste(self):
        """Handles the generic 'Paste' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return 

        marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)

        if active_tab_index == 1:  # Tile Editor Tab
            self.paste_tile() 
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.paste_supertile() 
        elif active_tab_index == 3:  # Map Editor Tab 
            if self.map_clipboard_data:
                canvas = self.map_canvas
                try:
                    pointer_x = canvas.winfo_pointerx()
                    pointer_y = canvas.winfo_pointery()
                    root_x = canvas.winfo_rootx()
                    root_y = canvas.winfo_rooty()
                    canvas_x = canvas.canvasx(pointer_x - root_x)
                    canvas_y = canvas.canvasy(pointer_y - root_y)
                except tk.TclError:
                    messagebox.showerror("Paste Error", "Could not get mouse position for map paste.", parent=self.root)
                    if marks_were_cleared: self.update_all_displays(changed_level="all")
                    return

                paste_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)
                if paste_coords is None:
                    messagebox.showinfo("Paste Map Region", "Cannot paste here: Current mouse position is outside the map boundaries.", parent=self.root)
                    if marks_were_cleared: self.update_all_displays(changed_level="all")
                    return

                paste_st_col, paste_st_row = paste_coords
                clip_w = self.map_clipboard_data["width"]
                clip_h = self.map_clipboard_data["height"]
                clip_data = self.map_clipboard_data["data"]
                modified = False

                for r_offset in range(clip_h):
                    for c_offset in range(clip_w):
                        target_map_row = paste_st_row + r_offset
                        target_map_col = paste_st_col + c_offset

                        if (0 <= target_map_row < map_height and 0 <= target_map_col < map_width):
                            if r_offset < len(clip_data) and c_offset < len(clip_data[r_offset]):
                                st_index_to_paste = clip_data[r_offset][c_offset]
                                # Ensure pasted ST index is valid for current num_supertiles
                                if 0 <= st_index_to_paste < num_supertiles:
                                    if map_data[target_map_row][target_map_col] != st_index_to_paste:
                                        map_data[target_map_row][target_map_col] = st_index_to_paste
                                        modified = True
                                else:
                                    # Handle case where clipboard ST index is out of bounds
                                    # (e.g. paste from a project with more STs)
                                    # Option: Paste as ST 0, or skip this cell
                                    if map_data[target_map_row][target_map_col] != 0: # Default to ST 0
                                        map_data[target_map_row][target_map_col] = 0
                                        modified = True
                                    self.debug(f"Warning: ST index {st_index_to_paste} from clipboard out of bounds. Pasted ST 0 at map ({target_map_row},{target_map_col}).")


                if modified:
                    self._mark_project_modified()
                    self.invalidate_minimap_background_cache()
                    self.draw_map_canvas()  
                    self.draw_minimap()  
                    self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE
                else:
                    if not marks_were_cleared: # Only show if no other action (like mark clearing) happened
                         messagebox.showinfo("Paste Map Region", "No changes made to the map by paste operation (content might be identical or outside bounds).", parent=self.root)


            else: # No map_clipboard_data
                messagebox.showinfo("Paste Map Region", "Map clipboard is empty.", parent=self.root)
                if marks_were_cleared: self.update_all_displays(changed_level="all")

        if marks_were_cleared and not (active_tab_index == 1 or active_tab_index == 2 or (active_tab_index == 3 and modified)):
            # If marks were cleared but no specific paste action happened that would redraw,
            # ensure a redraw occurs.
            self.update_all_displays(changed_level="all")

    def _setup_global_key_bindings(self):
        """Sets up global keyboard shortcuts (accelerators) for menu commands."""
        self.root.bind_all("<Control-n>", lambda event: self.new_project())
        self.root.bind_all("<Control-o>", lambda event: self.open_project())
        self.root.bind_all("<Control-s>", lambda event: self.save_project())
        self.root.bind_all(
            "<Control-Shift-KeyPress-S>", lambda event: self.save_project_as()
        )
        # MODIFIED: Ctrl+Q should also go through confirm_quit
        self.root.bind_all("<Control-q>", lambda event: self.confirm_quit())

        self.root.bind_all("<Control-c>", lambda event: self.handle_generic_copy())
        self.root.bind_all("<Control-v>", lambda event: self.handle_generic_paste())
        self.root.bind_all("<Control-m>", lambda event: self.toggle_minimap())

        self.debug("[DEBUG] Global key bindings set up.")

    def handle_map_tab_keypress(self, event):
        """Handles key presses specifically bound when the Map Tab is active."""
        key = event.keysym.lower()

        if key == "g":  # MODIFIED CHECK
            # Only cycle color if the key is 'g' (this handler is only active on map tab)
            self.cycle_grid_color()
            return "break"  # Prevent any other default actions for 'g'

    def _place_tile_in_supertile(self, r_place, c_place): # Renamed r, c
        global supertiles_data, current_supertile_index, selected_tile_for_supertile # Globals
        
        if not (0 <= current_supertile_index < num_supertiles):
            return False
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return False
        
        # Check against current project's supertile dimensions
        if not (0 <= r_place < self.supertile_grid_height and 0 <= c_place < self.supertile_grid_width):
            return False

        # Ensure definition structure is consistent before trying to access/modify
        current_definition_place = supertiles_data[current_supertile_index]
        if not current_definition_place or len(current_definition_place) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition_place[0]) != self.supertile_grid_width)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dim mismatch in _place_tile_in_supertile.")
            return False


        if current_definition_place[r_place][c_place] != selected_tile_for_supertile:
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            # Modify the global supertiles_data directly
            supertiles_data[current_supertile_index][r_place][c_place] = selected_tile_for_supertile
            
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="supertile")
            else: # Marks were cleared
                self.update_all_displays(changed_level="all") # Ensure full redraw
            self._mark_project_modified()

            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

            return True
        else:
            return False

    def handle_supertile_def_drag(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile
        mini_tile_dsize = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_dsize <= 0 or not canvas.winfo_exists():
            return

        col_drag = event.x // mini_tile_dsize
        row_drag = event.y // mini_tile_dsize

        current_cell_drag = (row_drag, col_drag)

        # Check bounds against current project's supertile dimensions
        # The _place_tile_in_supertile will do the ultimate bounds check against self.sgw/sgh
        if (0 <= row_drag < self.supertile_grid_height and \
            0 <= col_drag < self.supertile_grid_width and \
            current_cell_drag != self.last_placed_supertile_cell):

            placed_drag = self._place_tile_in_supertile(row_drag, col_drag)

            if placed_drag:
                self.last_placed_supertile_cell = current_cell_drag

    def handle_supertile_def_release(self, event):
        """Resets the drag state when the mouse button is released over the supertile definition canvas."""
        self.last_placed_supertile_cell = None

    def _update_map_coords_display(self, event):
        """Updates the coordinate label based on mouse motion over the map canvas."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        canvas = self.map_canvas
        try:
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)

            # Calculate supertile size at current zoom USING PROJECT DIMENSIONS
            zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims() # <--- USE THIS

            if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0: # Check both
                if hasattr(self, "map_coords_label"):
                    self.map_coords_label.config(text="ST Coords: Error")
                return

            # Calculate supertile row/col
            st_col = int(canvas_x // zoomed_st_pixel_w) # Use width for col
            st_row = int(canvas_y // zoomed_st_pixel_h) # Use height for row

            if 0 <= st_row < map_height and 0 <= st_col < map_width:
                coords_text = f"ST Coords: {st_col}, {st_row}"
            else:
                coords_text = "ST Coords: Out"

            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text=coords_text)

        except Exception as e:
            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text="ST Coords: Error")

    def _mark_project_modified(self):
        """Sets the project modified flag to True and updates the window title if needed."""
        if not self.project_modified:
            self.project_modified = True
            self._update_window_title()  # Update title when first marked as modified

    def flip_supertile_horizontal(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Flip Supertile", "No valid supertile selected.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition = supertiles_data[current_supertile_index]
        
        if not (current_definition and 
                len(current_definition) == self.supertile_grid_height and
                (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(current_definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for horizontal flip. Cannot flip.")
            messagebox.showerror("Flip Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot flip.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return

        new_definition_flipped_h_st = []
        for r_flip_st_h in range(self.supertile_grid_height):
            # Row should exist due to check above, but defensive access
            if r_flip_st_h < len(current_definition) and isinstance(current_definition[r_flip_st_h], list):
                 new_definition_flipped_h_st.append(current_definition[r_flip_st_h][::-1]) 
            else: 
                 new_definition_flipped_h_st.append([0] * self.supertile_grid_width) # Pad with default if row malformed


        supertiles_data[current_supertile_index] = new_definition_flipped_h_st

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache() # Map appearance might change
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        # Flipping doesn't change which tiles are used, only their order.
        # So, TileUsage *counts* don't change. Previews for STs in ST Usage will change.
        # self._request_tile_usage_refresh() # Not strictly needed for counts
        self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE
        
        self.debug(f"Supertile {current_supertile_index} flipped horizontally.")

    def flip_supertile_vertical(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Flip Supertile", "No valid supertile selected.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_to_flip_st = supertiles_data[current_supertile_index]
        
        if not (current_definition_to_flip_st and 
                len(current_definition_to_flip_st) == self.supertile_grid_height and
                (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(current_definition_to_flip_st[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for vertical flip. Cannot flip.")
            messagebox.showerror("Flip Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot flip.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return
            
        current_definition_to_flip_st.reverse() # Reverses the list of rows in-place

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        self._request_supertile_usage_refresh()
        
        self.debug(f"Supertile {current_supertile_index} flipped vertically.")

    def rotate_supertile_90cw(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Rotate Supertile", "No valid supertile selected.", parent=self.root)
            return

        if self.supertile_grid_width != self.supertile_grid_height:
            messagebox.showinfo("Rotate Supertile", "Rotation is only enabled for square supertiles.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_rotate_st = supertiles_data[current_supertile_index]
        dim_st_rotate = self.supertile_grid_width # Since it's square
        
        if not (current_definition_rotate_st and 
                len(current_definition_rotate_st) == dim_st_rotate and
                (dim_st_rotate == 0 or all(len(row) == dim_st_rotate for row in current_definition_rotate_st))):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for rotation. Cannot rotate.")
            messagebox.showerror("Rotate Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot rotate.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return

        new_definition_rotated_st = [[0 for _c in range(dim_st_rotate)] for _r in range(dim_st_rotate)]

        for r_rot_st_val in range(dim_st_rotate):
            for c_rot_st_val in range(dim_st_rotate):
                # Check bounds just in case definition was malformed despite earlier check
                if r_rot_st_val < len(current_definition_rotate_st) and c_rot_st_val < len(current_definition_rotate_st[r_rot_st_val]):
                    new_definition_rotated_st[c_rot_st_val][(dim_st_rotate - 1) - r_rot_st_val] = current_definition_rotate_st[r_rot_st_val][c_rot_st_val]
                # Else, new_definition_rotated_st already has 0 for that cell

        supertiles_data[current_supertile_index] = new_definition_rotated_st

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        self._request_supertile_usage_refresh()
        
        self.debug(f"Supertile {current_supertile_index} rotated 90 CW.")

    def shift_supertile_up(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        
        current_st_h_for_shift = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_h_for_shift <= 0:
            # Also handle case where ST might be 1 unit high (no change)
            if current_st_h_for_shift <=1 and 0 <= current_supertile_index < num_supertiles :
                 self.debug(f"Supertile {current_supertile_index} is {current_st_h_for_shift} unit(s) high, cannot shift up.")
                 return # No action if 1 unit high or less
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_shift_st_up = supertiles_data[current_supertile_index]
        
        if not (current_definition_shift_st_up and 
                len(current_definition_shift_st_up) == current_st_h_for_shift and
                (current_st_h_for_shift == 0 or (self.supertile_grid_width > 0 and len(current_definition_shift_st_up[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift up. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return
            
        first_row_data_st = current_definition_shift_st_up[0][:] # Shallow copy of the row

        for r_shift_st_up_val in range(current_st_h_for_shift - 1):
            current_definition_shift_st_up[r_shift_st_up_val] = current_definition_shift_st_up[r_shift_st_up_val + 1]

        current_definition_shift_st_up[current_st_h_for_shift - 1] = first_row_data_st
        
        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        # self._request_tile_usage_refresh() # Tile usage counts don't change
        self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE
        
        self.debug(f"Supertile {current_supertile_index} shifted up.")

    def shift_supertile_down(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        
        current_st_h_for_shift_d = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_h_for_shift_d <= 0:
            if current_st_h_for_shift_d <=1 and 0 <= current_supertile_index < num_supertiles:
                self.debug(f"Supertile {current_supertile_index} is {current_st_h_for_shift_d} unit(s) high, cannot shift down.")
                return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_shift_st_d = supertiles_data[current_supertile_index]

        if not (current_definition_shift_st_d and 
                len(current_definition_shift_st_d) == current_st_h_for_shift_d and
                (current_st_h_for_shift_d == 0 or (self.supertile_grid_width > 0 and len(current_definition_shift_st_d[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift down. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return
            
        last_row_data_st = current_definition_shift_st_d[current_st_h_for_shift_d - 1][:] 

        for r_shift_st_d_val in range(current_st_h_for_shift_d - 1, 0, -1):
            current_definition_shift_st_d[r_shift_st_d_val] = current_definition_shift_st_d[r_shift_st_d_val - 1]

        current_definition_shift_st_d[0] = last_row_data_st

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        self._request_supertile_usage_refresh()
        
        self.debug(f"Supertile {current_supertile_index} shifted down.")

    def shift_supertile_left(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals
        
        current_st_w_for_shift_l = self.supertile_grid_width
        current_st_h_for_shift_l = self.supertile_grid_height # Needed for row iteration
        
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w_for_shift_l <= 0 or current_st_h_for_shift_l <= 0:
            if current_st_w_for_shift_l <=1 and 0 <= current_supertile_index < num_supertiles :
                 self.debug(f"Supertile {current_supertile_index} is {current_st_w_for_shift_l} unit(s) wide, cannot shift left.")
                 return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_shift_st_l = supertiles_data[current_supertile_index]

        if not (current_definition_shift_st_l and 
                len(current_definition_shift_st_l) == current_st_h_for_shift_l and
                (current_st_h_for_shift_l == 0 or (current_st_w_for_shift_l > 0 and len(current_definition_shift_st_l[0]) == current_st_w_for_shift_l) or current_st_w_for_shift_l == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift left. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return

        for r_shift_st_l_val in range(current_st_h_for_shift_l):
            if r_shift_st_l_val < len(current_definition_shift_st_l): # Check row existence
                row_data_list_st_l = current_definition_shift_st_l[r_shift_st_l_val]
                if len(row_data_list_st_l) == current_st_w_for_shift_l and current_st_w_for_shift_l > 0:
                    first_tile_in_row_st = row_data_list_st_l[0]
                    for c_shift_st_l_val in range(current_st_w_for_shift_l - 1):
                        row_data_list_st_l[c_shift_st_l_val] = row_data_list_st_l[c_shift_st_l_val + 1]
                    row_data_list_st_l[current_st_w_for_shift_l - 1] = first_tile_in_row_st

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        self._request_supertile_usage_refresh()
        
        self.debug(f"Supertile {current_supertile_index} shifted left.")

    def shift_supertile_right(self):
        global supertiles_data, current_supertile_index, num_supertiles # Using globals

        current_st_w_for_shift_r = self.supertile_grid_width
        current_st_h_for_shift_r = self.supertile_grid_height
        
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w_for_shift_r <= 0 or current_st_h_for_shift_r <= 0:
            if current_st_w_for_shift_r <= 1 and 0 <= current_supertile_index < num_supertiles :
                 self.debug(f"Supertile {current_supertile_index} is {current_st_w_for_shift_r} unit(s) wide, cannot shift right.")
                 return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        current_definition_shift_st_r = supertiles_data[current_supertile_index]

        if not (current_definition_shift_st_r and 
                len(current_definition_shift_st_r) == current_st_h_for_shift_r and
                (current_st_h_for_shift_r == 0 or (current_st_w_for_shift_r > 0 and len(current_definition_shift_st_r[0]) == current_st_w_for_shift_r) or current_st_w_for_shift_r == 0)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift right. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            if self.marked_unused_tiles or self.marked_unused_supertiles: self.update_all_displays(changed_level="all")
            return

        for r_shift_st_r_val in range(current_st_h_for_shift_r):
            if r_shift_st_r_val < len(current_definition_shift_st_r):
                row_data_list_st_r = current_definition_shift_st_r[r_shift_st_r_val]
                if len(row_data_list_st_r) == current_st_w_for_shift_r and current_st_w_for_shift_r > 0:
                    last_tile_in_row_st = row_data_list_st_r[current_st_w_for_shift_r - 1]
                    for c_shift_st_r_val in range(current_st_w_for_shift_r - 1, 0, -1):
                        row_data_list_st_r[c_shift_st_r_val] = row_data_list_st_r[c_shift_st_r_val - 1]
                    row_data_list_st_r[0] = last_tile_in_row_st
        
        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self.update_all_displays(changed_level="all")
        else:
            self.update_all_displays(changed_level="supertile")
            
        self._request_supertile_usage_refresh()
        
        self.debug(f"Supertile {current_supertile_index} shifted right.")

    def handle_supertile_def_right_click(self, event):
        global selected_tile_for_supertile, current_supertile_index, num_supertiles, num_tiles_in_set, supertiles_data

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile in editor
        mini_tile_disp_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_disp_size <= 0 or not canvas.winfo_exists():
            return

        col = event.x // mini_tile_disp_size
        row = event.y // mini_tile_disp_size

        # Check click against current project's supertile dimensions
        if (
            0 <= row < self.supertile_grid_height
            and 0 <= col < self.supertile_grid_width
            and 0 <= current_supertile_index < num_supertiles
        ):
            try:
                # Ensure definition structure matches before accessing
                definition_rc = supertiles_data[current_supertile_index]
                if not definition_rc or len(definition_rc) != self.supertile_grid_height or \
                   (self.supertile_grid_height > 0 and (len(definition_rc[0]) != self.supertile_grid_width)):
                    self.debug(f"[DEBUG]Warning: ST def {current_supertile_index} dim mismatch in right_click.")
                    return

                clicked_tile_index_val = definition_rc[row][col]

                if 0 <= clicked_tile_index_val < num_tiles_in_set:
                    if selected_tile_for_supertile != clicked_tile_index_val:
                        selected_tile_for_supertile = clicked_tile_index_val
                        self.debug(f"[DEBUG]Right-click selected Tile: {selected_tile_for_supertile}")
                        self.draw_tileset_viewer(
                            self.st_tileset_canvas, selected_tile_for_supertile
                        )
                        self.update_supertile_info_labels()
                        self.scroll_viewers_to_tile(selected_tile_for_supertile)
                # else:
                    self.debug(f"[DEBUG]Right-click: Tile index {clicked_tile_index_val} at ST def [{row},{col}] is out of tile bounds (max {num_tiles_in_set-1}).")

            except IndexError: # Should be caught by structure check above
                self.debug(f"[DEBUG]Right-click: IndexError accessing supertile data for ST {current_supertile_index} at def [{row},{col}].")
                pass
            except Exception as e:
                self.debug(f"[DEBUG]Right-click: Unexpected error in supertile def handler: {e}")
                pass
        # else: Click was outside the definition grid based on current W/H dimensions

    def handle_map_canvas_right_click(self, event):
        """Handles right-click on the map canvas to select the clicked supertile."""
        global selected_supertile_for_map, map_data, map_width, map_height, num_supertiles

        # Prevent interference with panning or other actions
        if self.current_mouse_action is not None:
            return "break"  # Stop event propagation if another action is active

        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        # Calculate zoomed supertile size
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return
        zoomed_supertile_size = SUPERTILE_GRID_DIM * zoomed_tile_size
        if zoomed_supertile_size <= 0:
            return

        # Get canvas coordinates (handles scrolling)
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Calculate map column and row in supertile units
        map_col = int(canvas_x // zoomed_supertile_size)
        map_row = int(canvas_y // zoomed_supertile_size)

        # Check if the click is within the map bounds
        if 0 <= map_row < map_height and 0 <= map_col < map_width:
            try:
                # Get the supertile index at the clicked map cell
                clicked_supertile_index = map_data[map_row][map_col]

                # Check if the retrieved supertile index is valid
                if 0 <= clicked_supertile_index < num_supertiles:
                    # Check if the selection actually changed
                    if selected_supertile_for_map != clicked_supertile_index:
                        selected_supertile_for_map = clicked_supertile_index
                        print(
                            f"Right-click selected Supertile: {selected_supertile_for_map}"
                        )
                        # Redraw the supertile selector in the map tab
                        self.draw_supertile_selector(
                            self.map_supertile_selector_canvas,
                            selected_supertile_for_map,
                        )
                        # Update the info label
                        self.update_map_info_labels()
                        # Scroll the selector to the selected supertile
                        self.scroll_selectors_to_supertile(selected_supertile_for_map)
                else:
                    print(
                        f"Right-click: Supertile index {clicked_supertile_index} at map [{map_row},{map_col}] is out of bounds (max {num_supertiles-1})."
                    )

            except IndexError:
                print(
                    f"Right-click: Error accessing map data at [{map_row},{map_col}]."
                )
            except Exception as e:
                print(f"Right-click: Unexpected error in map canvas handler: {e}")

    def _check_tile_usage(self, tile_index_check): # Renamed tile_index
        used_in_supertiles_list = [] # Renamed
        if not (0 <= tile_index_check < num_tiles_in_set):
            return used_in_supertiles_list

        for st_idx_check in range(num_supertiles):
            definition_check = supertiles_data[st_idx_check] # global
            
            # Check consistency of this definition with project settings
            if not definition_check or len(definition_check) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_check[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: Supertile {st_idx_check} has inconsistent dimensions in _check_tile_usage. Skipping.")
                continue # Skip this malformed supertile definition

            found_in_current_st = False
            for r_check in range(self.supertile_grid_height):
                for c_check in range(self.supertile_grid_width):
                    # Bounds check for r_check, c_check within definition_check already done by loops
                    # and the initial structure check.
                    if definition_check[r_check][c_check] == tile_index_check:
                        if st_idx_check not in used_in_supertiles_list:
                            used_in_supertiles_list.append(st_idx_check)
                        found_in_current_st = True
                        break 
                if found_in_current_st:
                    break 
        return used_in_supertiles_list

    def _check_supertile_usage(self, supertile_index):
        """Checks if a supertile_index is used in the map data.
        Returns a list of (row, col) map coordinates that use it.
        """
        used_in_map = []
        if not (0 <= supertile_index < num_supertiles):
            return used_in_map  # Invalid index

        for r in range(map_height):
            for c in range(map_width):
                if map_data[r][c] == supertile_index:
                    used_in_map.append((r, c))
        return used_in_map

    # --- NEW: Reference Update Helpers ---
    def _update_supertile_refs_for_tile_change(self, tile_idx_changed, action_type): # Renamed index, action
        references_changed = False # Flag to track if any ST def was actually modified
        for st_idx_update in range(num_supertiles):
            current_definition_update = supertiles_data[st_idx_update] 

            if not current_definition_update or len(current_definition_update) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(current_definition_update[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: Supertile {st_idx_update} has inconsistent dimensions in _update_supertile_refs. Skipping.")
                continue

            for r_update in range(self.supertile_grid_height):
                for c_update in range(self.supertile_grid_width):
                    current_tile_ref = current_definition_update[r_update][c_update]
                    original_ref_for_comparison = current_tile_ref # Store before modification
                    
                    if action_type == "insert":
                        if current_tile_ref >= tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] += 1
                    elif action_type == "delete":
                        if current_tile_ref == tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] = 0 
                        elif current_tile_ref > tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] -= 1
                    
                    if supertiles_data[st_idx_update][r_update][c_update] != original_ref_for_comparison:
                        references_changed = True
                        self.invalidate_supertile_cache(st_idx_update)

        if references_changed:
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

    def _update_map_refs_for_supertile_change(self, index, action):
        map_changed_by_refs = False 
        if action == "insert":
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] >= index:
                        # Ensure incremented index does not exceed MAX_SUPERTILES - 1
                        if map_data[r][c] < MAX_SUPERTILES - 1:
                            map_data[r][c] += 1
                            map_changed_by_refs = True
                        elif map_data[r][c] == MAX_SUPERTILES -1 and index <= MAX_SUPERTILES -1 :
                             # If current ref is already at max, and we insert before/at it,
                             # it effectively gets pushed "out of bounds" conceptually.
                             # For safety, could map to a default like 0, or log.
                             # Current logic: it would remain MAX_SUPERTILES-1 if index makes it shift.
                             # If index makes map_data[r][c] need to be > MAX_SUPERTILES-1, it's an issue.
                             # Let's assume for now that num_supertiles management prevents this.
                             # A safer increment:
                             # original_val = map_data[r][c]
                             # map_data[r][c] = min(MAX_SUPERTILES - 1, original_val + 1)
                             # if map_data[r][c] != original_val: map_changed_by_refs = True
                             pass # Current logic might be okay if MAX_SUPERTILES is large

        elif action == "delete":
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] == index:
                        map_data[r][c] = 0
                        map_changed_by_refs = True
                    elif map_data[r][c] > index:
                        map_data[r][c] -= 1
                        map_changed_by_refs = True # Also a change
        else:
            self.debug(f"Warning: Unknown action '{action}' in _update_map_refs_for_supertile_change")

        if map_changed_by_refs:
            self._mark_project_modified() # If map data changed, project is modified
            self.invalidate_minimap_background_cache() # Minimap needs update
            # The map canvas itself will be redrawn by the caller of insert/delete ST usually.
            self._request_supertile_usage_refresh() # MODIFIED: ADDED THIS LINE

    def _insert_tile(self, index):
        global num_tiles_in_set, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX

        if not (
            0 <= index <= num_tiles_in_set
        ):  
            print(
                f"Error: Insert tile index {index} out of range [0, {num_tiles_in_set}]."
            )
            return False
        if num_tiles_in_set >= MAX_TILES:
            print("Error: Cannot insert tile, maximum tiles reached.")
            return False

        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]

        tileset_patterns.insert(index, blank_pattern)
        tileset_colors.insert(index, blank_colors)
        
        if len(tileset_patterns) > MAX_TILES:
            tileset_patterns.pop()
        if len(tileset_colors) > MAX_TILES:
            tileset_colors.pop()

        self._update_supertile_refs_for_tile_change(index, "insert") # calls _request_tile_usage_refresh

        self._mark_project_modified()
        return True

    def _delete_tile(self, index):
        global num_tiles_in_set, tileset_patterns, tileset_colors

        if not (0 <= index < num_tiles_in_set):
            print(
                f"Error: Delete tile index {index} out of range [0, {num_tiles_in_set - 1}]."
            )
            return False
        if num_tiles_in_set <= 1:
            print("Error: Cannot delete the last tile.")
            return False

        del tileset_patterns[index]
        del tileset_colors[index]

        self._update_supertile_refs_for_tile_change(index, "delete") # calls _request_tile_usage_refresh

        self._mark_project_modified()
        return True

    def _insert_supertile(self, index_to_insert_at): 
        global num_supertiles, supertiles_data 

        if not (0 <= index_to_insert_at <= num_supertiles):
            self.debug(f"[DEBUG]Error: Insert supertile index {index_to_insert_at} out of range [0, {num_supertiles}].")
            return False
        if num_supertiles >= MAX_SUPERTILES:
            self.debug("[DEBUG]Error: Cannot insert supertile, maximum reached.")
            return False

        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]

        supertiles_data.insert(index_to_insert_at, blank_st_definition) 
        
        if len(supertiles_data) > MAX_SUPERTILES:
            supertiles_data.pop() 

        self._update_map_refs_for_supertile_change(index_to_insert_at, "insert")
        self._mark_project_modified()
        self._request_tile_usage_refresh()

        return True

    def _delete_supertile(self, index):
        """Core logic to delete the supertile at the specified index.

        Args:
            index (int): The index of the supertile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global num_supertiles, supertiles_data

        if not (0 <= index < num_supertiles):
            print(
                f"Error: Delete supertile index {index} out of range [0, {num_supertiles - 1}]."
            )
            return False
        if num_supertiles <= 1:
            print("Error: Cannot delete the last supertile.")
            # messagebox.showwarning("Cannot Delete", "Cannot delete the last remaining supertile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data list
        del supertiles_data[index]
        # Let list shrink

        # Update references in map
        self._update_map_refs_for_supertile_change(index, "delete")

        self._mark_project_modified()
        return True

    def _update_editor_button_states(self):
        global num_tiles_in_set, num_supertiles # Using globals

        # --- Tile Editor Buttons ---
        can_add_tile = num_tiles_in_set < MAX_TILES
        can_insert_tile = num_tiles_in_set < MAX_TILES # Same condition as adding for enabling insert
        can_delete_tile = num_tiles_in_set > 1

        if hasattr(self, "add_tile_button") and self.add_tile_button.winfo_exists():
            self.add_tile_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED
            )
        if hasattr(self, "add_many_tiles_button") and self.add_many_tiles_button.winfo_exists():
            self.add_many_tiles_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_tile_button") and self.insert_tile_button.winfo_exists():
            self.insert_tile_button.config(
                state=tk.NORMAL if can_insert_tile else tk.DISABLED
            )
        if hasattr(self, "delete_tile_button") and self.delete_tile_button.winfo_exists():
            self.delete_tile_button.config(
                state=tk.NORMAL if can_delete_tile else tk.DISABLED
            )

        can_add_supertile = num_supertiles < MAX_SUPERTILES 
        can_insert_supertile = num_supertiles < MAX_SUPERTILES # Same condition
        can_delete_supertile = num_supertiles > 1

        if hasattr(self, "add_supertile_button") and self.add_supertile_button.winfo_exists():
            self.add_supertile_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED
            )
        if hasattr(self, "add_many_supertiles_button") and self.add_many_supertiles_button.winfo_exists():
            self.add_many_supertiles_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_supertile_button") and self.insert_supertile_button.winfo_exists():
            self.insert_supertile_button.config(
                state=tk.NORMAL if can_insert_supertile else tk.DISABLED
            )
        if hasattr(self, "delete_supertile_button") and self.delete_supertile_button.winfo_exists():
            self.delete_supertile_button.config(
                state=tk.NORMAL if can_delete_supertile else tk.DISABLED
            )

    def handle_add_tile(self):  
        global num_tiles_in_set, current_tile_index
    
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        success = self._insert_tile(num_tiles_in_set)  

        if success:
            num_tiles_in_set += 1
            new_tile_idx = num_tiles_in_set - 1
            current_tile_index = new_tile_idx  

            self.clear_all_caches()  
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")  
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()  
            self._request_color_usage_refresh() # Correctly placed
            print(f"Added new tile {new_tile_idx}")
        else:
            messagebox.showwarning(
                "Add Tile Failed", f"Could not add tile. Maximum {MAX_TILES} reached?"
            )

    def handle_insert_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if self._clear_marked_unused(trigger_redraw=False):
            pass 

        insert_idx = current_tile_index
        success = self._insert_tile(insert_idx)

        if success:
            num_tiles_in_set += 1
            current_tile_index = insert_idx 

            if selected_tile_for_supertile >= insert_idx:
                selected_tile_for_supertile += 1
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh() # Added
            print(f"Inserted tile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Tile Failed",
                f"Could not insert tile. Maximum {MAX_TILES} reached?",
            )

    def handle_delete_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if num_tiles_in_set <= 1:
            messagebox.showinfo("Delete Tile", "Cannot delete the last tile.")
            return

        delete_idx = current_tile_index
        if not (0 <= delete_idx < num_tiles_in_set):
            messagebox.showerror("Delete Tile Error", "Invalid tile index selected.")
            return

        usage = self._check_tile_usage(delete_idx)
        confirm_msg = f"Delete Tile {delete_idx}?"
        if usage:
            confirm_msg += "\n\n*** WARNING! ***\nThis tile is used by the following Supertile(s):\n"
            confirm_msg += ", ".join(map(str, usage[:10]))  
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += (
                f"\n\nReferences in these Supertiles will be reset to Tile 0."
            )

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"):
            return

        self._adjust_marked_indices_after_delete(self.marked_unused_tiles, delete_idx)

        success = self._delete_tile(delete_idx) # Core logic does NOT clear marks

        if success:
            num_tiles_in_set -= 1
            # Adjust selection: stay at index if possible, else clamp to new max
            current_tile_index = min(delete_idx, num_tiles_in_set - 1)
            current_tile_index = max(0, current_tile_index) # Ensure not -1 if last tile deleted

            # Adjust other selections if they pointed to deleted or higher index
            if selected_tile_for_supertile == delete_idx:
                selected_tile_for_supertile = 0 # Default to 0 if deleted
            elif selected_tile_for_supertile > delete_idx:
                selected_tile_for_supertile -= 1
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)
            selected_tile_for_supertile = max(0, selected_tile_for_supertile)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # This will redraw with adjusted marks
            self.scroll_viewers_to_tile(current_tile_index)  
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            # self._mark_project_modified() is called within _delete_tile
            print(f"Deleted tile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Tile Failed", "An error occurred during tile deletion."
            )

    def handle_add_supertile(self):  
        global num_supertiles, current_supertile_index # Using globals

        if self._clear_marked_unused(trigger_redraw=False):
            # If marks were cleared, update_all_displays later will handle redraw
            pass

        success = self._insert_supertile(num_supertiles) # Insert at the end

        if success:
            num_supertiles += 1 # Update count *after* successful insertion
            new_st_idx = num_supertiles - 1
            current_supertile_index = new_st_idx  

            self.supertile_image_cache.clear()  
            self.invalidate_minimap_background_cache() # Map not directly changed, but ST count did
            
            self.update_all_displays(changed_level="all") 
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_supertile
            
            # Refresh usage windows as num_supertiles changed
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            
            self.debug(f"Added new supertile {new_st_idx}")
        else:
            messagebox.showwarning(
                "Add Supertile Failed",
                f"Could not add supertile. Maximum {MAX_SUPERTILES} reached?",
                parent=self.root
            )

    def handle_insert_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map # Using globals

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        insert_idx = current_supertile_index # Insert at current selection
        success = self._insert_supertile(insert_idx)

        if success:
            num_supertiles += 1 # Update count after successful insertion
            # current_supertile_index remains insert_idx, which is correct
            
            # Adjust selected_supertile_for_map if it was at or after the insert point
            if selected_supertile_for_map >= insert_idx:
                if selected_supertile_for_map < MAX_SUPERTILES -1: # Prevent overflow if already at max
                    selected_supertile_for_map += 1
            # Ensure it's clamped within new valid range
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles - 1 if num_supertiles > 0 else 0)


            self.supertile_image_cache.clear()
            self.invalidate_minimap_background_cache() # Map refs changed by _update_map_refs...
            self.update_all_displays(changed_level="all") 
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is in _insert_supertile
            
            # Refresh usage windows
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

            self.debug(f"Inserted supertile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Supertile Failed",
                f"Could not insert supertile. Maximum {MAX_SUPERTILES} reached or error.",
                parent=self.root
            )

    def handle_delete_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map # Using globals

        if num_supertiles <= 1:
            messagebox.showinfo("Delete Supertile", "Cannot delete the last supertile.", parent=self.root)
            return

        delete_idx = current_supertile_index
        if not (0 <= delete_idx < num_supertiles):
            messagebox.showerror("Delete Supertile Error", "Invalid supertile index selected.", parent=self.root)
            return

        usage = self._check_supertile_usage(delete_idx)
        confirm_msg = f"Delete Supertile {delete_idx}?"
        if usage:
            map_coords_str = ", ".join(
                [f"({r_idx},{c_idx})" for r_idx, c_idx in usage[:10]] 
            )  
            confirm_msg += (
                "\n\n*** WARNING! ***\nThis supertile is used on the Map at:\n"
            )
            confirm_msg += map_coords_str
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += f"\n\nReferences on the Map will be reset to Supertile 0."

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning", parent=self.root):
            return
        
        # Clear marks before data modification, but _delete_supertile itself doesn't redraw
        if self._clear_marked_unused(trigger_redraw=False):
            pass # Redraw will be handled by update_all_displays below

        self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, delete_idx)

        success = self._delete_supertile(delete_idx) # Core data deletion

        if success:
            num_supertiles -= 1 # Update count *after* successful deletion
            
            # Adjust current_supertile_index
            current_supertile_index = min(delete_idx, num_supertiles - 1 if num_supertiles > 0 else 0)
            current_supertile_index = max(0, current_supertile_index) 

            # Adjust selected_supertile_for_map
            if selected_supertile_for_map == delete_idx:
                selected_supertile_for_map = 0 # Default to 0 if deleted
            elif selected_supertile_for_map > delete_idx:
                selected_supertile_for_map -= 1
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles - 1 if num_supertiles > 0 else 0)
            selected_supertile_for_map = max(0, selected_supertile_for_map)


            self.supertile_image_cache.clear()
            self.map_render_cache.clear() # Map refs changed
            self.invalidate_minimap_background_cache() # Map refs changed
            
            self.update_all_displays(changed_level="all") 
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is in _delete_supertile
            
            # Refresh usage windows
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            
            self.debug(f"Deleted supertile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Supertile Failed",
                "An error occurred during supertile deletion.",
                parent=self.root
            )

    def _reposition_tile(self, source_index_tile, target_index_tile): # Renamed
        global num_tiles_in_set, tileset_patterns, tileset_colors # Globals
        global current_tile_index, selected_tile_for_supertile, supertiles_data # Globals

        if not (0 <= source_index_tile < num_tiles_in_set):
            self.debug(f"[DEBUG]Error: Invalid source index {source_index_tile} for tile move.")
            return False
        
        # Clamp target_index_tile to be within valid bounds for insertion [0, num_tiles_in_set]
        # If target_index_tile == num_tiles_in_set, it means move to the very end.
        clamped_target_index_tile = max(0, min(target_index_tile, num_tiles_in_set))

        if source_index_tile == clamped_target_index_tile or \
           (clamped_target_index_tile == num_tiles_in_set and source_index_tile == num_tiles_in_set -1) : # Moving last item to end
             if source_index_tile == clamped_target_index_tile -1 and clamped_target_index_tile == num_tiles_in_set : # Moving last to effectively be "at the end" which is its current pos + 1 for insert
                  pass 
             elif source_index_tile == clamped_target_index_tile :
                  return False # No move needed if source is already at target (and not the special end case)


        self.debug(f"[DEBUG]Repositioning Tile: From {source_index_tile} to {clamped_target_index_tile}")

        moved_pattern_data = tileset_patterns.pop(source_index_tile)
        moved_colors_data = tileset_colors.pop(source_index_tile)

        # Actual insertion index if target was after source (due to pop)
        actual_insert_idx = clamped_target_index_tile
        if clamped_target_index_tile > source_index_tile:
            actual_insert_idx -= 1
        actual_insert_idx = max(0, actual_insert_idx) # Ensure not negative after adjustment

        tileset_patterns.insert(actual_insert_idx, moved_pattern_data)
        tileset_colors.insert(actual_insert_idx, moved_colors_data)

        # Update Supertile References
        references_in_sts_changed = False # Track if any ST definition was modified
        for st_idx_refo in range(num_supertiles):
            definition_refo = supertiles_data[st_idx_refo] # global
            if not definition_refo or len(definition_refo) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_refo[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: ST {st_idx_refo} dim mismatch in _reposition_tile. Skipping ref update.")
                continue

            st_def_modified_this_iteration = False
            for r_refo in range(self.supertile_grid_height):
                for c_refo in range(self.supertile_grid_width):
                    current_ref_val = definition_refo[r_refo][c_refo]
                    new_ref_val = current_ref_val

                    if current_ref_val == source_index_tile:
                        new_ref_val = actual_insert_idx
                    elif source_index_tile < actual_insert_idx: # Moved DOWN (target > source logically, actual_insert_idx reflects this)
                        if source_index_tile < current_ref_val <= actual_insert_idx:
                             new_ref_val = current_ref_val - 1
                    elif source_index_tile > actual_insert_idx: # Moved UP (target < source logically)
                        if actual_insert_idx <= current_ref_val < source_index_tile:
                             new_ref_val = current_ref_val + 1
                    
                    if new_ref_val != current_ref_val:
                         supertiles_data[st_idx_refo][r_refo][c_refo] = new_ref_val # Update global
                         st_def_modified_this_iteration = True
            
            if st_def_modified_this_iteration:
                references_in_sts_changed = True
                self.invalidate_supertile_cache(st_idx_refo) # Invalidate ST cache if its definition changed

        # Update Selections
        if current_tile_index == source_index_tile:
            current_tile_index = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < current_tile_index <= actual_insert_idx:
            current_tile_index -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= current_tile_index < source_index_tile:
            current_tile_index += 1

        if selected_tile_for_supertile == source_index_tile:
            selected_tile_for_supertile = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < selected_tile_for_supertile <= actual_insert_idx:
            selected_tile_for_supertile -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= selected_tile_for_supertile < source_index_tile:
            selected_tile_for_supertile += 1

        current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
        selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

        self._mark_project_modified()
        self.clear_all_caches() # Could clear more selectively, but all is safer
        self.invalidate_minimap_background_cache()
        if references_in_sts_changed: # If ST definitions were altered by the remapping
            self._request_tile_usage_refresh()
        self.debug(f"[DEBUG]  Successfully moved Tile {source_index_tile} to {actual_insert_idx}")
        return True

    def _reposition_supertile(self, source_index_st, target_index_st): # Renamed
        global num_supertiles, supertiles_data, map_data, map_width, map_height # Globals
        global current_supertile_index, selected_supertile_for_map 

        if not (0 <= source_index_st < num_supertiles):
            self.debug(f"[DEBUG]Error: Invalid source index {source_index_st} for supertile move.")
            return False
        
        clamped_target_index_st = max(0, min(target_index_st, num_supertiles))

        if source_index_st == clamped_target_index_st or \
           (clamped_target_index_st == num_supertiles and source_index_st == num_supertiles -1) :
             if source_index_st == clamped_target_index_st -1 and clamped_target_index_st == num_supertiles :
                  pass
             elif source_index_st == clamped_target_index_st :
                  return False

        self.debug(f"[DEBUG]Repositioning Supertile: From {source_index_st} to {clamped_target_index_st}")

        moved_st_definition = supertiles_data.pop(source_index_st) # Global

        actual_insert_idx_st = clamped_target_index_st
        if clamped_target_index_st > source_index_st:
            actual_insert_idx_st -= 1
        actual_insert_idx_st = max(0, actual_insert_idx_st)

        supertiles_data.insert(actual_insert_idx_st, moved_st_definition) # Global

        # Update Map References
        map_references_changed = False # Track if map data was modified
        for r_map_refo in range(map_height):
            for c_map_refo in range(map_width):
                current_map_ref = map_data[r_map_refo][c_map_refo] # Global
                new_map_ref = current_map_ref

                if current_map_ref == source_index_st:
                    new_map_ref = actual_insert_idx_st
                elif source_index_st < actual_insert_idx_st: 
                    if source_index_st < current_map_ref <= actual_insert_idx_st:
                         new_map_ref = current_map_ref - 1
                elif source_index_st > actual_insert_idx_st: 
                    if actual_insert_idx_st <= current_map_ref < source_index_st:
                         new_map_ref = current_map_ref + 1
                
                if new_map_ref != current_map_ref:
                     map_data[r_map_refo][c_map_refo] = new_map_ref # Global
                     map_references_changed = True

        # Update Selections
        if current_supertile_index == source_index_st:
            current_supertile_index = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < current_supertile_index <= actual_insert_idx_st:
            current_supertile_index -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= current_supertile_index < source_index_st:
            current_supertile_index += 1

        if selected_supertile_for_map == source_index_st:
            selected_supertile_for_map = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < selected_supertile_for_map <= actual_insert_idx_st:
            selected_supertile_for_map -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= selected_supertile_for_map < source_index_st:
            selected_supertile_for_map += 1

        current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
        selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

        self._mark_project_modified()
        self.supertile_image_cache.clear() 
        self.map_render_cache.clear() # Map render cache also needs clearing as ST indices changed
        self.invalidate_minimap_background_cache()
        
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()

        self.debug(f"[DEBUG]  Successfully moved Supertile {source_index_st} to {actual_insert_idx_st}")
        return True

    def _get_index_from_canvas_coords(self, canvas, x_event, y_event, item_type_str):
        padding = 1
        items_across_calc = 0
        item_render_w = 0
        item_render_h = 0
        max_items_count = 0

        if not canvas.winfo_exists(): # Early exit if canvas is gone
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Canvas {canvas} does not exist.")
            return -1 

        if item_type_str == "tile":
            items_across_calc = NUM_TILES_ACROSS # Constant for tile viewers
            item_render_w = VIEWER_TILE_SIZE
            item_render_h = VIEWER_TILE_SIZE
            max_items_count = num_tiles_in_set
        elif item_type_str == "supertile":
            item_render_w = self.supertile_grid_width * TILE_WIDTH
            item_render_h = self.supertile_grid_height * TILE_HEIGHT
            max_items_count = num_supertiles

            if item_render_w <= 0 or item_render_h <= 0:
                self.debug(f"[DEBUG] _get_index_from_canvas_coords: Invalid item_render_w/h for supertile ({item_render_w}x{item_render_h}).")
                return -1

            actual_canvas_w = canvas.winfo_width()
            if actual_canvas_w <= 1: # Canvas not sized yet or too small
                self.debug(f"[DEBUG] _get_index_from_canvas_coords: actual_canvas_w ({actual_canvas_w}) too small for supertile.")
                return -1 

            # --- UNIFIED "FIT AS MANY AS POSSIBLE" LOGIC ---
            # This logic should now be identical to the one in draw_supertile_selector
            if item_render_w + (2 * padding) > actual_canvas_w : # Not even one fits with padding on both sides
                items_across_calc = 0 
                if item_render_w <= actual_canvas_w : # Fits if no padding considered for this check
                    items_across_calc = 1
                # else: it's wider than canvas, items_across_calc remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                if (item_render_w + padding) <= 0: # Avoid division by zero if item_render_w is huge negative (should not happen)
                    items_across_calc = 0
                else:
                    items_across_calc = (actual_canvas_w - padding) // (item_render_w + padding)
            
            items_across_calc = max(1, items_across_calc) # Ensure at least 1 item if possible
            self.debug(f"[DEBUG] _get_index_from_canvas_coords (supertile): CanvasW={actual_canvas_w}, ItemW={item_render_w}, Calculated items_across_calc={items_across_calc}")
            # --- END UNIFIED LOGIC ---

        else:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Error: Invalid item_type '{item_type_str}'")
            return -1

        if item_render_w <= 0 or item_render_h <= 0 or items_across_calc <= 0:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Error: Invalid calculated layout params for {item_type_str} (item_w={item_render_w}, item_h={item_render_h}, items_across={items_across_calc})")
            return -1

        try:
            canvas_content_x = canvas.canvasx(x_event)
            canvas_content_y = canvas.canvasy(y_event)
        except tk.TclError:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: TclError getting canvasx/y for {item_type_str}. Canvas likely not ready.")
            return -1 

        # Calculate total content dimensions based on dynamic layout
        num_logical_rows_calc = math.ceil(max_items_count / items_across_calc) if items_across_calc > 0 else 0
        # Use actual_canvas_w for total_content_w if items_across_calc is based on it,
        # or derive from items_across_calc if that's the definitive count.
        # The scrollregion width in draw_supertile_selector is based on its items_across.
        # So, use items_across_calc here for consistency with how scrollregion is set.
        total_content_w = (items_across_calc * item_render_w) + ((items_across_calc + 1) * padding)
        total_content_h = (num_logical_rows_calc * item_render_h) + ((num_logical_rows_calc + 1) * padding)
        
        # Check if click is within the logical content area defined by items_across_calc
        # This check becomes more important if items_across_calc differs from what might physically fit
        # if the canvas is wider than what items_across_calc would fill.
        # However, with the unified logic, items_across_calc should reflect the drawn layout.
        if not (canvas_content_x >= 0 and canvas_content_x < total_content_w and \
                canvas_content_y >= 0 and canvas_content_y < total_content_h):
            # If click is outside the calculated total content width/height based on items_across_calc,
            # it might be in empty space if the canvas is wider than this content.
            # Consider it "outside grid content area".
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Click ({canvas_content_x},{canvas_content_y}) outside content area ({total_content_w}x{total_content_h}).")
            return -2 

        col_calc = 0
        if (item_render_w + padding) > 0 : # Avoid division by zero
            col_calc = int(canvas_content_x // (item_render_w + padding))
        
        row_calc = 0
        if (item_render_h + padding) > 0 : # Avoid division by zero
            row_calc = int(canvas_content_y // (item_render_h + padding))
        
        col_calc = max(0, col_calc) 
        row_calc = max(0, row_calc)

        index_calc = row_calc * items_across_calc + col_calc

        if 0 <= index_calc < max_items_count:
            return index_calc
        else:
            # Clicked within the logical grid area but beyond the last *valid* item.
            # This can signify a drop target at the end of the list.
            # Or it could be a click in an empty cell if the grid is not full.
            # Return max_items_count (the count) to indicate this "end of list" target or empty area.
            # For drag-and-drop, targetting max_items_count usually means "append".
            # For a simple click, if index_calc >= max_items_count, it means no valid item was clicked.
            # The caller (e.g., handle_viewer_drag_release or a click handler) needs to interpret this.
            # A click should probably only react if 0 <= index_calc < max_items_count.
            # A drag-release might use max_items_count as a valid drop target.
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Calculated index {index_calc} is >= max_items_count {max_items_count}. Returning {max_items_count}.")
            return max_items_count

    def handle_viewer_drag_motion(self, event):
        if self.drag_start_index == -1 or self.drag_item_type is None or self.drag_canvas is None:
            return

        canvas_motion = event.widget 

        if not self.drag_active:
            dx = event.x - self.drag_press_x
            dy = event.y - self.drag_press_y
            distance_squared = dx*dx + dy*dy

            if distance_squared >= (DRAG_THRESHOLD_PIXELS * DRAG_THRESHOLD_PIXELS):
                self.drag_active = True
                
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if self.drag_item_type == "tile":
                        other_highlight_idx = -1
                        if self.drag_canvas == self.tileset_canvas:
                             other_highlight_idx = selected_tile_for_supertile
                        elif self.drag_canvas == self.st_tileset_canvas:
                             other_highlight_idx = current_tile_index
                        self.draw_tileset_viewer(self.drag_canvas, other_highlight_idx) # Pass original selection
                    elif self.drag_item_type == "supertile":
                        other_highlight_idx_st = -1
                        if self.drag_canvas == self.supertile_selector_canvas:
                            other_highlight_idx_st = selected_supertile_for_map
                        elif self.drag_canvas == self.map_supertile_selector_canvas:
                            other_highlight_idx_st = current_supertile_index
                        self.draw_supertile_selector(self.drag_canvas, other_highlight_idx_st) # Pass original selection
                try:
                    if canvas_motion.winfo_exists():
                        canvas_motion.config(cursor="hand2")
                except tk.TclError: pass
            else:
                return # Threshold not met
        
        if not self.drag_active: 
            return

        target_canvas_for_indicator = self.drag_canvas # Indicator drawn on original drag canvas
        if not target_canvas_for_indicator or not target_canvas_for_indicator.winfo_exists():
            self.drag_active = False; self.drag_item_type = None; self.drag_start_index = -1; self.drag_canvas = None
            if self.drag_indicator_id and canvas_motion.winfo_exists():
                try: canvas_motion.delete(self.drag_indicator_id)
                except tk.TclError: pass
            self.drag_indicator_id = None
            return

        target_idx_motion = self._get_index_from_canvas_coords(
            canvas_motion, event.x, event.y, self.drag_item_type
        )

        if self.drag_indicator_id:
            try: target_canvas_for_indicator.delete(self.drag_indicator_id)
            except tk.TclError: pass
            self.drag_indicator_id = None

        if target_idx_motion >= 0 and canvas_motion == target_canvas_for_indicator:
            padding_ind = 1
            item_w_ind, item_h_ind, items_across_ind, max_items_ind = 0,0,0,0

            if self.drag_item_type == "tile":
                item_w_ind = VIEWER_TILE_SIZE
                item_h_ind = VIEWER_TILE_SIZE
                items_across_ind = NUM_TILES_ACROSS
                max_items_ind = num_tiles_in_set
            elif self.drag_item_type == "supertile":
                item_w_ind = self.supertile_grid_width * TILE_WIDTH
                item_h_ind = self.supertile_grid_height * TILE_HEIGHT

                max_items_ind = num_supertiles
                
                target_layout_w_ind = 256
                actual_canvas_w_ind = target_canvas_for_indicator.winfo_width()
                effective_layout_w_ind = min(target_layout_w_ind, actual_canvas_w_ind)
                current_items_across_ind = 0
                for p_o_2_val_ind in [32, 16, 8, 4, 2, 1]:
                    if p_o_2_val_ind == 0: continue
                    req_w_ind = (p_o_2_val_ind * item_w_ind) + ((p_o_2_val_ind + 1) * padding_ind)
                    if req_w_ind <= effective_layout_w_ind:
                        current_items_across_ind = p_o_2_val_ind
                        break
                if current_items_across_ind == 0:
                    if item_w_ind + 2 * padding_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    elif item_w_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    else: current_items_across_ind = 1
                items_across_ind = max(1, current_items_across_ind)

            if item_w_ind > 0 and item_h_ind > 0 and items_across_ind > 0:
                indicator_pos_idx = min(target_idx_motion, max_items_ind) 
                
                row_ind, col_ind = divmod(indicator_pos_idx, items_across_ind)
                
                line_x_pos = (col_ind * (item_w_ind + padding_ind)) + (padding_ind / 2) 
                line_y1_pos = (row_ind * (item_h_ind + padding_ind)) + (padding_ind / 2)
                line_y2_pos = line_y1_pos + item_h_ind 

                self.drag_indicator_id = target_canvas_for_indicator.create_line(
                    line_x_pos, line_y1_pos, line_x_pos, line_y2_pos,
                    fill="yellow", width=3, tags="drop_indicator"
                )
        try:
            if canvas_motion.winfo_exists() and canvas_motion.cget("cursor") != "hand2":
                 canvas_motion.config(cursor="hand2")
        except tk.TclError: pass

    def handle_viewer_drag_release(self, event):
        """Handles mouse button release over viewer/selector canvases.
        Completes either a click selection or a drag-and-drop repositioning.
        """
        global current_tile_index, selected_tile_for_supertile  # Selections
        global current_supertile_index, selected_supertile_for_map  # Selections

        canvas = event.widget  # Canvas where release occurred
        was_dragging = self.drag_active  # Check drag state BEFORE resetting

        # --- Always clean up visual drag indicators first ---
        if self.drag_indicator_id:
            # Try deleting from original drag canvas first, then current canvas
            try:
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    self.drag_canvas.delete(self.drag_indicator_id)
                elif canvas.winfo_exists():  # Fallback to current canvas
                    canvas.delete(self.drag_indicator_id)
            except tk.TclError:
                pass  # Ignore if already gone
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists():
                canvas.config(cursor="")  # Reset cursor on the current canvas
        except tk.TclError:
            pass

        # --- Determine Item Type and Max Items based on Canvas ---
        item_type = None
        max_items = 0
        source_canvas_type = None  # Track where drag started for potential validation

        if canvas == self.tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "tile_editor_main"
        elif canvas == self.st_tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "supertile_editor_tile"
        elif canvas == self.supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "supertile_editor_main"
        elif canvas == self.map_supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "map_editor_palette"
        else:
            # Should not happen if bindings are correct
            print(f"Warning: Drag release on unknown canvas: {canvas}")
            # Reset drag state fully and exit
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            return

        # --- Get Index Under Cursor ---
        index_at_release = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, item_type
        )

        # --- Handle Release ---
        if not was_dragging:
            # --- Scenario 1: It was just a CLICK (no drag initiated or minimal movement) ---
            if 0 <= index_at_release < max_items:  # Ensure click was on a valid item
                if item_type == "tile":
                    if (
                        source_canvas_type == "tile_editor_main"
                    ):  # Main tile editor viewer
                        if current_tile_index != index_at_release:
                            current_tile_index = index_at_release
                            # This is a new tile selection, so update everything including usage counts
                            self.update_all_displays(changed_level="tile_select")
                            self.scroll_viewers_to_tile(current_tile_index)
                    elif (
                        source_canvas_type == "supertile_editor_tile"
                    ):  # Supertile's tile selector
                        if selected_tile_for_supertile != index_at_release:
                            selected_tile_for_supertile = index_at_release
                            self.update_all_displays(changed_level="supertile")
                            self.scroll_viewers_to_tile(selected_tile_for_supertile)
                elif item_type == "supertile":
                    if (
                        source_canvas_type == "supertile_editor_main"
                    ):  # Main supertile selector
                        if current_supertile_index != index_at_release:
                            current_supertile_index = index_at_release
                            self.update_all_displays(changed_level="supertile")
                            self.scroll_selectors_to_supertile(current_supertile_index)
                    elif (
                        source_canvas_type == "map_editor_palette"
                    ):  # Map's supertile selector
                        if selected_supertile_for_map != index_at_release:
                            selected_supertile_for_map = index_at_release
                            self.update_all_displays(changed_level="map")
                            self.scroll_selectors_to_supertile(selected_supertile_for_map)

        else:
            # --- Scenario 2: It was a DRAG RELEASE ---
            source_index = self.drag_start_index
            dragged_item_type = self.drag_item_type

            if dragged_item_type != item_type:
                print(f"Warning: Drag type mismatch. Started '{dragged_item_type}', dropped on '{item_type}'. Cancelling.")
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if dragged_item_type == "tile":
                        self.draw_tileset_viewer(self.drag_canvas, -1)
                    elif dragged_item_type == "supertile":
                        self.draw_supertile_selector(self.drag_canvas, -1)
            else:
                valid_drop_target = False
                final_target_index = -1

                if index_at_release == max_items:
                    final_target_index = max_items
                    valid_drop_target = True
                elif 0 <= index_at_release < max_items:
                    final_target_index = index_at_release
                    valid_drop_target = True

                if valid_drop_target and final_target_index != source_index:
                    success = False
                    if item_type == "tile":
                        success = self._reposition_tile(source_index, final_target_index)
                    elif item_type == "supertile":
                        success = self._reposition_supertile(source_index, final_target_index)

                    if success:
                        self.clear_all_caches()
                        self.invalidate_minimap_background_cache()
                        self.update_all_displays(changed_level="all")
                        if item_type == "tile":
                            self.scroll_viewers_to_tile(current_tile_index)
                        elif item_type == "supertile":
                            self.scroll_selectors_to_supertile(current_supertile_index)
                    else:
                        messagebox.showerror("Reposition Error", f"Failed to move {item_type} from {source_index} to {final_target_index}.")
                        self.update_all_displays(changed_level="all")
                else:
                    print(f"Drag cancelled or no move needed (target_index: {index_at_release}, source: {source_index}).")
                    if item_type == "tile":
                        self.update_all_displays(changed_level="tile_select")
                    elif item_type == "supertile":
                        self.update_all_displays(changed_level="supertile")

        # --- Final Reset of Drag State (regardless of click or drag) ---
        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_canvas = None

    def _set_pencil_cursor(self, event):
        """Sets the cursor to 'pencil' for the widget that received the event."""
        try:
            # Check if widget still exists before configuring
            if event.widget.winfo_exists():
                event.widget.config(cursor="pencil")
        except tk.TclError:
            pass  # Ignore if widget is destroyed during event handling

    def _reset_cursor(self, event):
        """Resets the cursor to default for the widget that received the event."""
        try:
            if event.widget.winfo_exists():
                # Don't reset map canvas blindly, let its own logic handle it on leave
                if event.widget != self.map_canvas:
                    event.widget.config(cursor="")
                # If it *is* the map canvas, its existing <Leave> handler will take care of it
        except tk.TclError:
            pass  # Ignore if widget is destroyed

    # --- New Handlers and Helpers for Map Selection ---

    def handle_shift_press(self, event):
        """Handles Shift key press."""
        if "Shift" in event.keysym:
            if not self.is_shift_pressed:
                self.is_shift_pressed = True
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_shift_release(self, event):
        """Handles Shift key release."""
        if "Shift" in event.keysym:
            if self.is_shift_pressed:
                self.is_shift_pressed = False
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def _get_supertile_coords_from_canvas(self, canvas_x_coord, canvas_y_coord): # Renamed params
        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims()

        if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0:
            return None # Cannot calculate if dimensions are invalid

        st_col_calc = int(canvas_x_coord // zoomed_st_pixel_w)
        st_row_calc = int(canvas_y_coord // zoomed_st_pixel_h)

        if 0 <= st_row_calc < map_height and 0 <= st_col_calc < map_width:
            return (st_col_calc, st_row_calc)
        else:
            return None

    def _get_normalized_selection_st(self):
        """Returns normalized selection bounds (min_c, min_r, max_c, max_r) or None."""
        if self.map_selection_start_st is None or self.map_selection_end_st is None:
            return None

        start_c, start_r = self.map_selection_start_st
        end_c, end_r = self.map_selection_end_st

        min_c = min(start_c, end_c)
        min_r = min(start_r, end_r)
        max_c = max(start_c, end_c)
        max_r = max(start_r, end_r)

        return (min_c, min_r, max_c, max_r)

    def _draw_selection_rectangle(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        if self.map_selection_rect_id:
            try:
                canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass # Item might already be gone
            self.map_selection_rect_id = None

        norm_coords_sel = self._get_normalized_selection_st()
        if norm_coords_sel is None:
            return

        min_c_sel, min_r_sel, max_c_sel, max_r_sel = norm_coords_sel

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_sel, zoomed_st_pixel_h_sel = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_sel <= 0 or zoomed_st_pixel_h_sel <= 0:
            return

        px1_sel = min_c_sel * zoomed_st_pixel_w_sel
        py1_sel = min_r_sel * zoomed_st_pixel_h_sel
        px2_sel = (max_c_sel + 1) * zoomed_st_pixel_w_sel # +1 because coords are inclusive
        py2_sel = (max_r_sel + 1) * zoomed_st_pixel_h_sel

        try:
            self.map_selection_rect_id = canvas.create_rectangle(
                px1_sel, py1_sel, px2_sel, py2_sel,
                outline="yellow",
                dash=(4, 4),
                width=2,
                tags=("selection_rect",)
            )
            # Ensure it's drawn below other interactive elements
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_selection_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                canvas.tag_lower(self.map_selection_rect_id, "supertile_grid")
        except tk.TclError:
            self.map_selection_rect_id = None # Failed to create

    def _clear_map_selection(self):
        """Clears ONLY the map selection visual and related state variables."""
        canvas = self.map_canvas
        # Clear the visual rectangle
        if self.map_selection_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass
            self.map_selection_rect_id = None

        # Check if state needs updating before resetting (for menu update trigger)
        needs_menu_update = self.map_selection_start_st is not None

        # Reset selection state variables
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_selection_active = False # Ensure selection drag state is reset

        # Update menu if selection was active
        if needs_menu_update:
            self._update_edit_menu_state()
        # Do not redraw map here, let the caller handle redraw if needed
        # Do not clear paste preview or clipboard here

    def handle_map_selection_start(self, event):
        """Handles Shift + Button-1 press to start map selection."""
        if self.is_ctrl_pressed or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        self._clear_map_selection()

        start_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if start_coords:
            self.map_selection_start_st = start_coords
            self.map_selection_end_st = start_coords
            self.map_selection_active = True
            self._draw_selection_rectangle()
            self._update_map_cursor()
        else:
            self.map_selection_start_st = None
            self.map_selection_end_st = None
            self.map_selection_active = False

        return "break"

    def handle_map_selection_motion(self, event):
        """Handles Shift + B1 motion to update selection rectangle."""
        if not self.map_selection_active:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        current_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if current_coords:
            if self.map_selection_end_st != current_coords:
                self.map_selection_end_st = current_coords
                self._draw_selection_rectangle()
        # else: # Keep last valid end_st when mouse is outside

        return "break"

    def handle_map_selection_release(self, event):
        """Handles Shift + Button-1 release to finalize map selection."""
        if not self.map_selection_active:
            self._clear_map_selection()
            return

        self.map_selection_active = False

        if (
            self.map_selection_start_st is not None
            and self.map_selection_end_st is not None
        ):
            self.debug(f"[DEBUG]Selection finalized: {self.map_selection_start_st} to {self.map_selection_end_st}")
            # Final rectangle drawn by motion handler, redraw map to make it persistent
            self.draw_map_canvas()
            self._update_edit_menu_state()
        else:
            self._clear_map_selection()

        self._update_map_cursor()

        return "break"

    def handle_map_escape(self, event):
        """Handles Escape key press on map canvas to clear clipboard, paste preview, and selection."""
        self.debug("[DEBUG]Escape pressed, clearing clipboard, paste preview, and selection.")

        # Check what was active before clearing
        cleared_clipboard = self.map_clipboard_data is not None
        cleared_preview = self.map_paste_preview_rect_id is not None
        cleared_selection = self.map_selection_start_st is not None

        # Always attempt to clear clipboard, preview, and selection state
        self.map_clipboard_data = None
        self._clear_paste_preview_rect()
        self._clear_map_selection() # This now only clears selection visuals/state

        # Update menu state if the clipboard was cleared
        if cleared_clipboard:
            self._update_edit_menu_state()

        # Redraw map if the selection rectangle was visible to ensure it's removed
        # Clearing the paste preview doesn't require a full map redraw
        if cleared_selection and self.map_canvas.winfo_exists():
             self.draw_map_canvas()

        return "break" # Prevent other Escape bindings

    def _update_map_cursor_and_coords(self, event):
        """Combined handler for Motion to update both cursor and coords, and manage paste preview."""
        # Update coordinate display first
        self._update_map_coords_display(event)

        # Update cursor based on current state (e.g., pan, select, paint)
        self._update_map_cursor()

        # --- Paste Preview Logic ---
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                 selected_tab_index = self.notebook.index(self.notebook.select())
                 if selected_tab_index == 3: # Map Editor tab index
                     is_map_tab_active = True
            except tk.TclError:
                pass # Ignore if notebook not ready

        # Conditions to show paste preview: Map tab active AND map clipboard has data
        if is_map_tab_active and self.map_clipboard_data:
            self._draw_paste_preview_rect(event=event)
        else:
            # Clear preview if conditions are not met (e.g., wrong tab, no clipboard data)
            # This handles cases where clipboard is cleared while mouse is over canvas
            self._clear_paste_preview_rect()

    # --- New Paste Preview Methods ---
    def _draw_paste_preview_rect(self, event=None, canvas_coords=None):
        canvas = self.map_canvas
        if not canvas.winfo_exists() or not self.map_clipboard_data or not self.notebook:
            self._clear_paste_preview_rect()
            return
        try:
            if self.notebook.index(self.notebook.select()) != 3: # Map Editor tab index
                 self._clear_paste_preview_rect()
                 return
        except tk.TclError:
            self._clear_paste_preview_rect()
            return

        current_canvas_x_paste, current_canvas_y_paste = -1, -1
        if canvas_coords:
            current_canvas_x_paste, current_canvas_y_paste = canvas_coords
        elif event:
            try:
                current_canvas_x_paste = canvas.canvasx(event.x)
                current_canvas_y_paste = canvas.canvasy(event.y)
            except tk.TclError:
                self._clear_paste_preview_rect()
                return
        else:
             self._clear_paste_preview_rect()
             return

        paste_st_coords_preview = self._get_supertile_coords_from_canvas(current_canvas_x_paste, current_canvas_y_paste)

        if paste_st_coords_preview is None:
            self._clear_paste_preview_rect()
            return

        paste_st_col_preview, paste_st_row_preview = paste_st_coords_preview
        clip_w_preview = self.map_clipboard_data.get('width', 0)
        clip_h_preview = self.map_clipboard_data.get('height', 0)

        if clip_w_preview <= 0 or clip_h_preview <= 0:
            self._clear_paste_preview_rect()
            return

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_preview, zoomed_st_pixel_h_preview = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_preview <= 0 or zoomed_st_pixel_h_preview <= 0:
             self._clear_paste_preview_rect()
             return

        px1_preview = paste_st_col_preview * zoomed_st_pixel_w_preview
        py1_preview = paste_st_row_preview * zoomed_st_pixel_h_preview
        px2_preview = px1_preview + (clip_w_preview * zoomed_st_pixel_w_preview)
        py2_preview = py1_preview + (clip_h_preview * zoomed_st_pixel_h_preview)

        fill_color_preview = "#0000FF"
        stipple_pattern_preview = "gray50"

        if self.map_paste_preview_rect_id:
            try:
                canvas.coords(self.map_paste_preview_rect_id, px1_preview, py1_preview, px2_preview, py2_preview)
                canvas.itemconfig(self.map_paste_preview_rect_id, state=tk.NORMAL, fill=fill_color_preview, stipple=stipple_pattern_preview)
            except tk.TclError:
                self.map_paste_preview_rect_id = None
        
        if not self.map_paste_preview_rect_id:
            try:
                self.map_paste_preview_rect_id = canvas.create_rectangle(
                    px1_preview, py1_preview, px2_preview, py2_preview,
                    fill=fill_color_preview,
                    stipple=stipple_pattern_preview,
                    outline="", 
                    width=0,
                    tags=("paste_preview_rect",)
                )
            except tk.TclError:
                 self.map_paste_preview_rect_id = None
                 return

        try:
            if self.map_selection_rect_id:
                 canvas.tag_lower(self.map_paste_preview_rect_id, self.map_selection_rect_id)
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_paste_preview_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                 canvas.tag_lower(self.map_paste_preview_rect_id, "supertile_grid")
        except tk.TclError:
            pass


    def _clear_paste_preview_rect(self):
        """Safely deletes the paste preview rectangle from the canvas."""
        canvas = self.map_canvas
        if self.map_paste_preview_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_paste_preview_rect_id)
            except tk.TclError:
                pass # Ignore error if item already deleted or canvas gone
            finally:
                 # Ensure ID is cleared even if deletion fails
                 self.map_paste_preview_rect_id = None

    def show_about_box(self):
        """Displays the About information box with the application icon."""
        # Create a Toplevel window
        about_win = tk.Toplevel(self.root)
        about_win.title("About MSX Tile Forge")
        about_win.resizable(False, False) 
        about_win.transient(self.root) 
        about_win.grab_set() 

        # Main frame for content
        main_frame = ttk.Frame(about_win, padding="15")
        main_frame.pack(expand=True, fill="both")

        icon_label = None
        # Try to get the icon reference stored during startup on the root window
        app_icon_photo = getattr(self.root, 'app_icon_ref', None) # This should now find it

        if app_icon_photo:
            icon_label = ttk.Label(main_frame, image=app_icon_photo)
            # Keep reference for the label within this Toplevel
            icon_label.image = app_icon_photo 
            icon_label.grid(row=0, column=0, padx=(0, 15), pady=(0, 10), sticky="nw")

        # Text information frame
        text_frame = ttk.Frame(main_frame)
        text_frame.grid(row=0, column=1, sticky="nsew")

        # Program Name (Bold)
        style = ttk.Style()
        style.configure("About.TLabel", font=("-size", 10, "bold")) # Adjusted font size slightly
        name_label = ttk.Label(text_frame, text="MSX Tile Forge", style="About.TLabel")
        name_label.pack(anchor="w", pady=(0, 5))

        # Version and Author
        info_text = f"Version: {APP_VERSION}\nAuthor: Damned Angel + Gemini AI"
        info_label = ttk.Label(text_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(anchor="w")

        # OK Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2 if icon_label else 1, pady=(15, 0))

        ok_button = ttk.Button(button_frame, text="OK", command=about_win.destroy, width=10)
        ok_button.pack()

        about_win.update_idletasks() 
        main_width = self.root.winfo_width()
        main_height = self.root.winfo_height()
        main_x = self.root.winfo_x()
        main_y = self.root.winfo_y()

        pop_width = about_win.winfo_width()
        pop_height = about_win.winfo_height()

        pop_x = main_x + (main_width // 2) - (pop_width // 2)
        pop_y = main_y + (main_height // 2) - (pop_height // 2)

        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        pop_x = max(0, min(pop_x, screen_width - pop_width))
        pop_y = max(0, min(pop_y, screen_height - pop_height))

        about_win.geometry(f"+{pop_x}+{pop_y}")
        ok_button.focus_set()
        about_win.wait_window()

    def _find_unused_tiles(self):
        """Identifies tiles not used in any supertile definition."""
        global tileset_patterns, supertiles_data, num_tiles_in_set, num_supertiles
        used_tile_indices = set()
        # Tile 0 is implicitly used/reserved, don't mark it as unused
        for st_idx in range(num_supertiles):
            for r in range(SUPERTILE_GRID_DIM):
                for c in range(SUPERTILE_GRID_DIM):
                    used_tile_indices.add(supertiles_data[st_idx][r][c])
        
        unused_tiles = set()
        for i in range(1, num_tiles_in_set): # Start from 1, tile 0 is never "unused"
            if i not in used_tile_indices:
                unused_tiles.add(i)
        return unused_tiles

    def _find_unused_supertiles(self):
        """Identifies supertiles not used in the map_data."""
        global map_data, map_width, map_height, num_supertiles
        used_st_indices = set()
        # Supertile 0 is implicitly used/reserved
        for r_idx in range(map_height): # Renamed r
            for c_idx in range(map_width): # Renamed c
                used_st_indices.add(map_data[r_idx][c_idx])
        # self.debug(f"[DEBUG]DEBUG: Used Supertile Indices from map_data: {used_st_indices}") # DEBUG

        unused_supertiles = set()
        for i in range(1, num_supertiles): # Start from 1
            if i not in used_st_indices:
                unused_supertiles.add(i)
        self.debug(f"[DEBUG]DEBUG: Found Unused Supertiles (indices): {unused_supertiles}") # DEBUG
        return unused_supertiles

    def _clear_marked_unused(self, trigger_redraw=True):
        """Clears all 'marked unused' states and optionally redraws relevant viewers."""
        tile_marks_cleared = bool(self.marked_unused_tiles)
        st_marks_cleared = bool(self.marked_unused_supertiles)

        self.marked_unused_tiles.clear()
        self.marked_unused_supertiles.clear()

        if trigger_redraw and (tile_marks_cleared or st_marks_cleared):
            # Redraw only if marks were actually cleared to avoid unnecessary redraws
            # Determine active tab to redraw correctly
            current_tab_index = -1
            try:
                if self.notebook and self.notebook.winfo_exists():
                    selected_tab_name = self.notebook.select()
                    if selected_tab_name:
                        current_tab_index = self.notebook.index(selected_tab_name)
            except tk.TclError:
                pass

            if current_tab_index == 1: # Tile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
            elif current_tab_index == 2: # Supertile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                if st_marks_cleared:
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
            elif current_tab_index == 3: # Map Editor
                if st_marks_cleared: # Map editor only shows supertiles
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        return tile_marks_cleared or st_marks_cleared


    def _adjust_marked_indices_after_delete(self, marked_set, deleted_index):
        """Adjusts indices in a 'marked_set' after an item at 'deleted_index' is removed."""
        if deleted_index in marked_set:
            marked_set.remove(deleted_index)
        
        new_marked_set = set()
        for idx in marked_set:
            if idx > deleted_index:
                new_marked_set.add(idx - 1)
            else:
                new_marked_set.add(idx)
        marked_set.clear()
        marked_set.update(new_marked_set)


    def handle_mark_unused_tiles(self):
        """Handles the 'Mark Unused' button click in the Tile Editor tab."""
        if self.marked_unused_tiles: # If already marked, clear them
            self._clear_marked_unused(trigger_redraw=False) 
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index) 
        else:
            # Clear any supertile marks from other tab before marking tiles
            # This ensures only tile marks are active if this button is pressed
            if self.marked_unused_supertiles:
                self.marked_unused_supertiles.clear()
                 # Redraw ST selectors if they were marked to remove blue borders
                if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

            self.marked_unused_tiles = self._find_unused_tiles()
            if not self.marked_unused_tiles:
                messagebox.showinfo("Mark Unused Tiles", "No unused tiles found.")
            else:
                print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)

    def handle_mark_unused_supertiles_and_tiles(self):
        """Handles the 'Mark Unused' button in the Supertile Editor tab."""
        # If either set has marks, clear both
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self._clear_marked_unused(trigger_redraw=False) 
            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        else: # Neither set has marks, so we are in "mark" mode
            self.marked_unused_tiles = self._find_unused_tiles()
            self.marked_unused_supertiles = self._find_unused_supertiles() 
            
            if not self.marked_unused_tiles and not self.marked_unused_supertiles:
                messagebox.showinfo("Mark Unused", "No unused tiles or supertiles found.")
            else:
                # Only print the sets if they contain items
                if self.marked_unused_tiles: 
                    print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list for consistency
                if self.marked_unused_supertiles: 
                    print(f"Marked unused supertiles: {sorted(list(self.marked_unused_supertiles))}") # Print sorted list

            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)

    # --- ROM Importer Methods (NEW SECTION) ---

    def open_rom_importer(self):
        """Handles the 'Import Tiles from ROM...' menu command."""
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        rom_filepath = filedialog.askopenfilename(
            title="Select ROM File",
            filetypes=[("All files", "*.*"), ("Binary files", "*.bin"), ("ROM files", "*.rom")]
        )
        if not rom_filepath:
            return # User cancelled

        try:
            with open(rom_filepath, "rb") as f:
                rom_data = f.read()
            if not rom_data:
                messagebox.showerror("ROM Import Error", "Selected file is empty.")
                return
        except Exception as e:
            messagebox.showerror("ROM Import Error", f"Could not read ROM file:\n{e}")
            return

        # If successful, create and show the dialog
        self._create_rom_importer_dialog(rom_filepath, rom_data)

    def _create_rom_importer_dialog(self, rom_filepath, rom_data):
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        self.rom_import_dialog = tk.Toplevel(self.root)
        dialog = self.rom_import_dialog
        dialog.title(f"ROM Tile Importer - {os.path.basename(rom_filepath)}")
        dialog.transient(self.root)
        dialog.grab_set()

        dialog.rom_data = rom_data
        dialog.rom_filepath = rom_filepath
        dialog.fine_offset_var = tk.IntVar(value=0)
        dialog.rom_importer_selection = {}
        dialog.rom_importer_anchor_idx = -1
        dialog.current_importer_fg_idx = WHITE_IDX
        dialog.current_importer_bg_idx = BLACK_IDX
        dialog.hover_info_text_var = tk.StringVar(value="Offset: N/A | Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")
        dialog.top_left_grid_byte_offset_text_var = tk.StringVar(value="Grid Top-Left Byte: N/A")
        dialog.redraw_timer_id = None
        dialog.slider_redraw_timer_id = None
        dialog.rom_importer_grid_cols = 1

        dialog.pil_rom_viewport_image = None 
        dialog.tk_rom_photoimage = None      

        try:
            safe_tile_w = max(1, TILE_WIDTH)
            safe_tile_h = max(1, TILE_HEIGHT)
            dialog.temp_tile_image_unscaled_ref = tk.PhotoImage(width=safe_tile_w, height=safe_tile_h)
        except tk.TclError as e_photo:
            self.debug(f"[DEBUG] CRITICAL: Failed to create temp_tile_image_unscaled_ref: {e_photo}")
            messagebox.showerror("Importer Init Error", "Failed to initialize image resources for importer.", parent=dialog)
            if tk.Toplevel.winfo_exists(dialog):
                dialog.destroy()
            return

        main_dialog_frame = ttk.Frame(dialog, padding=5)
        main_dialog_frame.pack(expand=True, fill="both")
        main_dialog_frame.grid_columnconfigure(0, weight=0)
        main_dialog_frame.grid_columnconfigure(1, weight=1)
        main_dialog_frame.grid_rowconfigure(0, weight=1)
        main_dialog_frame.grid_rowconfigure(1, weight=0)

        left_column_frame = ttk.Frame(main_dialog_frame)
        left_column_frame.grid(row=0, column=0, sticky="nswe", padx=(0, 10))

        preview_label_frame = ttk.LabelFrame(left_column_frame, text="Live Preview")
        preview_label_frame.pack(side=tk.TOP, pady=(0, 10), anchor="n", fill=tk.X)
        preview_canvas_size = TILE_WIDTH * EDITOR_PIXEL_SIZE
        dialog.preview_canvas = tk.Canvas(
            preview_label_frame,
            width=max(1, preview_canvas_size),
            height=max(1, preview_canvas_size),
            bg="grey",
            highlightthickness=0
        )
        dialog.preview_canvas.pack(padx=5, pady=5, anchor="center")

        offset_control_frame = ttk.Frame(left_column_frame)
        offset_control_frame.pack(side=tk.TOP, pady=(0,10), fill=tk.X)
        ttk.Label(offset_control_frame, text="Fine Offset (0-7 bytes):").pack(side=tk.TOP, anchor="w")
        offset_slide_frame = ttk.Frame(offset_control_frame)
        offset_slide_frame.pack(side=tk.TOP, fill=tk.X, expand=True, padx=9)
        offset_slider = ttk.Scale(
            offset_slide_frame, from_=0, to=7, orient=tk.HORIZONTAL,
            variable=dialog.fine_offset_var, command=self._on_fine_offset_slider_change
        )
        offset_slider.pack(side=tk.TOP, fill=tk.X, expand=True)
        offset_tick_frame = ttk.Frame(offset_control_frame)
        offset_tick_frame.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(2,0))
        for i in range(8):
            offset_tick_frame.grid_columnconfigure(i, weight=1)
            lbl = ttk.Label(offset_tick_frame, text=str(i), font=("TkSmallCaptionFont", 7))
            lbl.grid(row=0, column=i)

        importer_color_frame = ttk.LabelFrame(left_column_frame, text="Preview/Import Colors")
        importer_color_frame.pack(side=tk.TOP, pady=(10,5), fill=tk.X)

        fg_color_subframe = ttk.Frame(importer_color_frame)
        fg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(fg_color_subframe, text="FG (1-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_fg_swatch = tk.Label(fg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_fg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_fg_swatch.bind("<Button-1>",
            lambda e, swatch_type='fg': self._pick_importer_color(swatch_type))

        bg_color_subframe = ttk.Frame(importer_color_frame)
        bg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(bg_color_subframe, text="BG (0-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_bg_swatch = tk.Label(bg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_bg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_bg_swatch.bind("<Button-1>",
            lambda e, swatch_type='bg': self._pick_importer_color(swatch_type))

        info_bar_frame = ttk.Frame(left_column_frame, padding=3)
        info_bar_frame.pack(side=tk.TOP, fill=tk.X, expand=False, pady=(5,5))
        dialog.status_bar_top_left_label = ttk.Label(info_bar_frame, textvariable=dialog.top_left_grid_byte_offset_text_var, anchor="w", justify=tk.LEFT)
        dialog.status_bar_top_left_label.pack(side=tk.TOP, fill=tk.X)
        hover_label = ttk.Label(info_bar_frame, textvariable=dialog.hover_info_text_var, anchor="w", justify=tk.LEFT)
        hover_label.pack(side=tk.TOP, fill=tk.X)
        selection_label = ttk.Label(info_bar_frame, textvariable=dialog.selection_info_text_var, anchor="w", justify=tk.LEFT)
        selection_label.pack(side=tk.TOP, fill=tk.X)

        canvas_frame = ttk.Frame(main_dialog_frame)
        canvas_frame.grid(row=0, column=1, sticky="nswe")
        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)

        rom_v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        rom_h_scroll = ttk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL)

        dialog.canvas = tk.Canvas(
            canvas_frame,
            bg="darkgrey",
            yscrollcommand=rom_v_scroll.set,
            xscrollcommand=rom_h_scroll.set,
            highlightthickness=0
        )

        def _schedule_debounced_draw_from_scroll_rom():
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

            if current_dialog.redraw_timer_id is not None:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

        def yview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.yview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        def xview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.xview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        rom_v_scroll.config(command=yview_wrapper_debounced_rom)
        rom_h_scroll.config(command=xview_wrapper_debounced_rom)

        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        rom_v_scroll.grid(row=0, column=1, sticky="ns")
        rom_h_scroll.grid(row=1, column=0, sticky="ew")

        buttons_frame = ttk.Frame(main_dialog_frame)
        buttons_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10,0))
        buttons_frame.grid_columnconfigure(0, weight=1)
        buttons_frame.grid_columnconfigure(1, weight=0)
        buttons_frame.grid_columnconfigure(2, weight=0)
        buttons_frame.grid_columnconfigure(3, weight=1)

        dialog.import_button = ttk.Button(
            buttons_frame, text="Import", command=self._execute_rom_tile_import, state=tk.DISABLED
        )
        cancel_button = ttk.Button(
            buttons_frame, text="Cancel", command=self._close_rom_importer_dialog
        )
        dialog.import_button.grid(row=0, column=1, padx=(0,5))
        cancel_button.grid(row=0, column=2, padx=(5,0))

        dialog.canvas.bind("<Configure>", lambda e: self._on_rom_importer_setting_change(configure_event=True))
        dialog.canvas.bind("<Motion>", self._on_rom_canvas_motion)
        dialog.canvas.bind("<Leave>", self._on_rom_canvas_leave)
        dialog.canvas.bind("<Button-1>", self._on_rom_canvas_left_click)
        dialog.canvas.bind("<Button-3>", self._on_rom_canvas_right_click)
        dialog.bind("<Escape>", lambda e: self._clear_rom_import_selection()) 
        dialog.canvas.bind("<FocusIn>", lambda e: None) 
        dialog.canvas.bind("<Key>", self._on_rom_canvas_keypress)
        dialog.canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-4>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-5>", self._on_mousewheel_scroll)
        dialog.canvas.focus_set()
        dialog.protocol("WM_DELETE_WINDOW", self._close_rom_importer_dialog)

        self._update_importer_color_swatches()
        dialog.after(50, lambda: self._on_rom_importer_setting_change(configure_event=True))

        dialog.update_idletasks()
        root_w = self.root.winfo_width()
        root_h = self.root.winfo_height()
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        dialog.update_idletasks() 
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = root_x + (root_w // 2) - (dialog_w // 2)
        y_pos = root_y + (root_h // 2) - (dialog_h // 2)
        
        screen_width_dialog = dialog.winfo_screenwidth()
        screen_height_dialog = dialog.winfo_screenheight()
        x_pos = max(0, min(x_pos, screen_width_dialog - dialog_w))
        y_pos = max(0, min(y_pos, screen_height_dialog - dialog_h))

        dialog.geometry(f"{dialog_w}x{dialog_h}+{x_pos}+{y_pos}")
        dialog.lift()

    def _close_rom_importer_dialog(self):
        """Closes and cleans up the ROM importer dialog."""
        if self.rom_import_dialog:
            self.rom_import_dialog.grab_release() # Release grab before destroying
            self.rom_import_dialog.destroy()
            self.rom_import_dialog = None # Clear reference

    def _on_rom_importer_setting_change(self, event=None, configure_event=False):
        # Called when fine_offset slider changes or canvas is configured/resized.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        if configure_event:
            self.debug("[DEBUG] _on_rom_importer_setting_change: Configure event triggered.")
            
            if not hasattr(dialog, 'redraw_timer_id'): # Ensure attribute exists
                dialog.redraw_timer_id = None

            if dialog.redraw_timer_id is not None:
                dialog.after_cancel(dialog.redraw_timer_id)
            # _perform_debounced_rom_canvas_draw handles clearing its own timer ID
            dialog.redraw_timer_id = dialog.after(150, self._perform_debounced_rom_canvas_draw) # Standard debounce for configure
            return 
        # else:
            # Non-configure events (e.g., direct calls if any, or slider)
            # Slider changes are handled by _on_fine_offset_slider_change which has its own debounce.
            # If this function were to be called directly for an immediate update by something else,
            # then that calling code would be responsible for the context.
            self.debug("[DEBUG] _on_rom_importer_setting_change: Non-configure event. No action taken here directly.")
            pass

    def _draw_rom_importer_canvas(self):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        self.debug(f"\n[DEBUG] ### _draw_rom_importer_canvas ### Pillow Viewport Strategy")

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[D] Canvas gone.")
            return

        rom_data = dialog.rom_data
        global_fine_offset_for_grid = dialog.fine_offset_var.get()
        current_fg_render_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        current_bg_render_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        selection_dict = getattr(dialog, 'rom_importer_selection', {})

        # Canvas viewport dimensions
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 1 or canvas_viewport_height <= 1:
            self.debug("[D] Canvas too small for Pillow viewport.")
            # Optionally clear canvas or draw a placeholder if needed
            try:
                if canvas.winfo_exists():
                    canvas.delete("all_rom_content")
                    canvas.config(scrollregion=(0,0,1,1))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            return

        # Delete old main image content (if any)
        try:
            if canvas.winfo_exists(): canvas.delete("rom_content_image")
        except tk.TclError: self.debug("[D] TclError deleting old rom_content_image."); # Continue if possible

        # Display parameters for items in the grid
        tile_display_size = VIEWER_TILE_SIZE # How big each 8x8 ROM tile appears on canvas
        padding = 1

        # Determine number of grid columns based on current canvas width
        current_draw_grid_cols = max(1, canvas_viewport_width // (tile_display_size + padding))
        dialog.rom_importer_grid_cols = current_draw_grid_cols # Store for other functions

        # Calculate total potential tiles from ROM data
        total_potential_tiles = 0
        if len(rom_data) > global_fine_offset_for_grid:
            total_potential_tiles = (len(rom_data) - global_fine_offset_for_grid) // TILE_WIDTH

        if total_potential_tiles <= 0:
            # Handle empty ROM data or offset beyond data length
            try:
                if canvas.winfo_exists():
                    canvas.config(scrollregion=(0,0,1,1))
                    # Create/clear the Pillow viewport even if empty
                    if dialog.pil_rom_viewport_image is None or \
                       dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
                       dialog.pil_rom_viewport_image.height != canvas_viewport_height:
                        dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                    else:
                        dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height))
                    
                    dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
                    view_content_x1_empty, view_content_y1_empty = 0,0 
                    try:
                        view_content_x1_empty = canvas.canvasx(0)
                        view_content_y1_empty = canvas.canvasy(0)
                    except tk.TclError: pass
                    canvas.create_image(view_content_x1_empty, view_content_y1_empty, image=dialog.tk_rom_photoimage, anchor=tk.NW, tags=("rom_content_image", "all_rom_content"))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            self.debug("[DEBUG] ### _draw_rom_importer_canvas END (no potential tiles) ###")
            return

        # Calculate scrollregion based on total content
        num_total_content_rows = math.ceil(total_potential_tiles / current_draw_grid_cols) if current_draw_grid_cols > 0 else 0
        scroll_region_width = current_draw_grid_cols * (tile_display_size + padding) + padding
        scroll_region_height = num_total_content_rows * (tile_display_size + padding) + padding
        scroll_region_width = max(1.0, float(scroll_region_width))
        scroll_region_height = max(1.0, float(scroll_region_height))
        
        current_scroll_region_str = ""
        try:
            sr_val = canvas.cget("scrollregion")
            current_scroll_region_str = " ".join(map(str, sr_val)) if isinstance(sr_val, tuple) else str(sr_val)
        except tk.TclError: pass
        new_scroll_region_str = f"0 0 {scroll_region_width} {scroll_region_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                if canvas.winfo_exists(): canvas.config(scrollregion=(0, 0, scroll_region_width, scroll_region_height))
            except tk.TclError: self.debug("[D] TclError setting scrollregion."); return

        # Get current viewport's top-left content coordinates
        view_content_x1 = canvas.canvasx(0)
        view_content_y1 = canvas.canvasy(0)

        # Update top-left grid byte offset label
        # (This logic remains similar, calculating based on visible grid start)
        start_grid_row_idx_for_label = max(0, int(view_content_y1 // (tile_display_size + padding)))
        start_grid_col_idx_for_label = max(0, int(view_content_x1 // (tile_display_size + padding)))
        actual_first_visible_tile_idx_in_data = (start_grid_row_idx_for_label * current_draw_grid_cols) + start_grid_col_idx_for_label
        if not hasattr(dialog, 'top_left_grid_byte_offset'): dialog.top_left_grid_byte_offset = 0
        dialog.top_left_grid_byte_offset = global_fine_offset_for_grid + (actual_first_visible_tile_idx_in_data * TILE_WIDTH)
        if hasattr(dialog, 'top_left_grid_byte_offset_text_var'):
            try:
                dialog.top_left_grid_byte_offset_text_var.set(f"Grid Top-Left Byte: {dialog.top_left_grid_byte_offset} (0x{dialog.top_left_grid_byte_offset:X})")
            except tk.TclError: pass

        # Create/Resize Pillow viewport image buffer
        if dialog.pil_rom_viewport_image is None or \
           dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
           dialog.pil_rom_viewport_image.height != canvas_viewport_height:
            try:
                dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                self.debug(f"[D] Created/Resized dialog.pil_rom_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except (ValueError, tk.TclError) as e_pil_new:
                self.debug(f"[D] Error creating pil_rom_viewport_image: {e_pil_new}"); return
        else:
            # Fill existing image with background color
            try:
                dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill:
                self.debug(f"[D] Error filling pil_rom_viewport_image: {e_fill}. Filling with darkgrey.")
                dialog.pil_rom_viewport_image.paste("darkgrey", (0,0,canvas_viewport_width,canvas_viewport_height) )

        # Determine visible grid range
        start_grid_row_idx = max(0, int(view_content_y1 // (tile_display_size + padding)))
        end_grid_row_idx = min(num_total_content_rows, int(math.ceil((view_content_y1 + canvas_viewport_height) / (tile_display_size + padding))))
        
        start_grid_col_idx = max(0, int(view_content_x1 // (tile_display_size + padding)))
        end_grid_col_idx = min(current_draw_grid_cols, int(math.ceil((view_content_x1 + canvas_viewport_width) / (tile_display_size + padding))))
        
        self.debug(f"[D] Visible Grid - Rows: {start_grid_row_idx}-{end_grid_row_idx-1}, Cols: {start_grid_col_idx}-{end_grid_col_idx-1}")

        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))
        # Scale factor for resizing 8x8 to tile_display_size
        # Pillow's resize requires positive dimensions.
        scaled_tile_w_for_pil = max(1, tile_display_size)
        scaled_tile_h_for_pil = max(1, tile_display_size)

        for r_grid in range(start_grid_row_idx, end_grid_row_idx):
            for c_grid in range(start_grid_col_idx, end_grid_col_idx):
                current_rom_tile_absolute_idx = r_grid * current_draw_grid_cols + c_grid
                if current_rom_tile_absolute_idx >= total_potential_tiles:
                    continue

                # Determine FG/BG colors and fine offset for this specific tile
                tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = -1, -1, -1
                if current_rom_tile_absolute_idx in selection_dict:
                    stored_props = selection_dict[current_rom_tile_absolute_idx]
                    tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = stored_props[0], stored_props[1], stored_props[2]
                else:
                    tile_fg_idx = current_fg_render_idx
                    tile_bg_idx = current_bg_render_idx
                    fine_offset_for_this_tile_render = global_fine_offset_for_grid # Use global if not selected

                safe_tile_fg_idx = tile_fg_idx if 0 <= tile_fg_idx < len(self.active_msx_palette) else WHITE_IDX
                safe_tile_bg_idx = tile_bg_idx if 0 <= tile_bg_idx < len(self.active_msx_palette) else BLACK_IDX
                color_for_fg_pixel = self.active_msx_palette[safe_tile_fg_idx]
                color_for_bg_pixel = self.active_msx_palette[safe_tile_bg_idx]

                # Calculate byte start position using the determined fine offset for this tile
                rom_byte_start_pos = fine_offset_for_this_tile_render + (current_rom_tile_absolute_idx * TILE_WIDTH)

                if not (0 <= rom_byte_start_pos < len(rom_data)):
                    self.debug(f"[D] Tile {current_rom_tile_absolute_idx} calculated offset {rom_byte_start_pos} out of bounds. Skipping.")
                    continue
                
                bytes_to_read = TILE_HEIGHT # Assuming TILE_WIDTH is bytes per tile, TILE_HEIGHT is rows
                if rom_byte_start_pos + bytes_to_read > len(rom_data):
                    num_bytes_avail = len(rom_data) - rom_byte_start_pos
                    tile_bytes_data = rom_data[rom_byte_start_pos:] + bytes(bytes_to_read - num_bytes_avail) # Pad if short
                else:
                    tile_bytes_data = rom_data[rom_byte_start_pos : rom_byte_start_pos + bytes_to_read]

                # Render the 8x8 tile onto pil_temp_base_tile
                pixel_data_for_base_tile = []
                for y_pixel_in_base in range(TILE_HEIGHT):
                    if y_pixel_in_base >= len(tile_bytes_data): break # Should not happen with padding
                    row_byte = tile_bytes_data[y_pixel_in_base]
                    for x_pixel_in_base in range(TILE_WIDTH):
                        pixel_val = (row_byte >> (7 - x_pixel_in_base)) & 1
                        hex_color_to_use = color_for_fg_pixel if pixel_val == 1 else color_for_bg_pixel
                        try:
                            r_int = int(hex_color_to_use[1:3], 16)
                            g_int = int(hex_color_to_use[3:5], 16)
                            b_int = int(hex_color_to_use[5:7], 16)
                            pixel_data_for_base_tile.append((r_int, g_int, b_int))
                        except ValueError:
                            pixel_data_for_base_tile.append((255,0,255)) # Magenta for error

                if len(pixel_data_for_base_tile) == TILE_WIDTH * TILE_HEIGHT:
                    pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                    # Scale the 8x8 temporary image
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (scaled_tile_w_for_pil, scaled_tile_h_for_pil),
                        Image.Resampling.NEAREST
                    )

                    # Calculate paste position on the pil_rom_viewport_image
                    # This is the tile's top-left on the viewport image, relative to (0,0) of the viewport image
                    paste_x_on_viewport_img = round((c_grid * (tile_display_size + padding) + padding) - view_content_x1)
                    paste_y_on_viewport_img = round((r_grid * (tile_display_size + padding) + padding) - view_content_y1)
                    
                    dialog.pil_rom_viewport_image.paste(pil_scaled_base_tile, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                else:
                    self.debug(f"[D] Incorrect pixel data length for tile {current_rom_tile_absolute_idx}. Skipping paste.")


        # Convert Pillow viewport image to Tk PhotoImage and display
        try:
            dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
        except Exception as e_photoimg:
            self.debug(f"[D] Error converting PIL to Tk PhotoImage for ROM importer: {e_photoimg}"); return

        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1,
                                    image=dialog.tk_rom_photoimage,
                                    anchor=tk.NW,
                                    tags=("rom_content_image", "all_rom_content"))
        except tk.TclError as e_create_img:
            self.debug(f"[D] TclError creating canvas image for ROM importer: {e_create_img}")

        # Redraw selection highlights on top
        self._draw_rom_import_selection_highlight(grid_cols_for_this_draw=current_draw_grid_cols)
        self._update_rom_importer_info_labels()

        if canvas.winfo_exists():
            canvas.update_idletasks() # Ensure image is drawn before method returns

        self.debug("[DEBUG] ### _draw_rom_importer_canvas END ### Pillow Viewport Strategy")

    def _draw_rom_import_selection_highlight(self, grid_cols_for_this_draw=None):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[DEBUG] Highlight: Canvas widget no longer exists. Aborting.")
            return

        try:
            canvas.delete("rom_selection_border")
        except tk.TclError:
            self.debug("[DEBUG] Highlight: TclError deleting 'rom_selection_border'. Ignoring.")

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            self.debug("[DEBUG] Highlight: No selection in selection_dict. Nothing to highlight.")
            return 
        
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        current_grid_cols = 0
        if grid_cols_for_this_draw is not None and grid_cols_for_this_draw > 0:
            current_grid_cols = grid_cols_for_this_draw
        else:
            current_grid_cols = getattr(dialog, 'rom_importer_grid_cols', 1)
            if current_grid_cols <= 0: 
                canvas_width_current = 0
                try:
                    if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
                except tk.TclError: self.debug("[DEBUG] Highlight: TclError getting canvas_width for fallback."); return
                if canvas_width_current <= 1 : self.debug("[DEBUG] Highlight: canvas_width too small for fallback."); return
                current_grid_cols = max(1, canvas_width_current // (tile_display_size + padding))
            self.debug(f"[DEBUG] Highlight: Using fallback/dialog grid_cols: {current_grid_cols}")
        
        if current_grid_cols <= 0:
            self.debug("[DEBUG] Highlight: current_grid_cols is zero or negative. Cannot draw highlights.")
            return

        main_image_items = canvas.find_withtag("rom_content_image")
        
        for selected_tile_idx in selection_dict.keys():
            if not isinstance(selected_tile_idx, int) or selected_tile_idx < 0:
                continue

            grid_r_content, grid_c_content = divmod(selected_tile_idx, current_grid_cols)

            tile_box_content_x1 = grid_c_content * (tile_display_size + padding) + padding
            tile_box_content_y1 = grid_r_content * (tile_display_size + padding) + padding
            tile_box_content_x2 = tile_box_content_x1 + tile_display_size
            tile_box_content_y2 = tile_box_content_y1 + tile_display_size
            
            try:
                if canvas.winfo_exists():
                    rect_id = canvas.create_rectangle(
                        tile_box_content_x1, tile_box_content_y1, 
                        tile_box_content_x2, tile_box_content_y2,
                        outline="yellow", width=1, 
                        tags=("rom_selection_border", "all_rom_content") 
                    )
                    if main_image_items:
                        canvas.tag_raise(rect_id, main_image_items[0]) 
            except tk.TclError as e_rect:
                self.debug(f"[DEBUG] Highlight: TclError creating rectangle for Idx {selected_tile_idx}: {e_rect}")
                break 
        
        self.debug("[DEBUG] --- _draw_rom_import_selection_highlight END ---")

    def _on_rom_canvas_motion(self, event):
        """Handles mouse motion over the ROM importer canvas for hover info and preview."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists(): return

        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        canvas_width_current = 0
        try:
            if canvas.winfo_exists():
                canvas_width_current = canvas.winfo_width()
        except tk.TclError: return

        if canvas_width_current <= 1: return
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        
        clicked_grid_col = int(cx // (tile_display_size + padding)) # Renamed for clarity, though not a click
        clicked_grid_row = int(cy // (tile_display_size + padding))
        hovered_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col
        
        total_potential_tiles = 0
        if len(rom_data) > fine_offset:
            total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        
        # Make sure hovered_rom_tile_absolute_idx is valid before proceeding
        is_valid_hover_idx = (0 <= hovered_rom_tile_absolute_idx < total_potential_tiles)

        if is_valid_hover_idx:
            hovered_byte_start_pos = fine_offset + (hovered_rom_tile_absolute_idx * TILE_WIDTH)
            
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set(
                        f"Offset: {hovered_byte_start_pos} (0x{hovered_byte_start_pos:X}) | Grid Index: {hovered_rom_tile_absolute_idx}"
                    )
                except tk.TclError: pass # Dialog might be closing
            # Pass hovered_rom_tile_absolute_idx to the preview function
            self._draw_rom_tile_preview(hovered_byte_start_pos, hovered_rom_tile_absolute_idx)
        else:
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
                except tk.TclError: pass
            
            preview_canvas = getattr(dialog, 'preview_canvas', None)
            if preview_canvas and preview_canvas.winfo_exists():
                try:
                    preview_canvas.delete("all")
                except tk.TclError: pass

    def _on_rom_canvas_leave(self, event):
        """Clears hover info and preview when mouse leaves ROM importer canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        self.rom_import_dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
        if hasattr(self.rom_import_dialog, 'preview_canvas'): # Check if preview_canvas exists
             self.rom_import_dialog.preview_canvas.delete("all")

    def _on_rom_canvas_left_click(self, event):
        # Handles left-click on ROM importer canvas for complex selection.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return

        # --- Start of existing logic to determine clicked_rom_tile_absolute_idx ---
        rom_data = dialog.rom_data
        current_global_fine_offset = dialog.fine_offset_var.get() 
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = 0
        try:
            if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
        except tk.TclError: return
        if canvas_width_current <=1: return
        
        # Use dialog.rom_importer_grid_cols as it should be up-to-date from the last full draw
        # If it's the very first click before any draw, this might need a default.
        # The _create_rom_importer_dialog now initializes dialog.rom_importer_grid_cols.
        tiles_across = getattr(dialog, 'rom_importer_grid_cols', max(1, canvas_width_current // (tile_display_size + padding)))
        if tiles_across <= 0: tiles_across = 1 # Ensure positive

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        clicked_grid_col = int(cx // (tile_display_size + padding))
        clicked_grid_row = int(cy // (tile_display_size + padding))
        clicked_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col

        total_potential_tiles = 0
        fine_offset_for_total_calc = dialog.fine_offset_var.get()
        if len(rom_data) > fine_offset_for_total_calc :
            total_potential_tiles = (len(rom_data) - fine_offset_for_total_calc) // TILE_WIDTH
        if not (0 <= clicked_rom_tile_absolute_idx < total_potential_tiles):
            self.debug(f"[DEBUG] Click outside valid tile area. Clicked index: {clicked_rom_tile_absolute_idx}, Total potential: {total_potential_tiles}")
            return
        # --- End of logic to determine clicked_rom_tile_absolute_idx ---


        is_shift_pressed = (event.state & 0x0001) != 0
        is_ctrl_pressed = (event.state & 0x0004) != 0
        selection_dict = dialog.rom_importer_selection
        current_anchor_idx = dialog.rom_importer_anchor_idx
        fg_to_associate = dialog.current_importer_fg_idx
        bg_to_associate = dialog.current_importer_bg_idx
        offset_to_associate = current_global_fine_offset # Use current global offset from slider
        properties_tuple_to_associate = (fg_to_associate, bg_to_associate, offset_to_associate)

        self.debug(f"\n[DEBUG] _on_rom_canvas_left_click: Clicked Idx: {clicked_rom_tile_absolute_idx}")
        self.debug(f"[DEBUG] Tiles Across used for click logic: {tiles_across}")
        self.debug(f"[DEBUG] Shift: {is_shift_pressed}, Ctrl: {is_ctrl_pressed}")
        self.debug(f"[DEBUG] Current Anchor: {current_anchor_idx}")
        self.debug(f"[DEBUG] Props to associate: {properties_tuple_to_associate}")
        self.debug(f"[DEBUG] Selection BEFORE: {dict(selection_dict)}") # Less verbose

        selection_changed_in_dict = False # More specific flag

        if is_ctrl_pressed and is_shift_pressed:
            self.debug("[DEBUG] Path: Ctrl+Shift+Click")
            # ... (Ctrl+Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            anchor_props_to_use = properties_tuple_to_associate # Default to current
            if current_anchor_idx != -1 and current_anchor_idx in selection_dict:
                anchor_props_to_use = selection_dict[current_anchor_idx]
                self.debug(f"[DEBUG] Ctrl+Shift: Using properties {anchor_props_to_use} from anchor {current_anchor_idx}.")
            else:
                 self.debug(f"[DEBUG] Ctrl+Shift: No/Invalid anchor, using current global properties {anchor_props_to_use}.")

            min_idx = min(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            max_idx = max(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            for i in range(min_idx, max_idx + 1):
                if i not in selection_dict or selection_dict[i] != anchor_props_to_use:
                    selection_dict[i] = anchor_props_to_use
                    selection_changed_in_dict = True
            if current_anchor_idx == -1: # Set anchor if it was not set
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
                 # selection_changed_in_dict = True # Anchor change is part of selection state
        elif is_shift_pressed:
            self.debug("[DEBUG] Path: Shift+Click")
            # ... (Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if current_anchor_idx != -1:
                new_range_selection = {}
                min_idx = min(current_anchor_idx, clicked_rom_tile_absolute_idx)
                max_idx = max(current_anchor_idx, clicked_rom_tile_absolute_idx)
                for i in range(min_idx, max_idx + 1):
                    new_range_selection[i] = properties_tuple_to_associate
                if selection_dict != new_range_selection: # Compare content
                    selection_dict.clear()
                    selection_dict.update(new_range_selection)
                    selection_changed_in_dict = True
            else: # No anchor, treat as normal click for selection, but set anchor
                if not (len(selection_dict) == 1 and clicked_rom_tile_absolute_idx in selection_dict and selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate):
                    selection_dict.clear()
                    selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                    selection_changed_in_dict = True
                dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
        elif is_ctrl_pressed:
            self.debug("[DEBUG] Path: Ctrl+Click")
            # ... (Ctrl logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if clicked_rom_tile_absolute_idx in selection_dict:
                del selection_dict[clicked_rom_tile_absolute_idx]
                selection_changed_in_dict = True
                if dialog.rom_importer_anchor_idx == clicked_rom_tile_absolute_idx:
                    dialog.rom_importer_anchor_idx = -1 
            else:
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            # Set/update anchor if adding to selection or if it's the only one left
            if clicked_rom_tile_absolute_idx in selection_dict and dialog.rom_importer_anchor_idx != clicked_rom_tile_absolute_idx :
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
            elif not selection_dict : # If selection became empty
                 dialog.rom_importer_anchor_idx = -1

        else: # Normal Click
            self.debug("[DEBUG] Path: Normal Click")
            # ... (Normal click logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            is_already_solely_selected_with_same_props = (
                len(selection_dict) == 1 and
                clicked_rom_tile_absolute_idx in selection_dict and
                selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate
            )
            if not is_already_solely_selected_with_same_props:
                selection_dict.clear()
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx

        # Check if anchor changed, that also means UI state change
        anchor_state_changed = (dialog.rom_importer_anchor_idx != current_anchor_idx)
        
        self.debug(f"[DEBUG] Selection AFTER: {dict(selection_dict)}")
        self.debug(f"[DEBUG] New Anchor: {dialog.rom_importer_anchor_idx}")

        # If selection dict content or anchor changed, then update UI
        if selection_changed_in_dict or anchor_state_changed:
            if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
                dialog.import_button.config(state=tk.NORMAL if selection_dict else tk.DISABLED)
            
            self._update_rom_importer_info_labels() # Updates text vars

            # --- MODIFICATION: Instead of calling highlight directly, trigger a full redraw ---
            self.debug("[DEBUG] Selection/Anchor changed. Triggering full canvas redraw.")
            # Ensure the redraw uses the most recent canvas size if it changed just before click
            # This can be done by calling the configure handler's logic, or just draw
            # self._on_rom_importer_setting_change(configure_event=True) # This will debounce
            # For immediate reflection of selection:
            if canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                 self._draw_rom_importer_canvas() # Direct call
            else: # If canvas not ready, rely on a later configure event to draw
                 self.debug("[DEBUG] Canvas not ready after click, deferring full redraw to configure event.")
            # --- END MODIFICATION ---
        else:
            self.debug("[DEBUG] No change in selection_dict content or anchor. Skipping UI updates from click.")

    def _on_rom_canvas_right_click(self, event):
        """Handles right-click on ROM importer canvas to cancel selection."""
        self._clear_rom_import_selection()

    def _clear_rom_import_selection(self):
        # Clears the current tile selection in the ROM importer dialog.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        dialog = self.rom_import_dialog
        
        selection_was_present = bool(getattr(dialog, 'rom_importer_selection', {}))
        anchor_was_present = (getattr(dialog, 'rom_importer_anchor_idx', -1) != -1)

        if hasattr(dialog, 'rom_importer_selection'):
            dialog.rom_importer_selection.clear()
        else:
            dialog.rom_importer_selection = {} # Ensure it exists
            
        dialog.rom_importer_anchor_idx = -1
            
        if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
            dialog.import_button.config(state=tk.DISABLED) 
        
        self._update_rom_importer_info_labels() # Update text vars

        # If there was a selection or anchor, a redraw is needed to remove highlights
        if selection_was_present or anchor_was_present:
            self.debug("[DEBUG] Selection cleared. Triggering full canvas redraw.")
            canvas = getattr(dialog, 'canvas', None)
            if canvas and canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                self._draw_rom_importer_canvas() # Redraw to remove highlights
            else:
                self.debug("[DEBUG] Canvas not ready after clearing selection, deferring redraw.")
        # else: # No selection was present, _draw_rom_import_selection_highlight would do nothing anyway
        #    self._draw_rom_import_selection_highlight() # Call to ensure no stale borders if logic changes

    def _update_rom_importer_info_labels(self):
        """Updates dynamic labels in the ROM importer (selected count, top-left byte)."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        count = 0
        if hasattr(dialog, 'rom_importer_selection'):
            count = len(dialog.rom_importer_selection)
        
        if hasattr(dialog, 'selection_info_text_var') and isinstance(dialog.selection_info_text_var, tk.StringVar):
            try:
                dialog.selection_info_text_var.set(f"Tiles Selected: {count}")
            except tk.TclError: # Can happen if dialog is closing
                pass
        # top_left_grid_byte_offset_text_var is updated in _draw_rom_importer_canvas

    def _draw_rom_tile_preview(self, rom_byte_start_pos_hover, hovered_rom_tile_absolute_idx=-1):
        """Draws a single tile from ROM data into the preview canvas, using appropriate colors and offset."""
        # rom_byte_start_pos_hover is calculated based on the GLOBAL fine offset for hover info
        # We need to recalculate it here if the tile is selected and has its own offset.

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not hasattr(self.rom_import_dialog, 'preview_canvas'):
            return

        preview_canvas = self.rom_import_dialog.preview_canvas
        rom_data = self.rom_import_dialog.rom_data
        dialog = self.rom_import_dialog
        preview_canvas.delete("all")

        # Determine FG/BG colors and the FINE OFFSET for this preview
        preview_fg_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        preview_bg_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        fine_offset_for_preview = dialog.fine_offset_var.get() # Default to global slider

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if hovered_rom_tile_absolute_idx != -1 and hovered_rom_tile_absolute_idx in selection_dict:
            stored_props = selection_dict[hovered_rom_tile_absolute_idx]
            preview_fg_idx, preview_bg_idx, fine_offset_for_preview = stored_props[0], stored_props[1], stored_props[2]

        # Recalculate the actual starting byte position using the determined fine_offset_for_preview
        # hovered_rom_tile_absolute_idx is the tile's index in the grid if the global offset were 0.
        actual_rom_byte_start_for_preview = fine_offset_for_preview + (hovered_rom_tile_absolute_idx * TILE_WIDTH)

        if not (0 <= actual_rom_byte_start_for_preview < len(rom_data)):
            self.debug(f"[DEBUG] Preview: Invalid actual_rom_byte_start_for_preview {actual_rom_byte_start_for_preview} for tile_idx {hovered_rom_tile_absolute_idx} with offset {fine_offset_for_preview}. Skipping preview.")
            return # Cannot draw if calculated offset is out of bounds

        safe_preview_fg_idx = preview_fg_idx if 0 <= preview_fg_idx < len(self.active_msx_palette) else WHITE_IDX
        safe_preview_bg_idx = preview_bg_idx if 0 <= preview_bg_idx < len(self.active_msx_palette) else BLACK_IDX
        color_for_fg_pixel_preview = self.active_msx_palette[safe_preview_fg_idx]
        color_for_bg_pixel_preview = self.active_msx_palette[safe_preview_bg_idx]

        if actual_rom_byte_start_for_preview + TILE_WIDTH > len(rom_data):
            num_bytes_avail = len(rom_data) - actual_rom_byte_start_for_preview
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview:] + bytes(TILE_WIDTH - num_bytes_avail)
        else:
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview : actual_rom_byte_start_for_preview + TILE_WIDTH]

        pixel_render_size = EDITOR_PIXEL_SIZE
        for r_tile_pixel in range(TILE_HEIGHT):
            if r_tile_pixel >= len(tile_bytes_data): continue
            row_byte = tile_bytes_data[r_tile_pixel]
            for c_tile_pixel in range(TILE_WIDTH):
                pixel_is_set = (row_byte >> (7 - c_tile_pixel)) & 1
                color_hex = color_for_fg_pixel_preview if pixel_is_set else color_for_bg_pixel_preview

                x1 = c_tile_pixel * pixel_render_size
                y1 = r_tile_pixel * pixel_render_size
                x2 = x1 + pixel_render_size
                y2 = y1 + pixel_render_size
                try:
                    if preview_canvas.winfo_exists():
                        preview_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey")
                except tk.TclError:
                    return

    def _on_rom_canvas_keypress(self, event):
        # Handles keyboard navigation for the ROM importer canvas.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        canvas = getattr(self.rom_import_dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return
        
        dialog = self.rom_import_dialog # Get dialog reference
        key_pressed = event.keysym
        self.debug(f"[DEBUG] Keypress: {key_pressed}") # Keep for now if needed

        action_taken = False
        native_scroll_performed = False 

        if key_pressed == "Up":
            canvas.yview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Down":
            canvas.yview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Left":
            canvas.xview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Right":
            canvas.xview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Prior": # PageUp
            canvas.yview_scroll(-1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Next": # PageDown
            canvas.yview_scroll(1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Home":
            current_x_frac, _ = canvas.xview()
            if current_x_frac != 0.0: canvas.xview_moveto(0.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac != 0.0: canvas.yview_moveto(0.0); native_scroll_performed = True
            action_taken = True
        elif key_pressed == "End":
            current_x_frac, _ = canvas.xview()
            if current_x_frac < 1.0: canvas.xview_moveto(1.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac < 1.0: canvas.yview_moveto(1.0); native_scroll_performed = True
            action_taken = True
        else:
            return 

        if action_taken:
            # If a native scroll was performed, or for Home/End, schedule a debounced redraw
            if native_scroll_performed or key_pressed in ["Home", "End"]:
                self.debug(f"[DEBUG] Keypress '{key_pressed}': Scheduling debounced _draw_rom_importer_canvas.")
                
                # Use dialog.redraw_timer_id for consistency with <Configure>
                if not hasattr(dialog, 'redraw_timer_id'): # Should have been init in _create_dialog
                    dialog.redraw_timer_id = None

                if dialog.redraw_timer_id is not None:
                    dialog.after_cancel(dialog.redraw_timer_id)
                
                # Perform_debounced_rom_canvas_draw already exists and calls _draw_rom_importer_canvas
                # It also clears its own timer ID.
                dialog.redraw_timer_id = dialog.after(30, self._perform_debounced_rom_canvas_draw) # 30ms delay
        return "break"

    def _execute_rom_tile_import(self):
        """Reads selected tile data from ROM and appends to the main tileset, using stored colors and offsets."""
        global num_tiles_in_set, current_tile_index, tileset_patterns, tileset_colors

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            messagebox.showwarning("Import Error", "No tiles selected from ROM.", parent=dialog)
            return

        rom_data = dialog.rom_data
        
        sorted_selected_items = sorted(selection_dict.items(), key=lambda item: item[0])

        num_tiles_to_import_attempt = len(sorted_selected_items)
        imported_tiles_count = 0
        first_newly_imported_tile_index = -1
        tileset_structure_changed = False # Flag to see if num_tiles_in_set actually increased

        for current_rom_tile_absolute_idx, (fg_idx_for_import, bg_idx_for_import, fine_offset_for_import) in sorted_selected_items:
            if num_tiles_in_set >= MAX_TILES:
                messagebox.showinfo(
                    "Import Limit Reached",
                    f"Tileset limit of {MAX_TILES} reached.\nImported {imported_tiles_count} of {num_tiles_to_import_attempt} selected tiles.",
                    parent=dialog
                )
                break

            rom_byte_start_pos = fine_offset_for_import + (current_rom_tile_absolute_idx * TILE_WIDTH)

            if not (0 <= rom_byte_start_pos < len(rom_data)):
                self.debug(f"[DEBUG] ROM Import EXEC: Skipping invalid ROM tile index {current_rom_tile_absolute_idx} with stored offset {fine_offset_for_import}, leading to offset {rom_byte_start_pos} out of bounds for ROM size {len(rom_data)}")
                continue

            new_tile_pattern_data = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
            new_tile_color_data = [(fg_idx_for_import, bg_idx_for_import) for _ in range(TILE_HEIGHT)]

            if rom_byte_start_pos + TILE_WIDTH > len(rom_data): # TILE_WIDTH is bytes per tile (TILE_HEIGHT bytes)
                num_bytes_avail = len(rom_data) - rom_byte_start_pos
                # Ensure tile_bytes_from_rom is TILE_HEIGHT bytes long for row iteration
                tile_bytes_from_rom = rom_data[rom_byte_start_pos:] + bytes(TILE_HEIGHT - num_bytes_avail if TILE_HEIGHT > num_bytes_avail else 0)
            else:
                tile_bytes_from_rom = rom_data[rom_byte_start_pos : rom_byte_start_pos + TILE_HEIGHT]


            for r_pixel in range(TILE_HEIGHT):
                if r_pixel < len(tile_bytes_from_rom):
                    row_byte_value = tile_bytes_from_rom[r_pixel]
                    for c_pixel in range(TILE_WIDTH):
                        new_tile_pattern_data[r_pixel][c_pixel] = (row_byte_value >> (7 - c_pixel)) & 1
                else: # Should only happen if TILE_HEIGHT > len(tile_bytes_from_rom) after padding
                    for c_pixel in range(TILE_WIDTH):
                        new_tile_pattern_data[r_pixel][c_pixel] = 0 # Fill with background

            if num_tiles_in_set < MAX_TILES:
                if len(tileset_patterns) > num_tiles_in_set and len(tileset_colors) > num_tiles_in_set:
                    if first_newly_imported_tile_index == -1:
                        first_newly_imported_tile_index = num_tiles_in_set

                    tileset_patterns[num_tiles_in_set] = new_tile_pattern_data
                    tileset_colors[num_tiles_in_set] = new_tile_color_data

                    num_tiles_in_set += 1
                    imported_tiles_count += 1
                    tileset_structure_changed = True # num_tiles_in_set increased
                    self._mark_project_modified()
                else:
                    self.debug(f"[DEBUG] ROM Import EXEC Error: Tileset data structures not large enough for index {num_tiles_in_set}.")
                    break
            else:
                break

        parent_dialog_for_messagebox = self.rom_import_dialog
        self._close_rom_importer_dialog()

        if imported_tiles_count > 0:
            if first_newly_imported_tile_index != -1:
                current_tile_index = first_newly_imported_tile_index
            else: # Should not happen if tiles were imported
                current_tile_index = num_tiles_in_set - 1

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()

            if hasattr(self, 'notebook') and hasattr(self, 'tab_tile_editor'):
                try:
                    self.notebook.select(self.tab_tile_editor)
                except tk.TclError:
                    self.debug("[DEBUG] TclError selecting tile editor tab after import (notebook/tab gone?).")

            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._update_edit_menu_state()
            if tileset_structure_changed: # If new tiles were added
                self._request_color_usage_refresh()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()

            messagebox.showinfo("Import Successful",
                                f"Successfully imported {imported_tiles_count} tile(s).",
                                parent=self.root)
        elif num_tiles_to_import_attempt > 0 :
             messagebox.showwarning("Import Notice",
                                   "No new tiles were imported. Tileset might be full or selected ROM data was out of bounds.",
                                   parent=self.root)

    def _get_zoomed_supertile_pixel_dims(self):
        """
        Calculates the pixel width and height of one supertile on the map canvas
        at the current zoom level, based on the project's supertile dimensions.
        Returns a tuple (width_pixels, height_pixels).
        """
        zoomed_tile_size = self.get_zoomed_tile_size() # This is pixels per TILE_WIDTH/TILE_HEIGHT (8x8) unit

        if zoomed_tile_size <= 0: # Defensive check
            return 0, 0

        zoomed_supertile_pixel_width = self.supertile_grid_width * zoomed_tile_size
        zoomed_supertile_pixel_height = self.supertile_grid_height * zoomed_tile_size
        
        # Ensure minimum 1 pixel if dimensions are very small but > 0
        zoomed_supertile_pixel_width = max(1, zoomed_supertile_pixel_width)
        zoomed_supertile_pixel_height = max(1, zoomed_supertile_pixel_height)

        return zoomed_supertile_pixel_width, zoomed_supertile_pixel_height

    def _update_supertile_rotate_button_state(self):
        """
        Updates the state of the supertile rotate button based on whether
        the current supertile dimensions are square.
        """
        if hasattr(self, 'st_rotate_button') and self.st_rotate_button.winfo_exists():
            try:
                if self.supertile_grid_width == self.supertile_grid_height:
                    self.st_rotate_button.config(state=tk.NORMAL)
                else:
                    self.st_rotate_button.config(state=tk.DISABLED)
            except tk.TclError:
                # Widget might be in the process of being destroyed, or not fully ready
                pass
        # else: button doesn't exist yet, will be configured when created

    def _reconfigure_supertile_definition_canvas(self):
        """
        Reconfigures the size of the supertile definition canvas based on the
        current self.supertile_grid_width and self.supertile_grid_height.
        Then redraws its content.
        """
        if hasattr(self, 'supertile_def_canvas') and self.supertile_def_canvas.winfo_exists():
            try:
                # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32)
                new_canvas_w = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
                new_canvas_h = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
                
                # Ensure minimum practical size for the canvas
                new_canvas_w = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_w) # Min width of one mini-tile
                new_canvas_h = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_h) # Min height of one mini-tile

                self.supertile_def_canvas.config(width=new_canvas_w, height=new_canvas_h)
                
                # The scrollregion for this canvas might not be strictly necessary if it's always
                # sized to fit its content perfectly and doesn't scroll.
                # If it were to scroll (e.g., fixed size canvas viewing larger def),
                # then scrollregion would need update: self.supertile_def_canvas.config(scrollregion=(0,0,new_canvas_w, new_canvas_h))

                self.draw_supertile_definition_canvas() # Redraw content after resize
            except tk.TclError:
                self.debug("[DEBUG]TclError during supertile definition canvas reconfiguration.")
                pass
            except Exception as e:
                self.debug(f"[DEBUG]Error reconfiguring supertile definition canvas: {e}")
                pass
        # else: canvas not yet created or already destroyed.


    def create_map_render_of_supertile(self, supertile_index, target_render_width, target_render_height):
        # Creates a Pillow Image for a supertile, scaled to target_render_width/height.
        # Cache now stores Pillow.Image objects.

        safe_target_render_width = max(1, int(target_render_width))
        safe_target_render_height = max(1, int(target_render_height))

        cache_key = (supertile_index, safe_target_render_width, safe_target_render_height, 
                     self.supertile_grid_width, self.supertile_grid_height)
        
        if cache_key in self.map_render_cache:
            return self.map_render_cache[cache_key]

        # Create a Pillow Image for the entire scaled supertile
        # Use 'RGB' mode. If alpha is needed later, can change to 'RGBA'.
        try:
            # Ensure dimensions are positive for Image.new
            pil_supertile_image = Image.new('RGB', 
                                          (max(1, safe_target_render_width), max(1, safe_target_render_height)), 
                                          INVALID_SUPERTILE_COLOR) # Fill with invalid color initially
        except ValueError as e_img_new: # e.g. negative size if calculations somehow fail
            self.debug(f"[DEBUG] Error creating Pillow image for supertile {supertile_index} (size {safe_target_render_width}x{safe_target_render_height}): {e_img_new}")
            # Return a minimal placeholder Pillow image on error
            placeholder_pil = Image.new('RGB', (1,1), INVALID_SUPERTILE_COLOR)
            self.map_render_cache[cache_key] = placeholder_pil # Cache placeholder to avoid re-erroring
            return placeholder_pil


        if not (0 <= supertile_index < num_supertiles):
            # Already filled with INVALID_SUPERTILE_COLOR
            self.map_render_cache[cache_key] = pil_supertile_image
            return pil_supertile_image

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            self.debug(f"[DEBUG] Supertile {supertile_index} dim mismatch for map render.")
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image

        # Size of one base 8x8 tile when scaled to fit within the target_render_width/height
        scaled_base_tile_w = safe_target_render_width / src_st_tile_grid_w
        scaled_base_tile_h = safe_target_render_height / src_st_tile_grid_h

        # Ensure scaled base tile dimensions are at least 1 pixel for Pillow's resize
        # Pillow's resize to (0,0) or (0,X) or (X,0) might error or produce unexpected results.
        # We round them, then ensure they are at least 1.
        final_scaled_base_tile_w = max(1, round(scaled_base_tile_w))
        final_scaled_base_tile_h = max(1, round(scaled_base_tile_h))


        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))

        for r_st_def in range(src_st_tile_grid_h): # Row in supertile definition
            for c_st_def in range(src_st_tile_grid_w): # Col in supertile definition
                tile_idx_from_st_def = definition[r_st_def][c_st_def]
                
                pixel_data_for_base_tile = [] # Flat list of (r,g,b) tuples for 8x8 tile
                valid_tile = True

                if not (0 <= tile_idx_from_st_def < num_tiles_in_set):
                    valid_tile = False
                else:
                    pattern = tileset_patterns[tile_idx_from_st_def]
                    colors = tileset_colors[tile_idx_from_st_def]

                    for y_pixel_in_base in range(TILE_HEIGHT): # 0-7
                        if not (y_pixel_in_base < len(pattern) and y_pixel_in_base < len(colors)):
                            valid_tile = False; break # Malformed tile data
                        
                        fg_idx, bg_idx = colors[y_pixel_in_base]
                        if not (0 <= fg_idx < len(self.active_msx_palette) and \
                                0 <= bg_idx < len(self.active_msx_palette)):
                            fg_color_hex = INVALID_TILE_COLOR; bg_color_hex = INVALID_TILE_COLOR
                        else:
                            fg_color_hex = self.active_msx_palette[fg_idx]
                            bg_color_hex = self.active_msx_palette[bg_idx]

                        row_pattern_data = pattern[y_pixel_in_base]
                        if not (len(row_pattern_data) == TILE_WIDTH):
                            valid_tile = False; break # Malformed tile row

                        for x_pixel_in_base in range(TILE_WIDTH): # 0-7
                            pixel_val = row_pattern_data[x_pixel_in_base]
                            color_hex_to_use = fg_color_hex if pixel_val == 1 else bg_color_hex
                            try:
                                # Pillow needs RGB tuples, not hex strings for putdata
                                r_int = int(color_hex_to_use[1:3], 16)
                                g_int = int(color_hex_to_use[3:5], 16)
                                b_int = int(color_hex_to_use[5:7], 16)
                                pixel_data_for_base_tile.append((r_int, g_int, b_int))
                            except ValueError: # Invalid hex string
                                pixel_data_for_base_tile.append((255,0,255)) # Magenta for error
                    if not valid_tile: break
                
                if not valid_tile or len(pixel_data_for_base_tile) != TILE_WIDTH * TILE_HEIGHT:
                    # Fill this part of supertile with invalid color if base tile is bad
                    # Create a temporary Pillow image for the scaled error tile
                    error_scaled_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)
                    paste_x = round(c_st_def * scaled_base_tile_w)
                    paste_y = round(r_st_def * scaled_base_tile_h)
                    pil_supertile_image.paste(error_scaled_tile, (paste_x, paste_y))
                    continue

                # Populate the 8x8 temporary Pillow image
                pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                # Scale the 8x8 temporary image to its final size within the supertile
                try:
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (final_scaled_base_tile_w, final_scaled_base_tile_h),
                        Image.Resampling.NEAREST
                    )
                except ValueError as e_resize: # e.g. if final_scaled_base_tile_w/h are zero
                    self.debug(f"[DEBUG] Error resizing base tile in supertile {supertile_index}: {e_resize}")
                    pil_scaled_base_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)


                # Calculate paste position (top-left) for this scaled base tile
                # Use floating point scaled_base_tile_w/h for paste position calculation
                # then round for the final integer paste coordinates.
                paste_x = round(c_st_def * scaled_base_tile_w)
                paste_y = round(r_st_def * scaled_base_tile_h)

                pil_supertile_image.paste(pil_scaled_base_tile, (paste_x, paste_y))

        self.map_render_cache[cache_key] = pil_supertile_image
        return pil_supertile_image

    def _handle_map_scroll_event(self, event=None):
        # This method is called by scrollbar interactions.
        # It needs to redraw the main map canvas content and the minimap.
        # A small delay can sometimes help smooth out rapid scrollbar dragging,
        # but let's try direct calls first. If it's choppy, we can add debouncing.
        if self.map_canvas and self.map_canvas.winfo_exists():
            self.draw_map_canvas() # Redraw main map content
            self.draw_minimap()    # Update minimap

    def _perform_debounced_rom_canvas_draw(self):
        # This method is called by the 'after' timer from _on_rom_importer_setting_change (e.g. Configure)
        # and from scrollbar/keypress handlers in the ROM importer.
        
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.debug("[DEBUG] DebouncedRomDraw: ROM import dialog no longer exists. Aborting.")
            return
        
        dialog = self.rom_import_dialog
        
        # Clear the timer ID if it exists on the dialog object
        if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
            dialog.redraw_timer_id = None # Mark timer as having fired/been cleared

        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[DEBUG] DebouncedRomDraw: ROM importer canvas no longer exists. Aborting.")
            return
            
        # Check canvas size again before drawing, as it might still be too small
        # if configure events are rapid or window is being minimized.
        canvas_w = canvas.winfo_width()
        canvas_h = canvas.winfo_height()
        min_draw_size = VIEWER_TILE_SIZE # A sensible minimum, e.g., one tile
        
        if canvas_w < min_draw_size or canvas_h < min_draw_size:
            self.debug(f"[DEBUG] DebouncedRomDraw: Canvas still too small (W:{canvas_w}, H:{canvas_h}). Rescheduling.")
            # Reschedule the debounced draw if canvas is not yet ready
            if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
                 dialog.after_cancel(dialog.redraw_timer_id) # Cancel if somehow another one got set
            dialog.redraw_timer_id = dialog.after(100, self._perform_debounced_rom_canvas_draw) # Try again
            return

        self.debug("[DEBUG] DebouncedRomDraw: Conditions met. Calling _draw_rom_importer_canvas.")
        self._draw_rom_importer_canvas() # Call the (now Pillow-optimized) drawing method

    def _on_fine_offset_slider_change(self, slider_value_str=None):
        """Handles the fine_offset slider value change with debouncing and snapping."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        # Ensure the slider_redraw_timer_id attribute exists on the dialog object
        if not hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None

        if slider_value_str is not None:
            try:
                # The value from the slider command is a string representation of a float
                current_float_val = float(slider_value_str)
                rounded_int_val = round(current_float_val) # Round to nearest integer

                # Ensure the rounded value is within the slider's defined range (0-7)
                # This is mostly a safeguard, as 'from_' and 'to' should constrain it.
                clamped_int_val = max(0, min(7, rounded_int_val))

                # Update the IntVar. This will cause the slider to visually snap
                # if its current internal float value was different from the rounded int.
                # Only set if different to avoid potential recursive calls if not careful,
                # though with an IntVar, Tkinter usually handles this well.
                if dialog.fine_offset_var.get() != clamped_int_val:
                    dialog.fine_offset_var.set(clamped_int_val)
                    # No need to call _draw_rom_importer_canvas here directly.
                    # The debouncer will handle it based on the *final* settled value.
                    # If you wanted instant preview of the *snapped* value, you could add it here.

            except ValueError:
                # Handle cases where slider_value_str might not be a valid float string
                # This shouldn't happen with a standard Scale widget but good for robustness.
                pass # Keep current var value if conversion fails

        # Cancel any previously scheduled redraw for the slider
        if dialog.slider_redraw_timer_id is not None:
            dialog.after_cancel(dialog.slider_redraw_timer_id)
        
        # Schedule the actual redraw after a short delay
        # _perform_debounced_slider_redraw will use dialog.fine_offset_var.get()
        dialog.slider_redraw_timer_id = dialog.after(250, self._perform_debounced_slider_redraw)

    def _perform_debounced_slider_redraw(self):
        """Called by the after timer to redraw the ROM importer canvas after slider movement has paused."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        
        # Ensure the slider_redraw_timer_id attribute exists before trying to clear it
        if hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None # Clear the timer ID

        # Now, call the main drawing function for the ROM importer canvas
        # This function will use the current value of dialog.fine_offset_var.get()
        self._draw_rom_importer_canvas()

    def _update_importer_color_swatches(self):
        """Updates the BG/FG color swatches in the ROM importer dialog."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        # Ensure swatches and color indices exist on dialog
        if not all(hasattr(dialog, attr) for attr in ['importer_fg_swatch', 'importer_bg_swatch', 
                                                      'current_importer_fg_idx', 'current_importer_bg_idx']):
            return

        try:
            fg_color_hex = self.active_msx_palette[dialog.current_importer_fg_idx]
            bg_color_hex = self.active_msx_palette[dialog.current_importer_bg_idx]

            if dialog.importer_fg_swatch.winfo_exists():
                dialog.importer_fg_swatch.config(bg=fg_color_hex, fg=get_contrast_color(fg_color_hex))
            if dialog.importer_bg_swatch.winfo_exists():
                dialog.importer_bg_swatch.config(bg=bg_color_hex, fg=get_contrast_color(bg_color_hex))
        except IndexError:
            self.debug("[DEBUG] Error updating importer swatches: Palette index out of range.")
        except tk.TclError:
            self.debug("[DEBUG] Error updating importer swatches: TclError (widget likely destroyed).")

    def _pick_importer_color(self, swatch_type):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not self.active_msx_palette:
            return

        dialog = self.rom_import_dialog
        
        # Create a standard Toplevel window for the picker
        picker_win = tk.Toplevel(dialog)
        picker_win.title(f"Select Importer {'FG' if swatch_type == 'fg' else 'BG'} Color")
        picker_win.transient(dialog) # Make it a "child" of the dialog
        picker_win.grab_set()      # Modal behavior
        picker_win.resizable(False, False)

        # Canvas for color swatches
        picker_canvas_size_w = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        picker_canvas_size_h = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        
        picker_canvas = tk.Canvas(picker_win, 
                                  width=picker_canvas_size_w, 
                                  height=picker_canvas_size_h, 
                                  borderwidth=0, highlightthickness=0)
        picker_canvas.pack(padx=5, pady=5)

        selected_palette_index_from_picker = tk.IntVar(value=-1) 

        def on_palette_color_click(event, index_clicked):
            selected_palette_index_from_picker.set(index_clicked)
            picker_win.destroy() # This is the primary way it should close

        # Bind Escape to close the picker window
        picker_win.bind("<Escape>", lambda e: picker_win.destroy())

        # Populate the picker canvas with color swatches
        for i in range(len(self.active_msx_palette)): 
            row, col = divmod(i, 4)
            x1 = col * (PALETTE_SQUARE_SIZE + 2) + 2
            y1 = row * (PALETTE_SQUARE_SIZE + 2) + 2
            x2 = x1 + PALETTE_SQUARE_SIZE
            y2 = y1 + PALETTE_SQUARE_SIZE
            color_hex = self.active_msx_palette[i]
            
            rect_id = picker_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey", width=1, tags=f"picker_swatch_{i}")
            picker_canvas.tag_bind(rect_id, "<Button-1>", 
                                   lambda e, idx=i: on_palette_color_click(e, idx))
            # Optional: Add hover effects back if desired, but keep it simple first
            # picker_canvas.tag_bind(rect_id, "<Enter>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="yellow", width=2))
            # picker_canvas.tag_bind(rect_id, "<Leave>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="grey", width=1))
        
        # --- Positioning Logic ---
        picker_win.update_idletasks() # Calculate picker's required size

        clicked_swatch_widget = None
        if swatch_type == 'fg':
            clicked_swatch_widget = getattr(dialog, 'importer_fg_swatch', None)
        elif swatch_type == 'bg':
            clicked_swatch_widget = getattr(dialog, 'importer_bg_swatch', None)

        if clicked_swatch_widget and clicked_swatch_widget.winfo_exists():
            dialog.update_idletasks() # Ensure main dialog geometry is current
            
            swatch_screen_x = clicked_swatch_widget.winfo_rootx()
            swatch_screen_y = clicked_swatch_widget.winfo_rooty()
            swatch_width = clicked_swatch_widget.winfo_width()
            
            target_x_pos = swatch_screen_x + swatch_width + 5 # Position to the right
            target_y_pos = swatch_screen_y                     # Align top edges

            picker_w = picker_win.winfo_width() 
            picker_h = picker_win.winfo_height()
            screen_w = picker_win.winfo_screenwidth()
            screen_h = picker_win.winfo_screenheight()

            # Adjust if off-screen (simplified boundary check)
            if target_x_pos + picker_w > screen_w:
                target_x_pos = swatch_screen_x - picker_w - 5 # Try left
            if target_x_pos < 0: # Still off left, or was initially off left
                 target_x_pos = 5 # Fallback to near left edge of screen
            
            if target_y_pos + picker_h > screen_h:
                target_y_pos = screen_h - picker_h - 5 # Move up from bottom
            if target_y_pos < 0:
                target_y_pos = 5 # Fallback to near top edge of screen
            
            picker_win.geometry(f"+{target_x_pos}+{target_y_pos}")
        else:
            # Fallback: Center on the ROM importer dialog if swatch widget not found or other issue
            self.debug("[DEBUG] _pick_importer_color: Swatch widget not found or error; using fallback centering.")
            picker_win.update_idletasks()
            dialog_x = dialog.winfo_rootx()
            dialog_y = dialog.winfo_rooty()
            dialog_w = dialog.winfo_width()
            picker_w = picker_win.winfo_width()
            x_pos = dialog_x + (dialog_w // 2) - (picker_w // 2)
            y_pos = dialog_y + 50 # Offset slightly from dialog top
            picker_win.geometry(f"+{max(0, x_pos)}+{max(0, y_pos)}") # Ensure on screen
        
        picker_win.focus_set()
        picker_win.wait_window() # This blocks until picker_win is destroyed

        # --- Post-picker logic (after it's closed) ---
        chosen_idx = selected_palette_index_from_picker.get()
        if 0 <= chosen_idx < len(self.active_msx_palette):
            changed_color = False
            if swatch_type == 'fg':
                if dialog.current_importer_fg_idx != chosen_idx:
                    dialog.current_importer_fg_idx = chosen_idx
                    changed_color = True
            elif swatch_type == 'bg':
                if dialog.current_importer_bg_idx != chosen_idx:
                    dialog.current_importer_bg_idx = chosen_idx
                    changed_color = True
            
            if changed_color:
                self._update_importer_color_swatches()
                self._draw_rom_importer_canvas()

    def confirm_quit(self):
        """Checks for unsaved changes and prompts user before quitting. Saves window configs on exit."""
        perform_quit = False
        if self.project_modified:
            project_name_display = "Untitled"
            if self.current_project_base_path:
                project_name_display = os.path.basename(self.current_project_base_path)
            
            response = messagebox.askyesnocancel(
                "Quit MSX Tile Forge",
                f"Save changes to '{project_name_display}' before quitting?",
                parent=self.root
            )

            if response is True:  # Yes, Save
                save_successful = self.save_project()
                if save_successful:
                    perform_quit = True
            elif response is False:  # No, Don't Save
                perform_quit = True
            # If response is None (Cancel), perform_quit remains False
        else:
            # No unsaved changes, can quit directly
            perform_quit = True

        if perform_quit:
            self.debug("[DEBUG] confirm_quit: Proceeding with application quit.")
            self._save_window_configs() # Save usage window configurations
            if hasattr(self.root, 'destroy'): # Check if root still exists
                try:
                    self.root.destroy()
                except tk.TclError:
                    self.debug("[DEBUG] TclError during root.destroy() in confirm_quit.")
        else:
            self.debug("[DEBUG] confirm_quit: Quit cancelled by user or save process.")

    def _on_palette_pane_configure_for_redraw_only(self, event=None):
        # Called when the palette pane in the map editor is resized.
        # Solely responsible for debouncing the redraw of its content (map_supertile_selector_canvas).
        
        current_pane_event_width = getattr(event, 'width', 'N/A') # Get width if event is provided
        self.debug(f"[DEBUG] _on_palette_pane_configure_for_redraw_only: Event (width={current_pane_event_width}). Scheduling selector redraw.")

        if hasattr(self, '_palette_pane_resize_timer') and self._palette_pane_resize_timer is not None:
            try:
                self.root.after_cancel(self._palette_pane_resize_timer)
            except tk.TclError: pass 
        
        if not hasattr(self, '_palette_pane_resize_timer'): 
            self._palette_pane_resize_timer = None
            
        self._palette_pane_resize_timer = self.root.after(100, self._redraw_map_supertile_selector_debounced)
        self.debug(f"[DEBUG] === _on_palette_pane_configure_for_redraw_only END ===") # Optional: reduce log noise

    def _redraw_map_supertile_selector_debounced(self):
        # Actual redraw function called by the debouncer.
        self._palette_pane_resize_timer = None # Clear timer ID
        if hasattr(self, 'map_supertile_selector_canvas') and \
           self.map_supertile_selector_canvas.winfo_exists():
            self.debug("[DEBUG] Palette pane configured, redrawing map_supertile_selector_canvas.")
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        else:
            self.debug("[DEBUG] Palette pane configured, but map_supertile_selector_canvas not ready/exists.")

    def _enforce_palette_min_width_on_release(self, event=None):
        # Called on ButtonRelease-1 on the PanedWindow.
        # Checks if the palette pane is too small and corrects sash if needed.
        self.debug(f"\n[DEBUG] === _enforce_palette_min_width_on_release START ===")
        
        palette_pane_widget = getattr(self, 'map_editor_palette_pane_container', None)
        paned_window_widget = getattr(self, 'map_paned_window', None)

        if not paned_window_widget or not paned_window_widget.winfo_exists() or \
           not palette_pane_widget or not palette_pane_widget.winfo_exists():
            self.debug("[DEBUG] EnforceMinOnRelease: Required widgets missing. Aborting.")
            self.debug("[DEBUG] === _enforce_palette_min_width_on_release END (widgets missing) ===")
            return

        try:
            # Give Tkinter a moment to settle sizes after drag release, then check
            # This 'after' helps ensure winfo_width() is up-to-date.
            self.root.after(10, self._do_check_and_enforce_palette_min_width) 
            
        except Exception as e: 
            self.debug(f"[DEBUG] Unexpected error scheduling enforcement check: {e}")
        
        self.debug(f"[DEBUG] === _enforce_palette_min_width_on_release END (check scheduled) ===")

    def _do_check_and_enforce_palette_min_width(self):
        self.debug(f"\n[DEBUG] --- _do_check_and_enforce_palette_min_width ---")

        map_pane_container = getattr(self, 'map_editor_map_pane_container', None)
        palette_pane_container = getattr(self, 'map_editor_palette_pane_container', None)
        paned_window_widget = getattr(self, 'map_paned_window', None)

        if not paned_window_widget or not paned_window_widget.winfo_exists() or \
           not palette_pane_container or not palette_pane_container.winfo_exists() or \
           not map_pane_container or not map_pane_container.winfo_exists():
            self.debug("[DEBUG] DoCheckEnforce: Required paned window/pane widgets missing. Aborting.")
            return

        try:
            paned_window_total_width = paned_window_widget.winfo_width()
            sash_thickness_approx = 8 
            
            if paned_window_total_width < 50: 
                self.debug(f"[DEBUG] DoCheckEnforce: PanedWindow total width ({paned_window_total_width}) too small. Skipping enforcement.")
                return

            self.debug(f"[DEBUG] DoCheckEnforce: PanedWindowTotalW={paned_window_total_width}")

            # Min width for Left Pane (Map Area + Controls)
            # Ensure self.map_controls_min_width has a sensible default if not yet calculated
            # The value 400 worked for you.
            min_left_pane_width = getattr(self, 'map_controls_min_width', 400) 
            if min_left_pane_width <= 10: # If it was calculated as something tiny or was default 0
                min_left_pane_width = 400 # Override with your known good fallback
                self.debug(f"[DEBUG] DoCheckEnforce: Overriding min_left_pane_width to fallback {min_left_pane_width}")
            min_left_pane_width = max(50, min_left_pane_width) # Absolute floor
            self.debug(f"[DEBUG] DoCheckEnforce: Min Left Pane (Map Controls) Width Required: {min_left_pane_width}")

            # Min width for Right Pane (Palette) Content
            padding_for_palette_content = 1
            frame_padding_palette_approx = 20
            scrollbar_width_approx = 10 
            one_supertile_item_w = (self.supertile_grid_width * TILE_WIDTH)
            min_canvas_content_width_palette = (1 * one_supertile_item_w) + (1 + 1) * padding_for_palette_content 
            min_canvas_content_width_palette = max(32, min_canvas_content_width_palette)
            min_total_right_pane_width = min_canvas_content_width_palette + frame_padding_palette_approx + scrollbar_width_approx
            self.debug(f"[DEBUG] DoCheckEnforce: Min Total Right Pane (Palette) Width Required: {min_total_right_pane_width}")

            current_sash_0_pos = paned_window_widget.sashpos(0)
            final_target_sash_pos = current_sash_0_pos # Start with current, adjust if needed
            self.debug(f"[DEBUG] DoCheckEnforce: Initial current_sash_pos(0) = {final_target_sash_pos}")

            # Calculate desired sash position to satisfy right pane's minimum
            sash_for_right_min = paned_window_total_width - min_total_right_pane_width - sash_thickness_approx
            
            # Calculate desired sash position to satisfy left pane's minimum
            sash_for_left_min = min_left_pane_width

            needs_correction = False

            # If left pane is too small
            if current_sash_0_pos < sash_for_left_min:
                self.debug(f"[DEBUG] DoCheckEnforce: Left pane ({current_sash_0_pos}) is smaller than required ({sash_for_left_min}). Targetting {sash_for_left_min}.")
                final_target_sash_pos = sash_for_left_min
                needs_correction = True
            
            # Now, check if this 'final_target_sash_pos' makes the right pane too small
            effective_right_pane_width = paned_window_total_width - final_target_sash_pos - sash_thickness_approx
            if effective_right_pane_width < min_total_right_pane_width:
                self.debug(f"[DEBUG] DoCheckEnforce: Giving left pane its min would make right pane ({effective_right_pane_width}) too small (min {min_total_right_pane_width}).")
                # This means we might not be able to satisfy both. Prioritize left pane's minimum.
                # The 'final_target_sash_pos' is already set to satisfy the left pane.
                # If we wanted to prioritize right, we'd set: final_target_sash_pos = sash_for_right_min
                # and then re-check if left became too small.
                # The current logic: if left needs X, set sash to X. If this makes right too small, tough for right.
                # Let's refine: try to satisfy both, but if conflict, choose.
                
                # Can we satisfy both?
                if (sash_for_left_min + sash_thickness_approx + min_total_right_pane_width) <= paned_window_total_width:
                    # Yes, there's enough space for both minimums and the sash.
                    # Ensure left gets its min.
                    final_target_sash_pos = max(final_target_sash_pos, sash_for_left_min)
                    # Ensure right gets its min (adjust sash from left edge).
                    final_target_sash_pos = min(final_target_sash_pos, sash_for_right_min)
                    self.debug(f"[DEBUG] DoCheckEnforce: Enough space for both. Final target after considering both: {final_target_sash_pos}")

                else: # Not enough space for both minimums
                    self.debug(f"[DEBUG] DoCheckEnforce: Not enough total width for both minimums. Prioritizing left pane min.")
                    final_target_sash_pos = sash_for_left_min # Prioritize left pane
                needs_correction = True # A correction is likely needed if we entered this complex block

            # Final clamping of the target sash position to valid PanedWindow bounds
            final_target_sash_pos = max(0, final_target_sash_pos)
            # Ensure right pane at least has space for sash thickness if target is too far right
            final_target_sash_pos = min(final_target_sash_pos, paned_window_total_width - sash_thickness_approx) 
                                          
            self.debug(f"[DEBUG] DoCheckEnforce: OriginalSashPos={current_sash_0_pos}, FinalCalculatedTargetSashPos={final_target_sash_pos}")

            if needs_correction and abs(current_sash_0_pos - final_target_sash_pos) > 2:
                self.debug(f"[DEBUG] DoCheckEnforce: Applying final sashpos(0) to: {final_target_sash_pos}")
                try:
                    paned_window_widget.sashpos(0, final_target_sash_pos)
                except tk.TclError as e_sash:
                    self.debug(f"[DEBUG] DoCheckEnforce: TclError setting sashpos: {e_sash}")
            elif needs_correction: # Corrected value is too close to current, no actual sashpos call
                 self.debug(f"[DEBUG] DoCheckEnforce: Correction calculated but change too small or already correct. Not calling sashpos.")
            else: # No violation detected initially
                self.debug(f"[DEBUG] DoCheckEnforce: No minimum width violations detected. No change to sash needed.")
        
        except tk.TclError as e:
            self.debug(f"[DEBUG] TclError in _do_check_and_enforce_palette_min_width: {e}")
        except Exception as e: 
            self.debug(f"[DEBUG] Unexpected error in _do_check_and_enforce_palette_min_width: {e}")
        self.debug(f"[DEBUG] --- _do_check_and_enforce_palette_min_width END ---")

    def _on_main_window_configure(self, event=None):
        if event and event.widget != self.root:
            return 

        self.debug(f"[DEBUG] _on_main_window_configure: Main window resized/moved (w={self.root.winfo_width()}, h={self.root.winfo_height()}).")

        if hasattr(self, '_main_window_configure_timer') and self._main_window_configure_timer is not None:
            try:
                self.root.after_cancel(self._main_window_configure_timer)
            except tk.TclError: pass
        
        # Ensure this calls the correctly named method
        self._main_window_configure_timer = self.root.after(300, self._call_enforce_min_width_logic_from_main_resize)

    def _call_enforce_min_width_logic_from_main_resize(self): # Renamed for clarity
        self.debug("[DEBUG] --- Main window resize: performing debounced pane minimum check ---")
        if hasattr(self, '_main_window_configure_timer'): 
            self._main_window_configure_timer = None
        
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                # Check if the currently selected tab's frame widget is the map editor's frame widget
                selected_tab_path = self.notebook.select()
                if selected_tab_path: # Ensure a tab is actually selected
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
            except tk.TclError: 
                self.debug("[DEBUG] Main resize check: TclError getting selected tab info.")
        
        if is_map_tab_active:
            # Ensure map_paned_window exists and is mapped (visible) before calling enforce
            if hasattr(self, 'map_paned_window') and \
               self.map_paned_window.winfo_exists() and \
               self.map_paned_window.winfo_ismapped():
                self.debug("[DEBUG] Main resize: Map tab active and paned window mapped. Calling _do_check_and_enforce_palette_min_width.")
                self._do_check_and_enforce_palette_min_width() # Call the core logic
            else:
                self.debug("[DEBUG] Main resize: Map tab active, but map_paned_window not ready/mapped. Skipping enforcement.")
        else:
            self.debug("[DEBUG] Main resize: Map tab not active. Skipping pane minimum enforcement.")

    def _on_map_canvas_configure(self, event=None):
        # Called when the map_canvas itself is resized (e.g., due to sash drag or window resize)
        
        map_canvas_widget = getattr(self, 'map_canvas', None)
        if not map_canvas_widget or not map_canvas_widget.winfo_exists():
            self.debug("[DEBUG] _on_map_canvas_configure: Map canvas not available. Skipping redraw.")
            return

        # event.width and event.height should give the new dimensions of self.map_canvas
        # Fallback to winfo_width/height if event attributes are not present (though they should be for <Configure>)
        new_width = getattr(event, 'width', map_canvas_widget.winfo_width())
        new_height = getattr(event, 'height', map_canvas_widget.winfo_height())

        self.debug(f"[DEBUG] _on_map_canvas_configure: Map canvas configured. New WxH: {new_width}x{new_height}.")

        # We only want to trigger a full redraw if the size has actually changed meaningfully,
        # as <Configure> can also fire for position changes.
        # We can compare with the dimensions of our current Pillow viewport image.
        viewport_changed_width = True # Assume changed unless proven otherwise
        viewport_changed_height = True

        if hasattr(self, 'pil_map_viewport_image') and self.pil_map_viewport_image:
            if self.pil_map_viewport_image.width == new_width:
                viewport_changed_width = False
            if self.pil_map_viewport_image.height == new_height:
                viewport_changed_height = False
        
        # Only redraw if dimensions are valid and have actually changed, or if no viewport image exists yet
        if (new_width > 1 and new_height > 1) and \
           (not hasattr(self, 'pil_map_viewport_image') or self.pil_map_viewport_image is None or viewport_changed_width or viewport_changed_height):
            
            if map_canvas_widget.winfo_ismapped(): # Ensure it's actually visible
                self.debug("[DEBUG] _on_map_canvas_configure: Calling draw_map_canvas() due to size change or initial setup.")
                self.draw_map_canvas() 
                self.draw_minimap()    
            else:
                self.debug("[DEBUG] _on_map_canvas_configure: Map canvas not mapped, draw call skipped despite size change.")
        else:
            self.debug(f"[DEBUG] _on_map_canvas_configure: No significant size change or canvas too small/not ready. W={new_width}, H={new_height}, ViewportChangedW={viewport_changed_width}, ViewportChangedH={viewport_changed_height}. Draw call skipped.")


    def _create_add_many_dialog(self, parent, title_text, prompt_text, current_items, max_items_total):
        """
        Helper to create a dialog for 'Add Many...' functionality.
        Returns the number of items to add, or None if cancelled.
        """
        space_available = max_items_total - current_items
        if space_available <= 0:
            messagebox.showinfo(title_text, "The list is already full.", parent=parent)
            return None

        dialog = tk.Toplevel(parent)
        dialog.title(title_text)
        dialog.transient(parent)
        dialog.grab_set()
        dialog.resizable(False, False)

        # Calculate default value for spinbox
        default_val = 8
        if space_available < 8:
            default_val = space_available
        
        # Frame for content
        main_frame = ttk.Frame(dialog, padding="10")
        main_frame.pack(expand=True, fill="both")

        ttk.Label(main_frame, text=prompt_text).pack(pady=(0, 5))

        spinbox_var = tk.IntVar(value=default_val)
        # Spinbox range is 1 to space_available
        spinbox = ttk.Spinbox(
            main_frame, 
            from_=1, 
            to=max(1, space_available), # Ensure 'to' is at least 1 if space_available is 1
            textvariable=spinbox_var, 
            width=5,
            wrap=False # Do not wrap around
        )
        spinbox.pack(pady=5)
        spinbox.focus_set()
        spinbox.selection_range(0, tk.END) # Select current text for easy overwrite

        # Frame for buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(10, 0))

        result = {"value": None} # Use a dictionary to pass result back

        def on_ok():
            try:
                val = spinbox_var.get()
                if 1 <= val <= space_available:
                    result["value"] = val
                    dialog.destroy()
                else:
                    messagebox.showerror("Invalid Input", f"Please enter a number between 1 and {space_available}.", parent=dialog)
            except tk.TclError: # Handles non-integer input if user types garbage
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.", parent=dialog)


        def on_cancel():
            dialog.destroy() # result["value"] remains None

        ok_button = ttk.Button(button_frame, text="OK", command=on_ok, width=8)
        ok_button.pack(side=tk.LEFT, padx=5)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=on_cancel, width=8)
        cancel_button.pack(side=tk.LEFT, padx=5)

        dialog.bind("<Return>", lambda e: on_ok())
        dialog.bind("<Escape>", lambda e: on_cancel())
        
        # Center dialog on parent
        parent.update_idletasks() # Ensure parent geometry is up to date
        dialog.update_idletasks() # Ensure dialog knows its requested size
        
        parent_x = parent.winfo_rootx()
        parent_y = parent.winfo_rooty()
        parent_w = parent.winfo_width()
        parent_h = parent.winfo_height()
        
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = parent_x + (parent_w // 2) - (dialog_w // 2)
        y_pos = parent_y + (parent_h // 2) - (dialog_h // 2)
        
        dialog.geometry(f"+{x_pos}+{y_pos}")

        dialog.wait_window()
        return result["value"]

    def handle_add_many_tiles(self):
        global num_tiles_in_set, current_tile_index, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX 

        if num_tiles_in_set >= MAX_TILES:
            messagebox.showinfo("Add Many Tiles", "Tileset is already full.", parent=self.root)
            return

        space_available = MAX_TILES - num_tiles_in_set
    
        num_to_add = self._create_add_many_dialog(
            parent=self.root, 
            title_text="Add Many Tiles",
            prompt_text=f"How many tiles to add? (1-{space_available})",
            current_items=num_tiles_in_set,
            max_items_total=MAX_TILES
        )

        if num_to_add is None or num_to_add <= 0: 
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass 

        self._mark_project_modified()
    
        first_new_tile_idx = num_tiles_in_set 
    
        for _ in range(num_to_add):
            if num_tiles_in_set < MAX_TILES: 
                if num_tiles_in_set < len(tileset_patterns) and num_tiles_in_set < len(tileset_colors):
                    tileset_patterns[num_tiles_in_set] = [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    tileset_colors[num_tiles_in_set] = [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    num_tiles_in_set += 1
                else:
                    self.debug(f"[DEBUG] handle_add_many_tiles: Error - trying to access beyond list capacity for tile {num_tiles_in_set}")
                    break 
            else:
                break 
        
        current_tile_index = first_new_tile_idx 
    
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        self.scroll_viewers_to_tile(current_tile_index)
        self._update_editor_button_states()
        self._request_color_usage_refresh() # Correctly placed
        self.debug(f"Added {num_to_add} new tiles.")

    def handle_add_many_supertiles(self):
        global num_supertiles, current_supertile_index, supertiles_data # Globals

        if num_supertiles >= MAX_SUPERTILES: 
            messagebox.showinfo("Add Many Supertiles", "Supertile set is already full.", parent=self.root)
            return

        space_available = MAX_SUPERTILES - num_supertiles

        num_to_add = self._create_add_many_dialog(
            parent=self.root,
            title_text="Add Many Supertiles",
            prompt_text=f"How many supertiles to add? (1-{space_available})",
            current_items=num_supertiles,
            max_items_total=MAX_SUPERTILES
        )

        if num_to_add is None or num_to_add <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        self._mark_project_modified()
        
        first_new_st_idx = num_supertiles 
        tiles_changed_due_to_new_sts = False # Track if new STs (referencing tile 0) were added

        for _ in range(num_to_add):
            if num_supertiles < MAX_SUPERTILES:
                if num_supertiles < len(supertiles_data):
                    supertiles_data[num_supertiles] = [
                        [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
                    ]
                    num_supertiles += 1
                    tiles_changed_due_to_new_sts = True # New STs reference tile 0
                else:
                    self.debug(f"[DEBUG] handle_add_many_supertiles: Error - trying to access beyond list capacity for ST {num_supertiles}")
                    break
            else:
                break
        
        current_supertile_index = first_new_st_idx 

        self.supertile_image_cache.clear()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()
        if tiles_changed_due_to_new_sts:
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        self.debug(f"Added {num_to_add} new supertiles.")

    def append_tileset_from_file(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set # Using globals

        if num_tiles_in_set >= MAX_TILES:
            messagebox.showinfo("Append Tileset", "Current project tileset is already full. Cannot append.", parent=self.root)
            return

        load_path = filedialog.askopenfilename(
            master=self.root, # Ensure dialog is modal to the main app
            filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
            title="Select Tileset File to Append",
        )
        if not load_path:
            return # User cancelled

        try:
            temp_loaded_patterns = []
            temp_loaded_colors = []
            tiles_in_file_count = 0

            with open(load_path, "rb") as f:
                # Read header
                num_tiles_header_byte_val = f.read(1)
                if not num_tiles_header_byte_val:
                    raise ValueError("Selected file is empty or missing tile count header.")
                
                header_value = struct.unpack("B", num_tiles_header_byte_val)[0]
                tiles_in_file_count = 256 if header_value == 0 else header_value

                if not (1 <= tiles_in_file_count <= MAX_TILES):
                    raise ValueError(f"Invalid tile count in file header: {tiles_in_file_count}.")

                # Read and discard reserved bytes (expecting v0.0.39 format)
                reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                    # This indicates it's either an old format file missing these bytes,
                    # or a corrupted new one. For append, we strictly expect the new format.
                    raise ValueError(f"File '{os.path.basename(load_path)}' does not appear to be a valid v0.0.39+ format tileset file (missing reserved bytes after header). Please migrate it if it's an older version.")
                
                self.debug(f"Info: Read {tiles_in_file_count} tiles header, skipped {RESERVED_BYTES_COUNT} reserved bytes from appending file.")

                # Read all pattern data from file
                bytes_per_tile_pattern = TILE_HEIGHT
                total_pattern_bytes_to_read = tiles_in_file_count * bytes_per_tile_pattern
                all_pattern_data_bytes = f.read(total_pattern_bytes_to_read)
                if len(all_pattern_data_bytes) < total_pattern_bytes_to_read:
                    raise EOFError("EOF while reading pattern data block from append file.")

                current_byte_offset_pattern = 0
                for _i in range(tiles_in_file_count):
                    tile_pattern_data = [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    tile_pattern_bytes = all_pattern_data_bytes[current_byte_offset_pattern : current_byte_offset_pattern + bytes_per_tile_pattern]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_pattern_bytes[r_idx]
                        for c in range(TILE_WIDTH):
                            pixel_bit = (byte_val >> (7 - c)) & 1
                            tile_pattern_data[r_idx][c] = pixel_bit
                    temp_loaded_patterns.append(tile_pattern_data)
                    current_byte_offset_pattern += bytes_per_tile_pattern
                
                # Read all color data from file
                bytes_per_tile_colors = TILE_HEIGHT
                total_color_bytes_to_read = tiles_in_file_count * bytes_per_tile_colors
                all_color_data_bytes = f.read(total_color_bytes_to_read)
                if len(all_color_data_bytes) < total_color_bytes_to_read:
                    raise EOFError("EOF while reading color data block from append file.")

                current_byte_offset_colors = 0
                for _i in range(tiles_in_file_count):
                    tile_color_data = [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    tile_color_bytes = all_color_data_bytes[current_byte_offset_colors : current_byte_offset_colors + bytes_per_tile_colors]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        if not (0 <= fg_idx < 16 and 0 <= bg_idx < 16):
                            tile_color_data[r_idx] = (WHITE_IDX, BLACK_IDX) # Default on error
                        else:
                            tile_color_data[r_idx] = (fg_idx, bg_idx)
                    temp_loaded_colors.append(tile_color_data)
                    current_byte_offset_colors += bytes_per_tile_colors

            # File reading successful, now handle append logic
            space_available = MAX_TILES - num_tiles_in_set
            num_to_actually_append = tiles_in_file_count # How many we'd like to append

            if tiles_in_file_count > space_available:
                confirm_partial = messagebox.askyesno(
                    "Tileset Limit Reached",
                    f"The selected file contains {tiles_in_file_count} tiles, "
                    f"but there is only space for {space_available} more tiles in the current project (max {MAX_TILES}).\n\n"
                    f"Do you want to append the first {space_available} tiles from the file?",
                    parent=self.root
                )
                if confirm_partial:
                    num_to_actually_append = space_available
                else:
                    self.debug("User cancelled partial tile append.")
                    return # User cancelled
            
            if num_to_actually_append <= 0: # Handles case where space_available was 0 or became 0
                messagebox.showinfo("Append Tileset", "No space available or no tiles to append.", parent=self.root)
                return

            if self._clear_marked_unused(trigger_redraw=False):
                pass

            self._mark_project_modified()
            
            first_appended_tile_idx = num_tiles_in_set # For selection later

            for i in range(num_to_actually_append):
                # These global lists (tileset_patterns, tileset_colors) are assumed to be
                # already allocated to MAX_TILES length. We are writing into the slots.
                if num_tiles_in_set < MAX_TILES: # Final check within loop
                    tileset_patterns[num_tiles_in_set] = temp_loaded_patterns[i]
                    tileset_colors[num_tiles_in_set] = temp_loaded_colors[i]
                    num_tiles_in_set += 1
                else:
                    # Should not be reached if num_to_actually_append logic is correct
                    self.debug("[DEBUG] append_tileset: Exceeded MAX_TILES during append loop unexpectedly.")
                    break 
            
            current_tile_index = first_appended_tile_idx # Select first appended tile

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh()

            final_message = f"Appended {num_to_actually_append} tile(s) from {os.path.basename(load_path)}."
            if num_to_actually_append < tiles_in_file_count:
                final_message += f"\n({tiles_in_file_count - num_to_actually_append} tiles from file were not appended due to limit.)"
            messagebox.showinfo("Append Successful", final_message, parent=self.root)

        except FileNotFoundError:
            messagebox.showerror("Append Error", f"File not found:\n{load_path}", parent=self.root)
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Append Tileset Error",
                f"Invalid data or format in tileset file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
        except Exception as e:
            messagebox.showerror(
                "Append Tileset Error",
                f"Failed to append tileset from '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )

    def _confirm_supertile_import_with_broken_refs(self, parent_dialog, supertile_def_to_render, original_st_index_in_file, num_tiles_actually_staged, original_starting_tile_idx_in_project):
        """
        Placeholder for a dialog that shows a supertile with broken refs and asks for confirmation.
        For now, uses a simpler messagebox.askyesnocancel.
        A proper implementation would render the supertile visually with error masks.

        Args:
            parent_dialog: The parent window for this dialog (e.g., self.root).
            supertile_def_to_render: The 2D list of remapped tile indices (where broken ones are already 0).
            original_st_index_in_file: The index of this supertile in the source file (for user message).
            num_tiles_actually_staged: How many tiles were successfully read from the linked .SC4Tiles.
            original_starting_tile_idx_in_project: The project index where tiles from the pack started.

        Returns:
            str: "import", "skip", or "cancel_all"
        """
        self.debug(f"[DEBUG] Confirming ST import: Original ST index {original_st_index_in_file} from file.")
        # In a full implementation, render supertile_def_to_render here,
        # highlighting cells that were remapped to 0 due to original index T_orig >= num_tiles_actually_staged.

        title = "Supertile Import Confirmation"
        message = (
            f"Supertile {original_st_index_in_file} (from file) references tiles that could not be fully imported "
            f"from its associated tileset (due to project tileset limits).\n\n"
            f"These broken tile references within this supertile have been set to use Project Tile 0.\n\n"
            f"Do you want to import this supertile with these adjustments?"
        )
        
        # Using a custom dialog setup for three distinct return values
        dialog = tk.Toplevel(parent_dialog)
        dialog.title(title)
        dialog.transient(parent_dialog)
        dialog.grab_set()
        dialog.resizable(False, False)

        result = {"action": "cancel_all"} # Default to cancel if window closed

        label = ttk.Label(dialog, text=message, wraplength=400, justify=tk.LEFT)
        label.pack(padx=20, pady=10)

        # TODO: Add visual rendering of the supertile_def_to_render here
        # For now, it's just a text confirmation.
        # Example:
        # preview_canvas = tk.Canvas(dialog, width=self.supertile_grid_width*32, height=self.supertile_grid_height*32, bg="lightgrey")
        # preview_canvas.pack(pady=5)
        # ... logic to draw the supertile_def_to_render onto preview_canvas ...
        # You would need to pass self.supertile_grid_width/height or get them
        # And use logic similar to create_supertile_image, but also indicate broken refs.

        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10, padx=10, fill=tk.X)
        button_frame.grid_columnconfigure(0, weight=1) # For centering buttons
        button_frame.grid_columnconfigure(1, weight=1)
        button_frame.grid_columnconfigure(2, weight=1)


        def set_action(action_val):
            result["action"] = action_val
            dialog.destroy()

        import_button = ttk.Button(button_frame, text="Import This Supertile", command=lambda: set_action("import"))
        import_button.grid(row=0, column=0, padx=5, sticky="ew")

        skip_button = ttk.Button(button_frame, text="Skip This Supertile", command=lambda: set_action("skip"))
        skip_button.grid(row=0, column=1, padx=5, sticky="ew")
        
        cancel_all_button = ttk.Button(button_frame, text="Cancel All Appending", command=lambda: set_action("cancel_all"))
        cancel_all_button.grid(row=0, column=2, padx=5, sticky="ew")

        dialog.bind("<Escape>", lambda e: set_action("cancel_all")) # Escape cancels all

        # Center dialog
        parent_dialog.update_idletasks()
        dialog.update_idletasks()
        px, py, pw, ph = parent_dialog.winfo_rootx(), parent_dialog.winfo_rooty(), parent_dialog.winfo_width(), parent_dialog.winfo_height()
        dw, dh = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
        dialog.geometry(f"{dw}x{dh}+{px + (pw - dw)//2}+{py + (ph - dh)//2}")


        dialog.wait_window()
        return result["action"]

    def append_supertiles_from_file(self):
        global supertiles_data, num_supertiles, tileset_patterns, tileset_colors, num_tiles_in_set 
        global current_supertile_index, current_tile_index 

        st_load_path = filedialog.askopenfilename(
            master=self.root,
            filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
            title="Select Supertile File to Append",
        )
        if not st_load_path:
            return 

        st_dir, st_filename = os.path.split(st_load_path)
        st_basename, _ = os.path.splitext(st_filename)
        tile_load_path = os.path.join(st_dir, f"{st_basename}.SC4Tiles")

        if not os.path.exists(tile_load_path):
            messagebox.showerror("Append Error", 
                                 f"Associated tileset file '{os.path.basename(tile_load_path)}' not found in the same directory. "
                                 "This operation requires it to append supertiles and their referenced tiles together.",
                                 parent=self.root)
            return

        file_st_grid_w, file_st_grid_h, file_st_count = 0,0,0
        file_tile_count = 0

        try: 
            with open(st_load_path, "rb") as f_st:
                first_count_byte = f_st.read(1)
                if not first_count_byte: raise ValueError("Supertile file empty.")
                indicator = struct.unpack("B", first_count_byte)[0]
                header_size_st_count = 1
                if indicator == 0:
                    count_short_bytes = f_st.read(2)
                    if len(count_short_bytes) < 2: raise EOFError("EOF for ST count.")
                    file_st_count = struct.unpack(">H", count_short_bytes)[0]
                    header_size_st_count = 3
                else:
                    file_st_count = indicator
                
                dim_w_byte, dim_h_byte = f_st.read(1), f_st.read(1)
                if not dim_w_byte or not dim_h_byte: raise EOFError("EOF for ST dimensions.")
                file_st_grid_w = struct.unpack("B", dim_w_byte)[0]
                file_st_grid_h = struct.unpack("B", dim_h_byte)[0]
            
            with open(tile_load_path, "rb") as f_tile:
                header_byte = f_tile.read(1)
                if not header_byte: raise ValueError("Tileset file empty.")
                val = struct.unpack("B", header_byte)[0]
                file_tile_count = 256 if val == 0 else val

        except Exception as e:
            messagebox.showerror("Append Error", f"Error reading file headers:\n{e}", parent=self.root)
            return

        if file_st_grid_w != self.supertile_grid_width or file_st_grid_h != self.supertile_grid_height:
            messagebox.showerror("Append Error",
                                 f"Cannot append. Supertile dimensions in file ({file_st_grid_w}x{file_st_grid_h}) "
                                 f"do not match current project's dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}).",
                                 parent=self.root)
            return
        
        if file_st_count == 0:
             messagebox.showinfo("Append Supertiles", "The selected supertile file contains no supertile definitions to append.", parent=self.root)
             return

        st_space_available = MAX_SUPERTILES - num_supertiles
        tile_space_available = MAX_TILES - num_tiles_in_set

        if st_space_available <= 0:
            messagebox.showinfo("Append Supertiles", "Current project supertile set is full. Cannot append.", parent=self.root)
            return
        # Allow appending STs even if tile space is full, if file_tile_count is 0 or refs are handled
        # The main check is if associated tiles *needed* from file can fit.

        num_st_to_attempt_append = min(file_st_count, st_space_available)
        num_tiles_to_attempt_append_from_file = 0
        if file_tile_count > 0 : # Only consider appending tiles if the file has them
            num_tiles_to_attempt_append_from_file = min(file_tile_count, tile_space_available)


        if num_st_to_attempt_append < file_st_count or (file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count):
            warn_msg = "Warning: Project limits might be reached.\n\n"
            if file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count:
                warn_msg += f"Tiles: Will attempt to append {num_tiles_to_attempt_append_from_file} of {file_tile_count} from '{os.path.basename(tile_load_path)}'.\n"
            if num_st_to_attempt_append < file_st_count:
                warn_msg += f"Supertiles: Will attempt to append {num_st_to_attempt_append} of {file_st_count} from '{os.path.basename(st_filename)}'.\n"
            warn_msg += "\nPartial tile appending may lead to broken references in some supertiles (you will be asked to confirm these individually).\n\nProceed with appending?"
            if not messagebox.askyesno("Confirm Partial Append", warn_msg, icon="warning", parent=self.root):
                self.debug("User cancelled overall partial append.")
                return
        
        if num_st_to_attempt_append == 0 : 
            messagebox.showinfo("Append Supertiles", "No supertiles to append after considering limits.", parent=self.root)
            return
        
        temp_appended_tile_patterns = []
        temp_appended_tile_colors = []
        original_starting_tile_index_in_project = num_tiles_in_set 
        num_tiles_actually_staged_from_file = 0

        if file_tile_count > 0 and num_tiles_to_attempt_append_from_file > 0:
            try:
                with open(tile_load_path, "rb") as f_tile:
                    _ = f_tile.read(1) 
                    _ = f_tile.read(RESERVED_BYTES_COUNT) 

                    bytes_per_tile_pattern = TILE_HEIGHT
                    all_pattern_bytes = f_tile.read(file_tile_count * bytes_per_tile_pattern)
                    
                    bytes_per_tile_colors = TILE_HEIGHT
                    all_color_bytes = f_tile.read(file_tile_count * bytes_per_tile_colors)

                    if len(all_pattern_bytes) < file_tile_count * bytes_per_tile_pattern or \
                       len(all_color_bytes) < file_tile_count * bytes_per_tile_colors:
                        raise EOFError("Could not read all tile data from linked tileset file.")

                    pat_offset, col_offset = 0,0
                    for i_tile_file in range(file_tile_count): # Iterate all tiles in file
                        if i_tile_file >= num_tiles_to_attempt_append_from_file: # Only stage up to allowed amount
                            break
                        
                        tile_pat = [[0]*TILE_WIDTH for _ in range(TILE_HEIGHT)]
                        tile_col = [(WHITE_IDX,BLACK_IDX)]*TILE_HEIGHT
                        
                        tile_pattern_bytes_slice = all_pattern_bytes[pat_offset : pat_offset + bytes_per_tile_pattern]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_pattern_bytes_slice[r]
                            for c in range(TILE_WIDTH): tile_pat[r][c] = (byte_val >> (7-c)) & 1
                        temp_appended_tile_patterns.append(tile_pat)
                        pat_offset += bytes_per_tile_pattern

                        tile_color_bytes_slice = all_color_bytes[col_offset : col_offset + bytes_per_tile_colors]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_color_bytes_slice[r]
                            fg,bg = (byte_val >> 4)&0xF, byte_val&0xF
                            tile_col[r] = (fg if 0<=fg<16 else WHITE_IDX, bg if 0<=bg<16 else BLACK_IDX)
                        temp_appended_tile_colors.append(tile_col)
                        col_offset += bytes_per_tile_colors
                        num_tiles_actually_staged_from_file +=1
            except Exception as e:
                messagebox.showerror("Append Error", f"Error reading data from linked tileset file '{os.path.basename(tile_load_path)}':\n{e}", parent=self.root)
                return
        self.debug(f"Staged {num_tiles_actually_staged_from_file} tiles for appending.")

        temp_appended_supertile_definitions = []
        supertiles_skipped_count = 0
        operation_fully_cancelled = False
        st_data_changed_flag = False 

        try:
            with open(st_load_path, "rb") as f_st:
                # Re-read header to position file pointer correctly
                _ = f_st.read(1) 
                if indicator == 0: _ = f_st.read(2) 
                _ = f_st.read(1) # dim_w
                _ = f_st.read(1) # dim_h
                _ = f_st.read(RESERVED_BYTES_COUNT) 

                tiles_in_one_def = self.supertile_grid_width * self.supertile_grid_height
                bytes_per_def = tiles_in_one_def 

                for st_file_idx in range(file_st_count): 
                    st_def_bytes = f_st.read(bytes_per_def)
                    if len(st_def_bytes) < bytes_per_def:
                        # This might happen if file_st_count was larger than actual defs in file
                        self.debug(f"Warning: EOF reading definition for ST index {st_file_idx} from file. Expected more data.")
                        break 
                    
                    if st_file_idx >= num_st_to_attempt_append: 
                        self.debug(f"Reached limit of STs to append ({num_st_to_attempt_append}). Stopping ST processing.")
                        break 

                    current_st_def_remapped = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                    has_broken_refs = False
                    byte_ptr = 0
                    for r_st_def in range(self.supertile_grid_height):
                        for c_st_def in range(self.supertile_grid_width):
                            t_orig_from_file = st_def_bytes[byte_ptr] # Tile index from the .SC4Super file
                            byte_ptr += 1
                            t_new_project_idx = 0 # Default if broken
                            if t_orig_from_file >= num_tiles_actually_staged_from_file: 
                                has_broken_refs = True
                                t_new_project_idx = 0 
                            else:
                                # Map file's tile index to its new index in the project
                                t_new_project_idx = t_orig_from_file + original_starting_tile_index_in_project
                            current_st_def_remapped[r_st_def][c_st_def] = t_new_project_idx
                    
                    if has_broken_refs:
                        user_choice = self._confirm_supertile_import_with_broken_refs(
                            self.root, current_st_def_remapped, st_file_idx, 
                            num_tiles_actually_staged_from_file, original_starting_tile_index_in_project
                        )
                        if user_choice == "import":
                            temp_appended_supertile_definitions.append(current_st_def_remapped)
                            st_data_changed_flag = True
                        elif user_choice == "skip":
                            supertiles_skipped_count += 1
                        elif user_choice == "cancel_all":
                            operation_fully_cancelled = True
                            break 
                    else: 
                        temp_appended_supertile_definitions.append(current_st_def_remapped)
                        st_data_changed_flag = True
            
            if operation_fully_cancelled:
                self.debug("Append supertiles operation cancelled by user during ST confirmation.")
                messagebox.showinfo("Append Cancelled", "Append operation cancelled.", parent=self.root)
                return

        except Exception as e:
            messagebox.showerror("Append Error", f"Error processing supertile file '{os.path.basename(st_load_path)}':\n{e}", parent=self.root)
            return

        if not temp_appended_tile_patterns and not temp_appended_supertile_definitions:
            messagebox.showinfo("Append Supertiles", "No new tiles or supertiles were ultimately appended.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False): pass
        self._mark_project_modified()

        appended_tiles_actual_count = 0
        if num_tiles_actually_staged_from_file > 0:
            for i_append_tile in range(num_tiles_actually_staged_from_file): # Iterate only staged tiles
                if num_tiles_in_set < MAX_TILES:
                    tileset_patterns[num_tiles_in_set] = temp_appended_tile_patterns[i_append_tile]
                    tileset_colors[num_tiles_in_set] = temp_appended_tile_colors[i_append_tile]
                    num_tiles_in_set += 1
                    appended_tiles_actual_count +=1
                else: break
        
        appended_st_actual_count = 0
        if temp_appended_supertile_definitions:
            first_new_st_idx_project = num_supertiles
            for st_def_to_add in temp_appended_supertile_definitions: # Iterate only STs confirmed for import
                if num_supertiles < MAX_SUPERTILES:
                    supertiles_data[num_supertiles] = st_def_to_add
                    num_supertiles += 1
                    appended_st_actual_count +=1
                else: break
            if appended_st_actual_count > 0: 
                current_supertile_index = first_new_st_idx_project

        if appended_tiles_actual_count > 0:
             current_tile_index = original_starting_tile_index_in_project

        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        if appended_tiles_actual_count > 0 : self.scroll_viewers_to_tile(current_tile_index)
        if appended_st_actual_count > 0 : self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()
        
        if appended_tiles_actual_count > 0 or appended_st_actual_count > 0:
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        summary_msg = f"Successfully appended {appended_tiles_actual_count} tile(s) and {appended_st_actual_count} supertile(s)."
        if supertiles_skipped_count > 0:
            summary_msg += f"\n{supertiles_skipped_count} supertile(s) from the file were skipped by user."
        if num_st_to_attempt_append < file_st_count and appended_st_actual_count < num_st_to_attempt_append :
             summary_msg += f"\nNote: Supertile limit may have prevented appending all desired supertiles."
        if file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count and appended_tiles_actual_count < num_tiles_to_attempt_append_from_file:
             summary_msg += f"\nNote: Tileset limit may have prevented appending all desired tiles."

        messagebox.showinfo("Append Successful", summary_msg, parent=self.root)


    def _on_mousewheel_scroll(self, event):
        # Generic handler for mousewheel vertical scrolling on canvases.
        canvas = event.widget
        if not canvas.winfo_exists():
            return

        scroll_units = 0
        if event.num == 5 or event.delta < 0:  # Scroll Down
            scroll_units = self.scroll_speed_units
        elif event.num == 4 or event.delta > 0: # Scroll Up
            scroll_units = -self.scroll_speed_units

        if scroll_units != 0:
            try:
                current_view_before_scroll = canvas.yview() # Get view before scroll
                canvas.yview_scroll(scroll_units, "units")
                current_view_after_scroll = canvas.yview()  # Get view after scroll

                # Only redraw if the view actually changed.
                if current_view_before_scroll != current_view_after_scroll:
                    # Identify the canvas and call its specific redraw method
                    if canvas == self.tileset_canvas:
                        self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
                    elif canvas == self.st_tileset_canvas:
                        self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                    elif canvas == self.supertile_selector_canvas:
                        self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                    elif canvas == self.map_canvas:
                        if not (event.state & 0x0004): # If Ctrl key is NOT pressed (mask for Control is 4)
                            self.draw_map_canvas()
                            self.draw_minimap() 
                    elif canvas == self.map_supertile_selector_canvas:
                        self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
                    elif hasattr(self, 'rom_import_dialog') and \
                         self.rom_import_dialog and \
                         tk.Toplevel.winfo_exists(self.rom_import_dialog) and \
                         canvas == getattr(self.rom_import_dialog, 'canvas', None):
                        self.debug("[DEBUG] Mousewheel scroll on ROM importer, scheduling direct redraw.")
                        self._schedule_debounced_draw_from_scroll_rom_direct()
                else:
                    self.debug(f"[DEBUG] Scroll attempted on {canvas} but view did not change (likely at limit). No redraw triggered.")

            except tk.TclError as e:
                self.debug(f"[DEBUG] TclError during yview_scroll/redraw: {e}")
            except Exception as e:
                self.debug(f"[DEBUG] Unexpected error during yview_scroll/redraw: {e}")
        return "break"

    def _schedule_debounced_draw_from_scroll_rom_direct(self):
        # Helper to schedule the debounced draw for the ROM importer canvas.
        current_dialog = getattr(self, 'rom_import_dialog', None)
        if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
        if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

        if current_dialog.redraw_timer_id is not None:
            try:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            except tk.TclError:
                pass # Timer might have already fired
        current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

    def _calculate_color_usage_data(self):
        # Calculates usage counts for each of the 16 active palette slots.
        # It calls the granular _calculate_single_color_usage for each slot.
        results = []
        if not self.active_msx_palette or len(self.active_msx_palette) != 16:
            self.debug("[DEBUG] _calculate_color_usage_data: Active MSX palette is not ready.")
            # Return placeholder data if palette is invalid
            for i in range(16):
                results.append({
                    'slot_index': i,
                    'current_color_hex': "#FF00FF",
                    'pixel_uses_count': 0,
                    'line_refs_count': 0,
                    'tile_refs_count': 0
                })
            return results

        for p_idx in range(16): # For each of the 16 palette slots
            current_color_hex = self.active_msx_palette[p_idx]
            
            # Use the new helper to get all usage stats for this slot
            pixel_uses, line_refs, tile_refs = self._calculate_single_color_usage(p_idx)

            results.append({
                'slot_index': p_idx,
                'current_color_hex': current_color_hex,
                'pixel_uses_count': pixel_uses,
                'line_refs_count': line_refs,
                'tile_refs_count': tile_refs
            })
            
        return results

    def toggle_color_usage_window(self):
        # Toggles the visibility of the Color Usage window.
        if self.color_usage_window is None or not tk.Toplevel.winfo_exists(self.color_usage_window):
            self.debug("[DEBUG] Creating new Color Usage window.")
            self.color_usage_window = ColorUsageWindow(self) # Pass self (the app instance)
        else:
            self.debug("[DEBUG] Lifting existing Color Usage window.")
            self.color_usage_window.lift()
            self.color_usage_window.focus_set()
            if hasattr(self.color_usage_window, 'refresh_data'): # If it has a refresh method
                self.color_usage_window.refresh_data() # Refresh when brought to front

    def synchronize_selection_from_usage_window(self, item_type, index):
        self.debug(f"\n[DEBUG] Synchronizing from USAGE WINDOW: type='{item_type}', index={index}")
        global selected_color_index, current_tile_index, selected_tile_for_supertile 
        global current_supertile_index, selected_supertile_for_map 
        global num_tiles_in_set, num_supertiles 

        if item_type == "color":
            # ... (existing color logic - assuming it's okay for now) ...
            if not (0 <= index <= 15):
                self.debug(f"  [DEBUG] Invalid color slot index {index}. Sync aborted.")
                return

            try:
                current_tab_widget = None
                if self.notebook.winfo_exists():
                    selected_tab_path = self.notebook.select()
                    if selected_tab_path:
                        current_tab_widget = self.notebook.nametowidget(selected_tab_path)

                self.selected_palette_slot = index
                selected_color_index = index 
                
                if current_tab_widget != self.tab_tile_editor and \
                   current_tab_widget != self.tab_palette_editor:
                    self.debug(f"  [DEBUG] Color sync: Current tab is not Tile/Palette Editor. Switching to Palette Editor.")
                    if self.notebook.winfo_exists() and self.tab_palette_editor.winfo_exists():
                        self.notebook.select(self.tab_palette_editor)
                        self.root.update_idletasks() # Allow tab switch to process
                    else:
                        self.debug("  [DEBUG] Sync: Palette editor tab or notebook not available for switch.")
                
                self.debug(f"  [DEBUG] Color sync: Calling update_all_displays(all).")
                self.update_all_displays(changed_level="all") 
                self.root.lift()
                self.debug(f"  [DEBUG] Color sync: Finished.")

            except tk.TclError as e:
                self.debug(f"  [DEBUG] TclError during color selection synchronization: {e}")
            except Exception as e:
                self.debug(f"  [DEBUG] Unexpected error during color selection synchronization: {e}")

        elif item_type == "tile":
            # ... (existing tile logic - assuming it's okay for now) ...
            if not (0 <= index < num_tiles_in_set): 
                self.debug(f"  [DEBUG] Invalid tile index {index} (num_tiles_in_set: {num_tiles_in_set}). Sync aborted.")
                return
            
            try:
                active_tab_widget = None
                if self.notebook.winfo_exists():
                    selected_tab_path = self.notebook.select()
                    if selected_tab_path:
                        active_tab_widget = self.notebook.nametowidget(selected_tab_path)
                self.debug(f"  [DEBUG] Tile sync: Current active tab widget: {active_tab_widget}")

                # Update selections first
                current_tile_index = index # Always update this for Tile Editor
                if active_tab_widget == self.tab_supertile_editor:
                    self.debug(f"  [DEBUG] Tile sync: Supertile Editor tab active. Updating its tile selection to {index}.")
                    selected_tile_for_supertile = index
                # else:
                    # For other tabs, like Palette or Map, we might also want selected_tile_for_supertile to follow
                    # This ensures consistency if user switches back to ST editor
                    # selected_tile_for_supertile = index 
                    # For now, let's assume current_tile_index is the primary one to sync if not on ST editor.


                # Switch to Tile Editor tab if not already there or on Supertile Editor
                if active_tab_widget != self.tab_tile_editor and active_tab_widget != self.tab_supertile_editor:
                    self.debug(f"  [DEBUG] Tile sync: Current tab is not Tile/Supertile Editor. Switching to Tile Editor.")
                    if self.notebook.winfo_exists() and self.tab_tile_editor.winfo_exists():
                        self.notebook.select(self.tab_tile_editor)
                        self.root.update_idletasks() # Allow tab switch to process
                    else:
                        self.debug("  [DEBUG] Sync: Tile editor tab or notebook not available for switch.")
                
                self.debug(f"  [DEBUG] Tile sync: Calling update_all_displays(all).")
                self.update_all_displays(changed_level="all") # This will draw based on current (possibly new) tab
                
                self.debug(f"  [DEBUG] Tile sync: Calling scroll_viewers_to_tile({index}).")
                self.scroll_viewers_to_tile(index) 
                
                self.root.lift() 
                self.debug(f"  [DEBUG] Tile sync: Finished.")

            except tk.TclError as e:
                self.debug(f"  [DEBUG] TclError during tile selection synchronization: {e}")
            except Exception as e:
                self.debug(f"  [DEBUG] Unexpected error during tile selection synchronization: {e}")

        elif item_type == "supertile":
            if not (0 <= index < num_supertiles):
                self.debug(f"  [DEBUG] Invalid supertile index {index} (num_supertiles: {num_supertiles}). Sync aborted.")
                return
            
            try:
                self.debug(f"  [DEBUG] ST Sync: Starting for index {index}.")
                # 1. Update model state (the selected indices)
                current_supertile_index = index    # For Supertile Editor tab's main selection
                selected_supertile_for_map = index # For Map Editor tab's palette selection
                self.debug(f"  [DEBUG] ST Sync: Updated current_supertile_index to {current_supertile_index}, selected_supertile_for_map to {selected_supertile_for_map}.")

                # 2. Determine target tab and switch if necessary
                active_tab_widget_before_switch = None
                if self.notebook.winfo_exists():
                    selected_tab_path = self.notebook.select()
                    if selected_tab_path:
                        active_tab_widget_before_switch = self.notebook.nametowidget(selected_tab_path)
                
                target_tab_to_ensure_visible = self.tab_supertile_editor # Default to ST editor
                if active_tab_widget_before_switch == self.tab_map_editor:
                    target_tab_to_ensure_visible = self.tab_map_editor # Stay on map editor if already there
                
                self.debug(f"  [DEBUG] ST Sync: Active tab before switch: {active_tab_widget_before_switch}")
                self.debug(f"  [DEBUG] ST Sync: Target tab to ensure visible: {target_tab_to_ensure_visible}")

                if active_tab_widget_before_switch != target_tab_to_ensure_visible:
                    if self.notebook.winfo_exists() and target_tab_to_ensure_visible.winfo_exists():
                        self.debug(f"  [DEBUG] ST Sync: Switching to target tab.")
                        self.notebook.select(target_tab_to_ensure_visible)
                        self.root.update_idletasks() # Crucial: Allow tab switch and geometry updates to process
                        self.debug(f"  [DEBUG] ST Sync: Tab switched and idletasks updated.")
                    else:
                        self.debug(f"  [DEBUG] ST Sync: Target tab or notebook not available for switch. Problems may occur.")
                
                # 3. Call update_all_displays. This will redraw the content of the *now active* tab.
                #    It should use the updated selection indices.
                self.debug(f"  [DEBUG] ST Sync: Calling update_all_displays(all). This should redraw the active tab's selector with correct highlight.")
                self.update_all_displays(changed_level="all") 
                # self.root.update_idletasks() # Let draw operations from update_all_displays complete

                # 4. Call scroll_selectors_to_supertile. This will now operate on the
                #    selector of the (potentially newly) active and drawn tab.
                self.debug(f"  [DEBUG] ST Sync: Calling scroll_selectors_to_supertile({index}).")
                self.scroll_selectors_to_supertile(index)
                # self.root.update_idletasks() # Let scroll operations complete

                # 5. If the scroll happened, the selector items might need to be redrawn *again*
                #    for the new viewport if `scroll_selectors_to_supertile` itself doesn't redraw.
                #    However, our modified `scroll_selectors_to_supertile` doesn't redraw.
                #    The `draw_supertile_selector` is called by `update_all_displays` (step 3).
                #    The crucial part is that the scroll in step 4 happens *after* the draw from step 3.
                #    So, we need a final redraw *after* the scroll.

                self.debug(f"  [DEBUG] ST Sync: Performing a final targeted redraw of the active selector AFTER scrolling.")
                if target_tab_to_ensure_visible == self.tab_supertile_editor:
                    if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                        self.debug(f"    [DEBUG] Redrawing SupertileTabSelector for ST {current_supertile_index}")
                        self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                elif target_tab_to_ensure_visible == self.tab_map_editor:
                    if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                        self.debug(f"    [DEBUG] Redrawing MapTabSelector for ST {selected_supertile_for_map}")
                        self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
                
                self.root.lift()
                self.debug(f"  [DEBUG] ST Sync: Finished for index {index}.")

            except tk.TclError as e:
                self.debug(f"  [DEBUG] TclError during supertile selection synchronization: {e}")
            except Exception as e:
                self.debug(f"  [DEBUG] Unexpected error during supertile selection synchronization: {e}")
        else:
            self.debug(f"  [DEBUG] Unknown item_type '{item_type}' for synchronization.")

    def _request_color_usage_refresh(self):
        # Helper to request a refresh of the color usage window if it's open.
        if self.color_usage_window and \
           tk.Toplevel.winfo_exists(self.color_usage_window) and \
           self.color_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.color_usage_window, 'request_refresh'):
                self.color_usage_window.request_refresh()
            else:
                self.debug("[DEBUG] ColorUsageWindow does not have request_refresh method.")
        # else: window doesn't exist or isn't visible, no action.

    def _handle_editor_paint_release(self, event):
        # Called on ButtonRelease-1 from the tile editor canvas
        global last_drawn_pixel # Assuming last_drawn_pixel is a module-level global
        
        if self.is_currently_painting_tile:
            self.debug("[DEBUG] Tile paint drag finished, requesting final color usage refresh.")
            self._request_color_usage_refresh()
            self.is_currently_painting_tile = False
        last_drawn_pixel = None # Reset for next click/drag

    def _calculate_tile_usage_data(self):
        # Calculates usage counts for each tile in the current tileset by
        # calling the new, granular _calculate_single_tile_usage method.
        results = []
        # Iterate only up to the current number of active tiles
        for t_idx in range(num_tiles_in_set):
            # Call the new helper to get the counts for this specific tile
            total_uses, unique_sts = self._calculate_single_tile_usage(t_idx)
            
            # Append the results in the dictionary format expected by the TileUsageWindow
            results.append({
                'tile_index': t_idx,
                'total_uses_count': total_uses,
                'used_by_sts_count': unique_sts
            })
        return results

    def toggle_tile_usage_window(self):
        # Toggles the visibility of the Tile Usage window.
        if self.tile_usage_window is None or not tk.Toplevel.winfo_exists(self.tile_usage_window):
            self.debug("[DEBUG] Creating new Tile Usage window.")
            self.tile_usage_window = TileUsageWindow(self) # Pass self (the app instance)
        else:
            # Window exists, lift and focus it.
            self.debug("[DEBUG] Lifting existing Tile Usage window.")
            self.tile_usage_window.lift()
            self.tile_usage_window.focus_set()

    def _request_tile_usage_refresh(self):
        # Helper to request a refresh of the tile usage window if it's open.
        if self.tile_usage_window and \
           tk.Toplevel.winfo_exists(self.tile_usage_window) and \
           self.tile_usage_window.winfo_ismapped():
            if hasattr(self.tile_usage_window, 'request_refresh'):
                self.tile_usage_window.request_refresh()
            else:
                self.debug("[DEBUG] TileUsageWindow does not have request_refresh method.")

    def _request_tile_usage_refresh(self):
        # Helper to request a refresh of the tile usage window if it's open and visible.
        if self.tile_usage_window and \
           tk.Toplevel.winfo_exists(self.tile_usage_window) and \
           self.tile_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.tile_usage_window, 'request_refresh'):
                self.tile_usage_window.request_refresh()
            else:
                self.debug("[DEBUG] TileUsageWindow does not have request_refresh method.")
        # else: window doesn't exist or isn't visible, no action.

    def toggle_supertile_usage_window(self):
        if self.supertile_usage_window is None or not tk.Toplevel.winfo_exists(self.supertile_usage_window):
            self.debug("[DEBUG] Creating new Supertile Usage window.")
            self.supertile_usage_window = SupertileUsageWindow(self)
        else:
            self.debug("[DEBUG] Lifting existing Supertile Usage window.")
            self.supertile_usage_window.lift()
            self.supertile_usage_window.focus_set()

    def _calculate_supertile_usage_data(self):
        # Calculates usage counts for each supertile in the current project.
        # Returns a list of dictionaries.
        global map_data, map_width, map_height, num_supertiles # Using globals

        results = []
        # Iterate only up to the current number of active supertiles
        for st_idx in range(num_supertiles): 
            uses_on_map = 0
            for r_map in range(map_height):
                for c_map in range(map_width):
                    if 0 <= r_map < len(map_data) and 0 <= c_map < len(map_data[r_map]):
                        if map_data[r_map][c_map] == st_idx:
                            uses_on_map += 1
                    else:
                        # Should not happen if map_data is consistent with map_width/height
                        self.app_ref.debug(f"[DEBUG] _calc_supertile_usage: Map data access out of bounds for ({r_map},{c_map})")
            
            results.append({
                'st_index': st_idx,
                'uses_on_map_count': uses_on_map
            })
        return results

    def _request_supertile_usage_refresh(self):
        # Helper to request a refresh of the supertile usage window if it's open and visible.
        if self.supertile_usage_window and \
           tk.Toplevel.winfo_exists(self.supertile_usage_window) and \
           self.supertile_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.supertile_usage_window, 'request_refresh'):
                self.supertile_usage_window.request_refresh()
            else:
                self.debug("[DEBUG] SupertileUsageWindow does not have request_refresh method.")
        # else: window doesn't exist or isn't visible, no action.

    def create_cropped_supertile_preview_for_usage_window(self, supertile_index, 
                                                          # target_image_content_area_width is the available space in col #0
                                                          target_image_content_area_width_in_col0, 
                                                          final_photo_target_height): 
        # --- Part 1: Calculate actual scaled dimensions of the supertile content ---
        actual_content_msx_w = self.supertile_grid_width * TILE_WIDTH
        actual_content_msx_h = self.supertile_grid_height * TILE_HEIGHT

        temp_full_photo_w = actual_content_msx_w * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        temp_full_photo_h = actual_content_msx_h * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        
        temp_full_photo_w = max(1, int(temp_full_photo_w))
        temp_full_photo_h = max(1, int(temp_full_photo_h))

        # --- Part 2: Create temp_full_photo with actual scaled content dimensions ---
        try:
            temp_full_photo = tk.PhotoImage(width=temp_full_photo_w, height=temp_full_photo_h)
        except tk.TclError as e:
            self.debug(f"[DEBUG] Error creating temp_full_photo ({temp_full_photo_w}x{temp_full_photo_h}): {e}")
            # Fallback placeholder if temp_full_photo creation fails
            placeholder_w = max(1, int(target_image_content_area_width_in_col0))
            placeholder_h = max(1, int(final_photo_target_height))
            ph_photo = tk.PhotoImage(width=placeholder_w, height=placeholder_h)
            try:
                ph_photo.put(INVALID_SUPERTILE_COLOR, to=(0, 0, placeholder_w, placeholder_h))
            except tk.TclError: pass
            return ph_photo

        # --- Part 3: Render supertile content onto temp_full_photo ---
        # (This extensive rendering logic remains the same as in Step 12/ your last working version of it)
        if not (0 <= supertile_index < num_supertiles):
            temp_full_photo.put(INVALID_SUPERTILE_COLOR, to=(0,0, temp_full_photo_w, temp_full_photo_h))
        else:
            definition = supertiles_data[supertile_index]
            if not (definition and 
                    len(definition) == self.supertile_grid_height and
                    (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
                temp_full_photo.put(INVALID_SUPERTILE_COLOR, to=(0,0, temp_full_photo_w, temp_full_photo_h))
            else:
                # No initial green fill here; temp_full_photo should be fully covered by actual content or error colors
                px_per_base_tile_w_on_temp = TILE_WIDTH * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
                px_per_base_tile_h_on_temp = TILE_HEIGHT * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL

                for r_st_def in range(self.supertile_grid_height):
                    for c_st_def in range(self.supertile_grid_width):
                        tile_idx_val = definition[r_st_def][c_st_def]
                        base_tile_draw_x = int(c_st_def * px_per_base_tile_w_on_temp)
                        base_tile_draw_y = int(r_st_def * px_per_base_tile_h_on_temp)

                        if not (0 <= tile_idx_val < num_tiles_in_set):
                            for y_fill_inv in range(int(px_per_base_tile_h_on_temp)):
                                for x_fill_inv in range(int(px_per_base_tile_w_on_temp)):
                                    dest_x_inv = base_tile_draw_x + x_fill_inv
                                    dest_y_inv = base_tile_draw_y + y_fill_inv
                                    if dest_x_inv < temp_full_photo_w and dest_y_inv < temp_full_photo_h:
                                        temp_full_photo.put(INVALID_TILE_COLOR, to=(dest_x_inv, dest_y_inv))
                            continue
                        pattern = tileset_patterns[tile_idx_val]
                        colors = tileset_colors[tile_idx_val]
                        for r_msx in range(TILE_HEIGHT): 
                            fg_idx, bg_idx = WHITE_IDX, BLACK_IDX 
                            if r_msx < len(colors): fg_idx, bg_idx = colors[r_msx]
                            safe_fg_idx = fg_idx if 0 <= fg_idx < 16 else WHITE_IDX
                            safe_bg_idx = bg_idx if 0 <= bg_idx < 16 else BLACK_IDX
                            fg_color_hex = self.active_msx_palette[safe_fg_idx]
                            bg_color_hex = self.active_msx_palette[safe_bg_idx]
                            row_pattern_data_list = []
                            if r_msx < len(pattern): row_pattern_data_list = pattern[r_msx]
                            for c_msx in range(TILE_WIDTH):
                                pixel_pattern_bit = 0
                                if c_msx < len(row_pattern_data_list): pixel_pattern_bit = row_pattern_data_list[c_msx]
                                color_to_draw_hex = fg_color_hex if pixel_pattern_bit == 1 else bg_color_hex
                                for y_offset_in_block in range(SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL):
                                    for x_offset_in_block in range(SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL):
                                        dest_screen_x = base_tile_draw_x + (c_msx * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL) + x_offset_in_block
                                        dest_screen_y = base_tile_draw_y + (r_msx * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL) + y_offset_in_block
                                        if dest_screen_x < temp_full_photo_w and dest_screen_y < temp_full_photo_h:
                                            try:
                                                temp_full_photo.put(color_to_draw_hex, to=(dest_screen_x, dest_screen_y))
                                            except tk.TclError: break 
                                    else: continue
                                    break 
        # --- End of rendering onto temp_full_photo ---

        # --- MODIFIED Part 4: Determine final_photo_width and create final_photo ---
        # final_photo_width is the minimum of the actual scaled content width and the available column area
        calculated_final_photo_width = min(temp_full_photo_w, max(1, int(target_image_content_area_width_in_col0)))
        
        # final_photo_height is the target row height for the Treeview cell
        final_photo_height = max(1, int(final_photo_target_height)) 
        
        final_photo = tk.PhotoImage(width=calculated_final_photo_width, height=final_photo_height)
        
        if supertile_index == 0: # Debug
             self.debug(f"[STP DEBUG {supertile_index}] temp_full_photo WxH: {temp_full_photo_w}x{temp_full_photo_h}")
             self.debug(f"[STP DEBUG {supertile_index}] target_image_content_area_width_in_col0: {target_image_content_area_width_in_col0}")
             self.debug(f"[STP DEBUG {supertile_index}] final_photo will be WxH: {calculated_final_photo_width}x{final_photo_height}")

        # --- Part 5: Fill final_photo with background ---
        hex_bg_color_final = "#F0F0F0" 
        try:
            system_bg_name = "SystemButtonFace" 
            rgb_tuple = self.root.winfo_rgb(system_bg_name) 
            r_8bit, g_8bit, b_8bit = rgb_tuple[0]//256, rgb_tuple[1]//256, rgb_tuple[2]//256
            hex_bg_color_final = f"#{r_8bit:02x}{g_8bit:02x}{b_8bit:02x}"
        except tk.TclError: pass 
        final_photo.put(hex_bg_color_final, to=(0,0, calculated_final_photo_width, final_photo_height))

        # --- Part 6: Copy/Crop from temp_full_photo to final_photo, vertically centering ---
        # Width to copy from source is limited by final_photo's (potentially cropped) width
        width_to_copy_from_source = calculated_final_photo_width 
        # Height to copy from source is the actual content height from temp_full_photo
        height_to_copy_from_source = temp_full_photo_h 

        if width_to_copy_from_source > 0 and height_to_copy_from_source > 0:
            y_offset_for_centering = 0
            if final_photo.height() > temp_full_photo.height(): # If row is taller than content
                y_offset_for_centering = (final_photo.height() - temp_full_photo.height()) // 2
            y_offset_for_centering = max(0, y_offset_for_centering)

            try:
                # Copy from temp_full_photo (0,0) up to (width_to_copy_from_source, height_to_copy_from_source)
                # To final_photo at (0, y_offset_for_centering)
                final_photo.tk.call(final_photo, 'copy', temp_full_photo,
                                    '-from', 0, 0, width_to_copy_from_source, height_to_copy_from_source,
                                    '-to', 0, y_offset_for_centering)
                if supertile_index == 0: self.debug(f"[STP DEBUG {supertile_index}] Copied {width_to_copy_from_source}x{height_to_copy_from_source} from temp to final at y_offset {y_offset_for_centering}")
            except tk.TclError as e:
                self.debug(f"[DEBUG] Error during PhotoImage copy for ST preview: {e}")
        
        return final_photo

    # --- Usage Window Config Management Helpers (NEW) ---
    def _get_config_filepath(self):
        """Constructs the path to the usage windows configuration file."""
        try:
            # Use appauthor=False to avoid creating an extra subdirectory for the author.
            # The directory structure will be like: .../AppConfigDir/MSXTileForge/
            config_dir = platformdirs.user_config_dir(self.config_app_name, appauthor=False,ensure_exists=True)
            return os.path.join(config_dir, self.config_file_name)
        except Exception as e:
            self.debug(f"[ERROR] Could not determine or create config directory using platformdirs: {e}")
            # Fallback to alongside the executable/script if platformdirs fails or is unavailable
            # This requires msxtileforge.py to be in a writable location if packaged.
            try:
                base_path = os.path.dirname(os.path.abspath(__file__))
                return os.path.join(base_path, self.config_file_name)
            except NameError: # __file__ is not defined (e.g. interactive, or frozen app without proper setup)
                 self.debug(f"[ERROR] __file__ not defined, falling back to CWD for config: {self.config_file_name}")
                 return self.config_file_name


    def _load_window_configs(self):
        """Loads usage window configurations from the JSON file into self.window_configs."""
        filepath = self._get_config_filepath()
        try:
            if os.path.exists(filepath) and os.path.getsize(filepath) > 0: # Check size too
                with open(filepath, 'r') as f:
                    loaded_data = json.load(f)
                    if isinstance(loaded_data, dict): # Basic type check
                        self.window_configs = loaded_data
                        self.debug(f"[DEBUG] Loaded window configurations from: {filepath}")
                    else:
                        self.debug(f"[ERROR] Config file {filepath} did not contain a valid JSON object. Using defaults.")
                        self.window_configs = {}
            else:
                self.debug(f"[DEBUG] Window configuration file not found or empty at: {filepath}. Using defaults.")
                self.window_configs = {}
        except (json.JSONDecodeError, IOError, OSError) as e:
            self.debug(f"[ERROR] Failed to load window configurations from {filepath}: {e}")
            self.window_configs = {} # Reset to default on error
        except Exception as e_generic: # Catch any other unexpected error during load
            self.debug(f"[ERROR] Unexpected error loading window configurations: {e_generic}")
            self.window_configs = {}


    def _save_window_configs(self):
        """
        Gathers current states of all open usage windows into self.window_configs,
        ensures closed windows are marked as such, and saves the entire dictionary to disk.
        Called on application quit.
        """
        filepath = self._get_config_filepath()
        try:
            self.debug(f"[DEBUG] Preparing to save window configurations to: {filepath}")
            self._gather_current_open_window_states(final_save=True) # Pass flag for final save logic

            # Ensure all known window types have an entry, marking non-gathered ones as closed
            all_known_window_types = ["ColorUsageWindow", "TileUsageWindow", "SupertileUsageWindow"]
            for window_name in all_known_window_types:
                if window_name not in self.window_configs:
                    self.window_configs[window_name] = {'is_open': False}
                elif 'is_open' not in self.window_configs[window_name]: # Ensure is_open key exists
                    # This case means it was gathered (so it was open) but somehow 'is_open' wasn't set by gather.
                    # Should not happen if _gather_current_open_window_states is correct.
                    # For safety, assume it was open if an entry exists but no 'is_open' flag.
                    # However, _gather_current_open_window_states *should* set it to True if it's gathering.
                    # More robustly: if it wasn't set to True by gather, and not False by an _on_close,
                    # then it's an undefined state. Defaulting to False is safer.
                    instance_was_found_open = False
                    if window_name == "ColorUsageWindow" and getattr(self, 'color_usage_window', None) and tk.Toplevel.winfo_exists(self.color_usage_window):
                        instance_was_found_open = True
                    elif window_name == "TileUsageWindow" and getattr(self, 'tile_usage_window', None) and tk.Toplevel.winfo_exists(self.tile_usage_window):
                        instance_was_found_open = True
                    elif window_name == "SupertileUsageWindow" and getattr(self, 'supertile_usage_window', None) and tk.Toplevel.winfo_exists(self.supertile_usage_window):
                        instance_was_found_open = True
                    
                    if not instance_was_found_open:
                         self.window_configs[window_name]['is_open'] = False


            with open(filepath, 'w') as f:
                json.dump(self.window_configs, f, indent=4, sort_keys=True) # sort_keys for consistent output
            self.debug(f"[DEBUG] Successfully saved all window configurations.")

        except (IOError, OSError, tk.TclError) as e:
            self.debug(f"[ERROR] Failed to save window configurations to {filepath}: {e}")
        except Exception as e_generic:
            self.debug(f"[ERROR] Unexpected error saving window configurations: {e_generic}")


    def load_specific_window_config(self, window_class_name):
        """
        Returns the saved configuration dictionary for a specific window class name.
        Returns an empty dictionary if no configuration is found.
        """
        # Ensure self.window_configs is initialized if called before full app init
        if not hasattr(self, 'window_configs'):
            self.window_configs = {}
            self._load_window_configs() # Attempt to load if not already loaded

        return self.window_configs.get(window_class_name, {}).copy() # Return a copy


    def update_specific_window_config(self, window_class_name, geometry=None, tree_config=None, is_open=None):
        """
        Updates the in-memory configuration (self.window_configs) for a specific window.
        This does NOT write to disk.
        tree_config should be a dict: {'sort_column_id': '...', 'sort_asc': True/False, 'column_widths': {'col_id': width, ...}}
        """
        if not hasattr(self, 'window_configs'): # Should have been initialized
            self.window_configs = {}
        
        if window_class_name not in self.window_configs:
            self.window_configs[window_class_name] = {}

        config_entry = self.window_configs[window_class_name]

        if geometry is not None:
            config_entry['geometry'] = geometry
        if tree_config is not None:
            if 'sort_column_id' in tree_config:
                config_entry['sort_column_id'] = tree_config['sort_column_id']
            if 'sort_asc' in tree_config:
                config_entry['sort_asc'] = tree_config['sort_asc']
            if 'column_widths' in tree_config:
                # Ensure column_widths is a dict before trying to update it
                if 'column_widths' not in config_entry or not isinstance(config_entry.get('column_widths'), dict):
                    config_entry['column_widths'] = {}
                config_entry['column_widths'].update(tree_config['column_widths']) # Merge/update widths
        if is_open is not None:
            config_entry['is_open'] = is_open
        
        self.debug(f"[DEBUG] In-memory config updated for {window_class_name}. IsOpen: {config_entry.get('is_open')}, Geo: {config_entry.get('geometry')}")


    def _gather_current_open_window_states(self, final_save=False):
        """
        Updates self.window_configs with the current state of any instantiated and
        visible usage windows. If final_save is True, it implies this is for app quit.
        """
        self.debug(f"[DEBUG] Gathering current open usage window states (final_save={final_save})...")

        window_details = [
            ("ColorUsageWindow", getattr(self, 'color_usage_window', None)),
            ("TileUsageWindow", getattr(self, 'tile_usage_window', None)),
            ("SupertileUsageWindow", getattr(self, 'supertile_usage_window', None))
        ]

        for name, instance in window_details:
            if instance and tk.Toplevel.winfo_exists(instance): # Check if instance exists and window is valid
                current_geometry = ""
                tree_config_data = {}
                try:
                    current_geometry = instance.winfo_geometry() # Get current geometry string
                    if hasattr(instance, '_get_current_tree_config'):
                        tree_config_data = instance._get_current_tree_config()
                    
                    self.update_specific_window_config(
                        name,
                        geometry=current_geometry,
                        tree_config=tree_config_data,
                        is_open=True # Explicitly mark as open because we found it
                    )
                except tk.TclError as e:
                    self.debug(f"[DEBUG] TclError gathering state for {name} (likely during shutdown): {e}")
                    # If error (e.g., window closing), try to preserve last known 'is_open' state if not final_save
                    if not final_save and name in self.window_configs:
                        self.window_configs[name]['is_open'] = self.window_configs[name].get('is_open', False)
                    elif final_save: # On final save, if error, assume it's closed
                         self.update_specific_window_config(name, is_open=False)

            elif final_save: # If it's the final save and instance is None or destroyed, ensure is_open is False
                self.update_specific_window_config(name, is_open=False)
            # If not final_save and instance is None, its state (likely is_open=False)
            # would have been set by its _on_close method.


    def _apply_initial_usage_window_states(self):
        """
        Opens usage windows after application start or project load,
        based on their saved 'is_open' state from self.window_configs.
        """
        self.debug("[DEBUG] Applying initial usage window states from loaded config...")
        
        # Use a list to manage order or dependencies if any, though not strictly needed here
        window_toggle_map = {
            "ColorUsageWindow": self.toggle_color_usage_window,
            "TileUsageWindow": self.toggle_tile_usage_window,
            "SupertileUsageWindow": self.toggle_supertile_usage_window
        }

        for window_name, toggle_function in window_toggle_map.items():
            config = self.window_configs.get(window_name, {})
            should_be_open = config.get('is_open', False) # Default to False if no 'is_open' key

            # Get current instance (if any)
            current_instance = None
            if window_name == "ColorUsageWindow": current_instance = self.color_usage_window
            elif window_name == "TileUsageWindow": current_instance = self.tile_usage_window
            elif window_name == "SupertileUsageWindow": current_instance = self.supertile_usage_window

            is_currently_open = current_instance is not None and tk.Toplevel.winfo_exists(current_instance)

            self.debug(f"  [DEBUG] For {window_name}: ShouldBeOpen={should_be_open}, IsCurrentlyOpen={is_currently_open}")

            if should_be_open and not is_currently_open:
                self.debug(f"    [DEBUG] Config says {window_name} should be open, and it's not. Calling toggle.")
                toggle_function() # This will create and show it, and __init__ will apply geometry/settings
            elif not should_be_open and is_currently_open:
                self.debug(f"    [DEBUG] Config says {window_name} should be closed, but it's open. Closing it.")
                # The toggle function might just lift it. We need to explicitly close.
                if current_instance: # Should be true if is_currently_open
                    try:
                        current_instance._on_close() # Call its proper close method
                    except tk.TclError: pass # Might already be destroying
            elif should_be_open and is_currently_open:
                self.debug(f"    [DEBUG] {window_name} is correctly open. Ensuring it's lifted.")
                if current_instance: current_instance.lift() # Ensure visible
    # --- End Usage Window Config Management Helpers ---

    def _calculate_single_tile_usage(self, tile_index_to_check):
        """Calculates total placements and unique supertiles for a single tile."""
        total_placements = 0
        unique_supertiles = set()

        # Check if the tile index is valid for the current tileset
        if not (0 <= tile_index_to_check < num_tiles_in_set):
            return 0, 0 # Return zero counts if the tile index is out of bounds

        # Iterate through all defined supertiles to find references
        for st_idx in range(num_supertiles):
            st_definition = supertiles_data[st_idx]
            # Validate the structure of the supertile definition to prevent errors
            if not st_definition or len(st_definition) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and len(st_definition[0]) != self.supertile_grid_width):
                continue # Skip malformed or inconsistent supertile definitions

            st_uses_tile = False
            for r_st in range(self.supertile_grid_height):
                for c_st in range(self.supertile_grid_width):
                    if st_definition[r_st][c_st] == tile_index_to_check:
                        total_placements += 1
                        st_uses_tile = True

            if st_uses_tile:
                unique_supertiles.add(st_idx)
        
        return total_placements, len(unique_supertiles)

    def _update_selected_tile_info_panel(self, update_usage_counts=True):
        """Updates the new selected tile info panel with the image and usage counts."""
        if not hasattr(self, 'selected_tile_preview_canvas'):
            return # Panel not yet created, do nothing

        # Update the tile number label
        self.selected_tile_info_label.config(text=f"Tile: {current_tile_index}")
        
        # Update the live preview image on the canvas
        preview_size = 64 # Use the fixed size defined during widget creation
        img = self.create_tile_image(current_tile_index, preview_size)
        self.selected_tile_preview_image_ref = img # Keep a reference to prevent garbage collection
        self.selected_tile_preview_canvas.delete("all")
        self.selected_tile_preview_canvas.create_image(0, 0, image=img, anchor=tk.NW)

        # Conditionally update usage counts for better performance during live drawing
        if update_usage_counts:
            placements, unique_sts = self._calculate_single_tile_usage(current_tile_index)
            self.selected_tile_usage_label.config(text=f"Used {placements} times in {unique_sts} Supertiles")

    def _calculate_single_color_usage(self, slot_index):
        """Calculates pixel, line, and unique tile usage for a single palette slot index."""
        pixel_uses = 0
        line_references = 0
        tile_references_set = set()

        if not (0 <= slot_index < 16):
            return 0, 0, 0 # Return zero counts for invalid slot index

        for tile_idx in range(num_tiles_in_set):
            tile_uses_this_slot = False
            if tile_idx >= len(tileset_colors): continue

            for row_idx in range(TILE_HEIGHT):
                if row_idx >= len(tileset_colors[tile_idx]): continue
                
                fg_slot, bg_slot = tileset_colors[tile_idx][row_idx]
                line_uses_this_slot_this_row = False

                if fg_slot == slot_index:
                    line_references += 1
                    tile_uses_this_slot = True
                    line_uses_this_slot_this_row = True
                
                if bg_slot == slot_index and fg_slot != slot_index:
                    line_references += 1
                    tile_uses_this_slot = True
                    line_uses_this_slot_this_row = True
                elif bg_slot == slot_index and fg_slot == slot_index:
                    # If fg and bg are the same, the line is already counted.
                    # This case still contributes to tile usage.
                    tile_uses_this_slot = True

                if line_uses_this_slot_this_row:
                    if tile_idx >= len(tileset_patterns) or row_idx >= len(tileset_patterns[tile_idx]): continue
                    
                    for col_idx in range(TILE_WIDTH):
                        if col_idx >= len(tileset_patterns[tile_idx][row_idx]): continue
                        
                        pixel_val = tileset_patterns[tile_idx][row_idx][col_idx]
                        if pixel_val == 1 and fg_slot == slot_index:
                            pixel_uses += 1
                        elif pixel_val == 0 and bg_slot == slot_index:
                            pixel_uses += 1
            
            if tile_uses_this_slot:
                tile_references_set.add(tile_idx)

        return pixel_uses, line_references, len(tile_references_set)

# print(dir(TileEditorApp))
# exit() # Stop before GUI starts for this test

# --- Main Execution ---
if __name__ == "__main__":
    import argparse 

    parser = argparse.ArgumentParser(description="MSX Tile Forge - Tile and Map Editor.")
    parser.add_argument("--debug",action="store_true",help="Enable detailed debug console output.")
    args = parser.parse_args()
    
    root = tk.Tk()
    root.withdraw() # Hide main window initially
    root.app_debug_mode = args.debug
    if root.app_debug_mode: print("[INFO] Debug mode enabled via --debug flag.")

    splash_win = tk.Toplevel(root)
    splash_win.overrideredirect(True) # No window decorations
    splash_win.config(cursor="watch")

    splash_after_id = None # To store the ID of the 'after' job

    def destroy_splash_and_show_main():
        # This function is called either by timer or by Esc key
        global splash_after_id
        if tk.Toplevel.winfo_exists(splash_win): # Check if splash window still exists
            if splash_after_id: # If a timer was set
                try:
                    splash_win.after_cancel(splash_after_id) # Try to cancel it
                    print("Splash timer cancelled.")
                except tk.TclError:
                    pass # Timer might have already fired or window gone
            splash_after_id = None
            splash_win.destroy()
        
        if root.winfo_exists(): # Check if root window still exists
            root.deiconify()
            app = TileEditorApp(root) # Create and show the main application
            if hasattr(app, 'debug'): app.debug("[DEBUG] Main application initialized.")

    def handle_splash_escape(event=None): # Added event=None for binding
        print("Escape pressed on splash, skipping.")
        destroy_splash_and_show_main()

    if not SPLASH_IMAGE or not isinstance(SPLASH_IMAGE, str) or len(SPLASH_IMAGE) < 20:
        print("[WARNING] SPLASH_IMAGE is invalid or not defined. Skipping splash image display.")
        if root.winfo_exists():
            splash_after_id = root.after(100, destroy_splash_and_show_main) # Very short delay if no image
        root.bind("<Escape>", handle_splash_escape) 
        raise RuntimeError("Splash image data invalid") # Go to except block for fallback

    image_data = base64.b64decode(SPLASH_IMAGE)
    splash_photo_ref = tk.PhotoImage(data=image_data) # Keep reference directly

    # Frame to hold image and text, to help with centering and layout
    content_frame = ttk.Frame(splash_win)
    content_frame.pack(expand=True, fill='both', padx=1, pady=1) # Add minimal padding if needed

    splash_image_label = ttk.Label(content_frame, image=splash_photo_ref, borderwidth=0)
    splash_image_label.pack(side=tk.TOP, padx=0, pady=0)
    splash_image_label.image = splash_photo_ref # Keep reference on label

    version_text_label = ttk.Label(
        content_frame, 
        text=f"v{APP_VERSION}", 
        font=("Segoe UI", 8), # Small font for version
    )
    version_text_label.pack(side=tk.BOTTOM, pady=(2, 2)) # Small padding below image
    splash_win.update_idletasks()
    req_width = content_frame.winfo_reqwidth()
    req_height = content_frame.winfo_reqheight()
        
    # Ensure positive dimensions, fallback to image size if frame calculation is off
    img_w = splash_photo_ref.width() if splash_photo_ref else 100
    img_h = splash_photo_ref.height() if splash_photo_ref else 50
        
    final_width = max(req_width, img_w, 1) # At least image width, or 1
    final_height = max(req_height, img_h, 1) # At least image height + text, or 1

    screen_width = splash_win.winfo_screenwidth()
    screen_height = splash_win.winfo_screenheight()
    x_pos = (screen_width // 2) - (final_width // 2)
    y_pos = (screen_height // 2) - (final_height // 2)
        
    splash_win.geometry(f'{final_width}x{final_height}+{x_pos}+{y_pos}')

    splash_win.bind("<Escape>", handle_splash_escape)
    splash_win.focus_set() # Give splash window focus to receive Esc key

    if root.winfo_exists():
        splash_after_id = splash_win.after(3000, destroy_splash_and_show_main)
    else: # Root closed before timer set
        if tk.Toplevel.winfo_exists(splash_win): splash_win.destroy()

    root.mainloop()