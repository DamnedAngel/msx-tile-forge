#!/bin/env -S python3
# -*- coding: utf-8 -*-
import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser
from tkinter import filedialog
from tkinter import messagebox
from tkinter import simpledialog
from contextlib import suppress
import struct
import os
import math
import copy
import base64
import io

# --- Constants ---
TILE_WIDTH = 8
TILE_HEIGHT = 8
EDITOR_PIXEL_SIZE = 30
VIEWER_TILE_SIZE = TILE_WIDTH * 2  # 16
PALETTE_SQUARE_SIZE = 20
NUM_TILES_ACROSS = 16
MAX_TILES = 256
SUPERTILE_GRID_DIM = 4
SUPERTILE_DEF_TILE_SIZE = TILE_WIDTH * 4  # 32
SUPERTILE_SELECTOR_PREVIEW_SIZE = TILE_WIDTH * 4  # 32
NUM_SUPERTILES_ACROSS = 8
MAX_SUPERTILES = 256
DEFAULT_MAP_WIDTH = 32  # In supertiles
DEFAULT_MAP_HEIGHT = 24  # In supertiles
DEFAULT_WIN_VIEW_WIDTH_TILES = 32  # Default screen size
DEFAULT_WIN_VIEW_HEIGHT_TILES = 24  # Default screen size
MAX_WIN_VIEW_HEIGHT_TILES = 27  # Allow up to 27 for half-tile logic

MINIMAP_INITIAL_WIDTH = 256  # Default desired width of minimap window in pixels
MINIMAP_INITIAL_HEIGHT = 212  # Default desired height of minimap window in pixels

DRAG_THRESHOLD_PIXELS = 3 # Minimum pixels mouse must move to initiate a drag

# --- Palette Editor Constants ---
MSX2_PICKER_COLS = 32
MSX2_PICKER_ROWS = 16
MSX2_PICKER_SQUARE_SIZE = 15
CURRENT_PALETTE_SLOT_SIZE = 30

# --- MSX2 Default Palette (Indices & Colors) ---
MSX2_RGB7_VALUES = [
    (0, 0, 0),
    (0, 0, 0),
    (1, 6, 1),
    (3, 7, 3),
    (1, 1, 7),
    (2, 3, 7),
    (5, 1, 1),
    (2, 6, 7),
    (7, 1, 1),
    (7, 3, 3),
    (6, 6, 1),
    (6, 6, 4),
    (1, 4, 1),
    (6, 2, 5),
    (5, 5, 5),
    (7, 7, 7),
]
BLACK_IDX = 1
MED_GREEN_IDX = 2
WHITE_IDX = 15

# --- Placeholder Colors ---
INVALID_TILE_COLOR = "#FF00FF"
INVALID_SUPERTILE_COLOR = "#00FFFF"

# --- Grid & Overlay Constants ---
GRID_COLOR_CYCLE = [
    "#FFFFFF",
    "#000000",
    "#FF00FF",
    "#00FFFF",
    "#FFFF00",
]  # White, Black, Magenta, Cyan, Yellow
GRID_DASH_PATTERN = (5, 3)  # 5 pixels on, 3 pixels off
WIN_VIEW_HANDLE_SIZE = 8  # Pixel size of resize handles
WIN_VIEW_HALF_ROW_COLOR = "#80808080"  # Semi-transparent grey for overscan area (adjust alpha if needed, format depends on tk version)

ICON_IMAGE = r"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"
SPLASH_IMAGE = r"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"

# --- MSX2 Color Generation ---
msx2_512_colors_hex = []
msx2_512_colors_rgb7 = []
for r in range(8):
    for g in range(8):
        for b in range(8):
            r_255 = min(255, r * 36)
            g_255 = min(255, g * 36)
            b_255 = min(255, b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            msx2_512_colors_hex.append(hex_color)
            msx2_512_colors_rgb7.append((r, g, b))

# --- Data Structures ---
tileset_patterns = [
    [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
tileset_colors = [
    [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
current_tile_index = 0
num_tiles_in_set = 1
selected_color_index = WHITE_IDX
last_drawn_pixel = None
supertiles_data = [
    [[0 for _ in range(SUPERTILE_GRID_DIM)] for _ in range(SUPERTILE_GRID_DIM)]
    for _ in range(MAX_SUPERTILES)
]
current_supertile_index = 0
num_supertiles = 1
selected_tile_for_supertile = 0
map_width = DEFAULT_MAP_WIDTH  # In supertiles
map_height = DEFAULT_MAP_HEIGHT  # In supertiles
map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
selected_supertile_for_map = 0
last_painted_map_cell = None
tile_clipboard_pattern = None
tile_clipboard_colors = None
supertile_clipboard_data = None

# --- Utility Functions ---
def get_contrast_color(hex_color):
    try:
        hex_color = hex_color.lstrip("#")
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
        return "#000000" if luminance > 0.5 else "#FFFFFF"
    except:
        return "#000000"


# --- Application Class ---
class TileEditorApp:
    def __init__(self, root):
        self.debug_enabled = getattr(root, 'app_debug_mode', False)

        self.root = root

        self.root.title("MSX Tile Forge - Untitled")
        with suppress(tk.TclError):
            self.root.state("zoomed")

        self.current_project_base_path = None
        self.project_modified = False

        self.supertile_grid_width = SUPERTILE_GRID_DIM 
        self.supertile_grid_height = SUPERTILE_GRID_DIM 

        self.active_msx_palette = []
        for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
            canonical_hex = self._rgb7_to_hex(r_pal, g_pal, b_pal)
            self.active_msx_palette.append(canonical_hex)
        self.selected_palette_slot = 0

        self.tile_image_cache = {}
        self.supertile_image_cache = {}
        self.map_render_cache = {} 

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0       # X coord of initial button press for drag threshold
        self.drag_press_y = 0       # Y coord of initial button press for drag threshold
        self.drag_canvas = None
        self.drag_indicator_id = None

        self.map_zoom_level = 1.0
        self.show_supertile_grid = tk.BooleanVar(value=False)
        self.show_window_view = tk.BooleanVar(value=False)
        self.grid_color_index = 1
        self.window_view_tile_x = 0
        self.window_view_tile_y = 0
        self.window_view_tile_w = tk.IntVar(value=DEFAULT_WIN_VIEW_WIDTH_TILES)
        self.window_view_tile_h = tk.IntVar(value=DEFAULT_WIN_VIEW_HEIGHT_TILES)
        self.window_view_resize_handle = None
        self.drag_start_x = 0
        self.drag_start_y = 0
        self.drag_start_win_tx = 0
        self.drag_start_win_ty = 0
        self.drag_start_win_tw = 0
        self.drag_start_win_th = 0

        self.minimap_window = None
        self.minimap_canvas = None
        self.MINIMAP_VIEWPORT_COLOR = "#FF0000"
        self.MINIMAP_WIN_VIEW_COLOR = "#0000FF"
        self.minimap_background_cache = None
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0
        self.minimap_resize_timer = None
        self._minimap_resizing_internally = False

        self.is_ctrl_pressed = False
        self.current_mouse_action = None
        self.pan_start_x = 0
        self.pan_start_y = 0
        self.last_placed_supertile_cell = None
        self.is_shift_pressed = False

        self.map_selection_active = False
        self.map_selection_rect_id = None
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_clipboard_data = None
        self.map_paste_preview_rect_id = None

        self.edit_menu = None
        self.copy_menu_item_index = -1
        self.paste_menu_item_index = -1

        self.marked_unused_tiles = set()
        self.marked_unused_supertiles = set()

        self.rom_import_dialog = None

        self.create_menu()
        self._setup_global_key_bindings()
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")

        self.tab_palette_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_tile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_supertile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_map_editor = ttk.Frame(self.notebook, padding="10")

        self.notebook.add(self.tab_palette_editor, text="Palette Editor")
        self.notebook.add(self.tab_tile_editor, text="Tile Editor")
        self.notebook.add(self.tab_supertile_editor, text="Supertile Editor")
        self.notebook.add(self.tab_map_editor, text="Map Editor")

        self.create_palette_editor_widgets(self.tab_palette_editor)
        self.create_tile_editor_widgets(self.tab_tile_editor)
        self.create_supertile_editor_widgets(self.tab_supertile_editor)
        self.create_map_editor_widgets(self.tab_map_editor)

        self.update_all_displays(changed_level="all")
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)

        self._setup_map_canvas_bindings()

        self._update_window_title()
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state() 

        self._update_map_cursor()

    def debug(self, message):
        """Prints the message to the console only if debug mode is enabled."""
        if self.debug_enabled:
            print(str(message)) # Ensure message is a string

    # --- Palette Conversion Helpers ---
    def _hex_to_rgb7(self, hex_color):
        try:
            if not isinstance(hex_color, str):
                raise TypeError("Input must be a string.")
            if not hex_color.startswith("#") or len(hex_color) != 7:
                raise ValueError(f"Input '{hex_color}' is not a valid #RRGGBB format.")
            lookup_hex = hex_color.lower()
            idx512 = msx2_512_colors_hex.index(lookup_hex)
            return msx2_512_colors_rgb7[idx512]
        except ValueError:
            print(
                f"Warning: Could not find exact MSX2 RGB7 mapping for hex '{hex_color}'. Returning (0,0,0)."
            )
            return (0, 0, 0)
        except TypeError as e:
            print(f"Error in _hex_to_rgb7: Input type error for '{hex_color}'. {e}")
            return (0, 0, 0)
        except Exception as e:
            print(f"Unexpected error in _hex_to_rgb7 for '{hex_color}': {e}")
            return (0, 0, 0)

    def _rgb7_to_hex(self, r, g, b):
        try:
            safe_r = max(0, min(7, int(r)))
            safe_g = max(0, min(7, int(g)))
            safe_b = max(0, min(7, int(b)))
            r_255 = min(255, safe_r * 36)
            g_255 = min(255, safe_g * 36)
            b_255 = min(255, safe_b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            return hex_color
        except (ValueError, TypeError) as e:
            print(f"Error in _rgb7_to_hex converting input ({r},{g},{b}): {e}")
            return "#000000"
        except Exception as e:
            print(f"Unexpected error in _rgb7_to_hex for ({r},{g},{b}): {e}")
            return "#000000"

    # --- Cache Management ---
    def invalidate_tile_cache(self, tile_index):
        keys_to_remove = [k for k in self.tile_image_cache if k[0] == tile_index]
        for key in keys_to_remove:
            self.tile_image_cache.pop(key, None)
        for st_index in range(num_supertiles):
            definition = supertiles_data[st_index]
            used = False
            # Check if definition is valid for current dimensions before iterating
            if len(definition) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) :
                for r_st_def in range(self.supertile_grid_height):
                    # Ensure row exists (it should if height check passed)
                    if r_st_def < len(definition):
                        for c_st_def in range(self.supertile_grid_width):
                             # Ensure column exists within row
                            if c_st_def < len(definition[r_st_def]):
                                if definition[r_st_def][c_st_def] == tile_index:
                                    used = True
                                    break
                            else: # Should not happen if width check above is good
                                # print(f"Warning: Invalidate tile cache, ST {st_index} row {r_st_def} too short for width {self.supertile_grid_width}")
                                break
                    else: # Should not happen if height check passed
                        # print(f"Warning: Invalidate tile cache, ST {st_index} definition too short for height {self.supertile_grid_height}")
                        break
                    if used:
                        break
            else:
                # This case indicates an inconsistency between self.supertile_grid_width/height
                # and the actual structure of supertiles_data[st_index].
                # This might happen if dimensions change but data isn't properly migrated/reinitialized.
                # For now, we'll skip invalidating supertile cache if the structure is unexpected,
                # or one could choose to invalidate all supertile caches as a precaution.
                # print(f"Warning: Supertile {st_index} definition dimensions mismatch project settings during tile cache invalidation. Skipping ST cache invalidation for this ST.")
                pass # Or: self.invalidate_supertile_cache(st_index) if aggressive


            if used:
                self.invalidate_supertile_cache(st_index)

    def invalidate_supertile_cache(self, supertile_index):
        keys_to_remove_st_img = [
            k for k in self.supertile_image_cache if k[0] == supertile_index
        ]
        for key_st_img in keys_to_remove_st_img:
            self.supertile_image_cache.pop(key_st_img, None)

        # Also invalidate corresponding entries in map_render_cache
        keys_to_remove_map_render = [
            k for k in self.map_render_cache if k[0] == supertile_index
        ]
        for key_map_render in keys_to_remove_map_render:
            self.map_render_cache.pop(key_map_render, None)

    def clear_all_caches(self):
        self.tile_image_cache.clear()
        self.supertile_image_cache.clear()
        self.map_render_cache.clear() # Added to clear the new map render cache

    # --- Image Generation ---
    def create_tile_image(self, tile_index, size):
        cache_key = (tile_index, size)
        if cache_key in self.tile_image_cache:
            return self.tile_image_cache[cache_key]
        render_size = max(1, int(size))
        img = tk.PhotoImage(width=render_size, height=render_size)
        if not (0 <= tile_index < num_tiles_in_set):
            img.put(INVALID_TILE_COLOR, to=(0, 0, render_size, render_size))
            self.tile_image_cache[cache_key] = img
            return img
        pattern = tileset_patterns[tile_index]
        colors = tileset_colors[tile_index]
        pixel_w_ratio = TILE_WIDTH / render_size
        pixel_h_ratio = TILE_HEIGHT / render_size
        for y in range(render_size):
            tile_r = min(TILE_HEIGHT - 1, int(y * pixel_h_ratio))
            try:
                fg_idx, bg_idx = colors[tile_r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            row_colors_hex = []
            for x in range(render_size):
                tile_c = min(TILE_WIDTH - 1, int(x * pixel_w_ratio))
                try:
                    pixel_val = pattern[tile_r][tile_c]
                except IndexError:
                    pixel_val = 0
                color_hex = fg_color if pixel_val == 1 else bg_color
                row_colors_hex.append(color_hex)
            try:
                img.put("{" + " ".join(row_colors_hex) + "}", to=(0, y))
            except tk.TclError as e:
                print(
                    f"Warning [create_tile_image]: TclError tile {tile_index} size {size} row {y}: {e}"
                )
                if row_colors_hex:
                    img.put(row_colors_hex[0], to=(0, y, render_size, y + 1))
        self.tile_image_cache[cache_key] = img
        return img

    def create_supertile_image(self, supertile_index, target_preview_width, target_preview_height): # Renamed parameters
        # Ensure target dimensions are at least 1x1
        safe_target_preview_width = max(1, int(target_preview_width))
        safe_target_preview_height = max(1, int(target_preview_height))

        # Cache key now includes actual target dimensions and source supertile grid dimensions
        cache_key = (supertile_index, safe_target_preview_width, safe_target_preview_height, self.supertile_grid_width, self.supertile_grid_height)
        if cache_key in self.supertile_image_cache: # Use supertile_image_cache
            return self.supertile_image_cache[cache_key]

        img = tk.PhotoImage(width=safe_target_preview_width, height=safe_target_preview_height)

        if not (0 <= supertile_index < num_supertiles):
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            # print(f"Warning: Supertile {supertile_index} internal dim mismatch for create_supertile_image. Expected {src_st_tile_grid_w}x{src_st_tile_grid_h}")
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        # --- Letterboxing/Pillarboxing logic REMOVED ---
        # The image is created with exact target dimensions, and we render directly into it.

        # Pixels of one original base tile (e.g., 8x8) when rendered within the target_preview_width/height
        output_pixels_per_base_tile_w = safe_target_preview_width / src_st_tile_grid_w
        output_pixels_per_base_tile_h = safe_target_preview_height / src_st_tile_grid_h
        
        # Heuristic: if rendering a source tile column/row to less than 1 pixel on average.
        if safe_target_preview_width < src_st_tile_grid_w or safe_target_preview_height < src_st_tile_grid_h:
             img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
             self.supertile_image_cache[cache_key] = img
             return img

        # Ratio of source base tile pixels (e.g., TILE_WIDTH) to its display size in the preview.
        src_pixels_per_output_pixel_w_ratio = TILE_WIDTH / output_pixels_per_base_tile_w if output_pixels_per_base_tile_w > 1e-9 else float('inf')
        src_pixels_per_output_pixel_h_ratio = TILE_HEIGHT / output_pixels_per_base_tile_h if output_pixels_per_base_tile_h > 1e-9 else float('inf')

        for y_out_preview in range(safe_target_preview_height):
            row_colors_hex_preview = []
            for x_out_preview in range(safe_target_preview_width):
                src_base_tile_c_in_st_grid_preview = min(src_st_tile_grid_w - 1, int(x_out_preview / output_pixels_per_base_tile_w))
                src_base_tile_r_in_st_grid_preview = min(src_st_tile_grid_h - 1, int(y_out_preview / output_pixels_per_base_tile_h))

                x_in_scaled_base_tile_area_preview = (x_out_preview / output_pixels_per_base_tile_w - src_base_tile_c_in_st_grid_preview) * output_pixels_per_base_tile_w
                y_in_scaled_base_tile_area_preview = (y_out_preview / output_pixels_per_base_tile_h - src_base_tile_r_in_st_grid_preview) * output_pixels_per_base_tile_h
                
                src_pixel_c_in_base_tile_preview = min(TILE_WIDTH - 1, int(x_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_w_ratio))
                src_pixel_r_in_base_tile_preview = min(TILE_HEIGHT - 1, int(y_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_h_ratio))

                pixel_color_hex_final_preview = INVALID_TILE_COLOR

                try:
                    tile_idx_from_st_def_preview = definition[src_base_tile_r_in_st_grid_preview][src_base_tile_c_in_st_grid_preview]
                    if 0 <= tile_idx_from_st_def_preview < num_tiles_in_set:
                        if not (0 <= src_pixel_r_in_base_tile_preview < TILE_HEIGHT and \
                                len(tileset_patterns[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview and \
                                0 <= src_pixel_c_in_base_tile_preview < TILE_WIDTH and \
                                len(tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]) > src_pixel_c_in_base_tile_preview and \
                                len(tileset_colors[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview):
                            pixel_color_hex_final_preview = INVALID_TILE_COLOR
                        else:
                            pattern_pixel_val_preview = tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview][src_pixel_c_in_base_tile_preview]
                            fg_idx_val_preview, bg_idx_val_preview = tileset_colors[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]
                            
                            if not (0 <= fg_idx_val_preview < len(self.active_msx_palette) and 0 <= bg_idx_val_preview < len(self.active_msx_palette)):
                                fg_color_preview = INVALID_TILE_COLOR; bg_color_preview = INVALID_TILE_COLOR
                            else:
                                fg_color_preview = self.active_msx_palette[fg_idx_val_preview]
                                bg_color_preview = self.active_msx_palette[bg_idx_val_preview]
                            pixel_color_hex_final_preview = fg_color_preview if pattern_pixel_val_preview == 1 else bg_color_preview
                except IndexError:
                    pixel_color_hex_final_preview = INVALID_TILE_COLOR
                
                row_colors_hex_preview.append(pixel_color_hex_final_preview)
            
            try:
                if safe_target_preview_width > 0:
                    img.put("{" + " ".join(row_colors_hex_preview) + "}", to=(0, y_out_preview))
            except tk.TclError as e:
                if row_colors_hex_preview and safe_target_preview_width > 0:
                    img.put(row_colors_hex_preview[0], to=(0, y_out_preview, safe_target_preview_width, y_out_preview + 1))
        
        self.supertile_image_cache[cache_key] = img # Store in the original cache
        return img

    # --- Menu Creation ---
    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # --- File Menu ---
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(
            label="New Project (All)", command=self.new_project, accelerator="Ctrl+N"
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Project...", command=self.open_project, accelerator="Ctrl+O"
        )
        file_menu.add_command(
            label="Save Project", command=self.save_project, accelerator="Ctrl+S"
        )
        file_menu.add_command(
            label="Save Project As...",
            command=self.save_project_as,
            accelerator="Ctrl+Shift+S",
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Palette (.msxpal)...", command=self.open_palette
        )
        file_menu.add_command(
            label="Save Palette (.msxpal)...", command=self.save_palette
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Tileset (.SC4Tiles)...", command=self.open_tileset
        )
        file_menu.add_command(
            label="Save Tileset (.SC4Tiles)...", command=self.save_tileset
        )
        # --- NEW: Import Tiles from ROM ---
        file_menu.add_command(
            label="Import Tiles from ROM...", command=self.open_rom_importer # New command
        )
        # --- End New ---
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Supertiles (.SC4Super)...", command=self.open_supertiles
        )
        file_menu.add_command(
            label="Save Supertiles (.SC4Super)...", command=self.save_supertiles
        )
        file_menu.add_separator()
        file_menu.add_command(label="Open Map (.SC4Map)...", command=self.open_map)
        file_menu.add_command(label="Save Map (.SC4Map)...", command=self.save_map)
        file_menu.add_separator()
        file_menu.add_command(
            label="Exit", command=self.root.quit, accelerator="Ctrl+Q"
        )

        # --- Edit Menu (Modified) ---
        self.edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=self.edit_menu)

        self.edit_menu.add_command(
            label="Copy",
            command=self.handle_generic_copy,
            state=tk.DISABLED,
            accelerator="Ctrl+C",
        )
        self.copy_menu_item_index = self.edit_menu.index(tk.END)

        self.edit_menu.add_command(
            label="Paste",
            command=self.handle_generic_paste,
            state=tk.DISABLED,
            accelerator="Ctrl+V",
        )
        self.paste_menu_item_index = self.edit_menu.index(tk.END)

        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Clear Current Tile", command=self.clear_current_tile
        )
        self.edit_menu.add_command(
            label="Clear Current Supertile", command=self.clear_current_supertile
        )
        self.edit_menu.add_command(label="Clear Map", command=self.clear_map)
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Set Tileset Size...", command=self.set_tileset_size
        )
        self.edit_menu.add_command(
            label="Set Supertile Count...", command=self.set_supertile_count
        )
        self.edit_menu.add_command(
            label="Set Map Dimensions...", command=self.set_map_dimensions
        )

        # --- View Menu ---
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(
            label="Show/Hide Minimap", command=self.toggle_minimap, accelerator="Ctrl+M"
        )

        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About...", command=self.show_about_box)

    # --- Widget Creation ---
    def create_palette_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame, padding=5)
        left_frame.grid(row=0, column=0, sticky="ns")
        right_frame = ttk.Frame(main_frame, padding=5)
        right_frame.grid(row=0, column=1, sticky="nsew")
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0)
        main_frame.grid_columnconfigure(1, weight=1)
        # Left Frame Contents
        current_palette_frame = ttk.LabelFrame(
            left_frame, text="Active Palette (16 colors)"
        )
        current_palette_frame.pack(pady=(0, 10), fill="x")
        cp_canvas_width = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        cp_canvas_height = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        self.current_palette_canvas = tk.Canvas(
            current_palette_frame,
            width=cp_canvas_width,
            height=cp_canvas_height,
            borderwidth=0,
            highlightthickness=0,
        )
        self.current_palette_canvas.pack()
        self.current_palette_canvas.bind(
            "<Button-1>", self.handle_current_palette_click
        )
        info_frame = ttk.LabelFrame(left_frame, text="Selected Slot Info")
        info_frame.pack(pady=(0, 10), fill="x")
        self.selected_slot_label = ttk.Label(info_frame, text="Slot: 0")
        self.selected_slot_label.grid(
            row=0, column=0, columnspan=3, sticky="w", padx=5, pady=2
        )
        self.selected_slot_color_label = tk.Label(
            info_frame, text="      ", bg="#000000", relief="sunken", width=6
        )
        self.selected_slot_color_label.grid(row=1, column=0, padx=5, pady=2)
        self.selected_slot_rgb_label = ttk.Label(info_frame, text="RGB: #000000")
        self.selected_slot_rgb_label.grid(
            row=1, column=1, columnspan=2, sticky="w", padx=5
        )
        rgb_frame = ttk.LabelFrame(left_frame, text="Set Color (RGB 0-7)")
        rgb_frame.pack(pady=(0, 10), fill="x")
        r_label = ttk.Label(rgb_frame, text="R:")
        r_label.grid(row=0, column=0, padx=(5, 0))
        self.rgb_r_var = tk.StringVar(value="0")
        self.rgb_r_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_r_var, width=2)
        self.rgb_r_entry.grid(row=0, column=1)
        g_label = ttk.Label(rgb_frame, text="G:")
        g_label.grid(row=0, column=2, padx=(5, 0))
        self.rgb_g_var = tk.StringVar(value="0")
        self.rgb_g_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_g_var, width=2)
        self.rgb_g_entry.grid(row=0, column=3)
        b_label = ttk.Label(rgb_frame, text="B:")
        b_label.grid(row=0, column=4, padx=(5, 0))
        self.rgb_b_var = tk.StringVar(value="0")
        self.rgb_b_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_b_var, width=2)
        self.rgb_b_entry.grid(row=0, column=5)
        apply_rgb_button = ttk.Button(
            rgb_frame, text="Set", command=self.handle_rgb_apply
        )
        apply_rgb_button.grid(row=0, column=6, padx=5, pady=5)
        reset_palette_button = ttk.Button(
            left_frame,
            text="Reset to MSX2 Default",
            command=self.reset_palette_to_default,
        )
        reset_palette_button.pack(pady=(0, 5), fill="x")
        # Right Frame Contents
        picker_frame = ttk.LabelFrame(right_frame, text="MSX2 512 Color Picker")
        picker_frame.pack(expand=True, fill="both")
        picker_canvas_width = MSX2_PICKER_COLS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_canvas_height = MSX2_PICKER_ROWS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_hbar = ttk.Scrollbar(picker_frame, orient=tk.HORIZONTAL)
        picker_vbar = ttk.Scrollbar(picker_frame, orient=tk.VERTICAL)
        self.msx2_picker_canvas = tk.Canvas(
            picker_frame,
            bg="lightgrey",
            scrollregion=(0, 0, picker_canvas_width, picker_canvas_height),
            xscrollcommand=picker_hbar.set,
            yscrollcommand=picker_vbar.set,
        )
        picker_hbar.config(command=self.msx2_picker_canvas.xview)
        picker_vbar.config(command=self.msx2_picker_canvas.yview)
        self.msx2_picker_canvas.grid(row=0, column=0, sticky="nsew")
        picker_vbar.grid(row=0, column=1, sticky="ns")
        picker_hbar.grid(row=1, column=0, sticky="ew")
        picker_frame.grid_rowconfigure(0, weight=1)
        picker_frame.grid_columnconfigure(0, weight=1)
        self.msx2_picker_canvas.bind("<Button-1>", self.handle_512_picker_click)
        self.draw_512_picker()

    def create_tile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        # Left Frame (Editor, Attributes, Transform)
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10))

        editor_frame = ttk.LabelFrame(
            left_frame, text="Tile Editor (Left: FG, Right: BG)"
        )
        editor_frame.grid(row=0, column=0, pady=(0, 10), sticky="ew") 
        
        self.editor_canvas = tk.Canvas(
            editor_frame,
            width=TILE_WIDTH * EDITOR_PIXEL_SIZE,
            height=TILE_HEIGHT * EDITOR_PIXEL_SIZE,
            bg="grey",
        )
        self.editor_canvas.grid(row=0, column=0, sticky=tk.NSEW) 
        editor_frame.grid_rowconfigure(0, weight=1) 
        editor_frame.grid_columnconfigure(0, weight=0) 


        self.editor_canvas.bind("<Button-1>", self.handle_editor_click)
        self.editor_canvas.bind("<B1-Motion>", self.handle_editor_drag)
        self.editor_canvas.bind(
            "<Button-3>", self.handle_editor_click
        ) 
        self.editor_canvas.bind(
            "<B3-Motion>", self.handle_editor_drag
        ) 
        self.editor_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.editor_canvas.bind("<Leave>", self._reset_cursor)

        # --- FG/BG Buttons Container ---
        fg_bg_buttons_container = ttk.Frame(editor_frame)
        fg_bg_buttons_container.grid(row=0, column=1, sticky=(tk.N, tk.S), padx=(10, 0))
        editor_frame.grid_columnconfigure(1, weight=0) 
        # fg_bg_buttons_container.grid_rowconfigure(0, weight=0) # Removed as title label was removed

        self.attr_row_frames = [] 
        self.attr_fg_labels = []
        self.attr_bg_labels = []

        for r_idx in range(TILE_HEIGHT): # Renamed r to r_idx
            row_control_frame = ttk.Frame(fg_bg_buttons_container)
            row_control_frame.grid(row=r_idx, column=0, sticky=tk.EW) # Start row at 0
            fg_bg_buttons_container.grid_rowconfigure(r_idx, weight=1) 

            row_control_frame.grid_columnconfigure(0, weight=0)  
            row_control_frame.grid_columnconfigure(1, weight=1)  
            row_control_frame.grid_columnconfigure(2, weight=0)  


            row_num_label = ttk.Label(row_control_frame, text=f"{r_idx}:")
            row_num_label.grid(row=0, column=0, padx=(0, 5), sticky=tk.W)

            fg_label = tk.Label(
                row_control_frame, text=" FG ", width=3, relief="raised", borderwidth=2
            )
            fg_label.grid(row=0, column=1, padx=(0, 2), sticky=tk.E) 
            fg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "fg")) # Ensure correct lambda capture if r_idx is used
            self.attr_fg_labels.append(fg_label)

            bg_label = tk.Label(
                row_control_frame, text=" BG ", width=3, relief="raised", borderwidth=2
            )
            bg_label.grid(row=0, column=2, padx=(2, 0), sticky=tk.W) 
            bg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "bg")) # Ensure correct lambda capture
            self.attr_bg_labels.append(bg_label)
            
            self.attr_row_frames.append(row_control_frame)
        # --- End FG/BG Buttons Container ---

        # --- Transform Frame below editor_frame in left_frame ---
        transform_frame = ttk.LabelFrame(left_frame, text="Transform")
        transform_frame.grid(row=1, column=0, pady=(0, 5), sticky="ew") 
        
        flip_h_button = ttk.Button(
            transform_frame, text="Flip H", command=self.flip_tile_horizontal
        )
        flip_h_button.grid(row=0, column=0, padx=3, pady=3)
        flip_v_button = ttk.Button(
            transform_frame, text="Flip V", command=self.flip_tile_vertical
        )
        flip_v_button.grid(row=0, column=1, padx=3, pady=3)
        rotate_button = ttk.Button(
            transform_frame, text="Rotate", command=self.rotate_tile_90cw
        )
        rotate_button.grid(row=0, column=2, padx=3, pady=3)
        shift_up_button = ttk.Button(
            transform_frame, text="Shift Up", command=self.shift_tile_up
        )
        shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        shift_down_button = ttk.Button(
            transform_frame, text="Shift Down", command=self.shift_tile_down
        )
        shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        shift_left_button = ttk.Button(
            transform_frame, text="Shift Left", command=self.shift_tile_left
        )
        shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        shift_right_button = ttk.Button(
            transform_frame, text="Shift Right", command=self.shift_tile_right
        )
        shift_right_button.grid(row=1, column=3, padx=3, pady=3)
        
        # --- Mark Unused Button below transform_frame in left_frame ---
        # This button is now placed directly in left_frame, at row=2
        self.mark_unused_tiles_button = ttk.Button( # Store as self attribute
            left_frame, text="Mark Unused", command=self.handle_mark_unused_tiles
        )
        self.mark_unused_tiles_button.grid(row=2, column=0, pady=(5, 10), sticky="ew") 

        # Right Frame (Palette, Tileset Viewer, Buttons)
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(
            row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E)
        ) 
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0) 
        main_frame.grid_columnconfigure(1, weight=1) 

        palette_frame = ttk.LabelFrame(
            right_frame, text="Color Selector (Click to draw)"
        )
        palette_frame.grid(row=0, column=0, pady=(0, 10), sticky=(tk.N, tk.W, tk.E))
        self.tile_editor_palette_canvas = tk.Canvas(
            palette_frame,
            width=4 * (PALETTE_SQUARE_SIZE + 2),
            height=4 * (PALETTE_SQUARE_SIZE + 2),
            borderwidth=0,
            highlightthickness=0,
        )
        self.tile_editor_palette_canvas.grid(row=0, column=0)
        self.tile_editor_palette_canvas.bind(
            "<Button-1>", self.handle_tile_editor_palette_click
        )

        viewer_frame = ttk.LabelFrame(right_frame, text="Tileset")
        viewer_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(0, weight=0) 
        right_frame.grid_rowconfigure(1, weight=1) 
        right_frame.grid_rowconfigure(2, weight=0) 
        right_frame.grid_rowconfigure(3, weight=0) 
        right_frame.grid_columnconfigure(0, weight=1) 

        viewer_canvas_width = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1
        num_rows_in_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS)
        viewer_canvas_height = num_rows_in_viewer * (VIEWER_TILE_SIZE + 1) + 1
        viewer_hbar = ttk.Scrollbar(viewer_frame, orient=tk.HORIZONTAL)
        viewer_vbar = ttk.Scrollbar(viewer_frame, orient=tk.VERTICAL)
        self.tileset_canvas = tk.Canvas(
            viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width, viewer_canvas_height),
            xscrollcommand=viewer_hbar.set,
            yscrollcommand=viewer_vbar.set,
        )
        viewer_hbar.config(command=self.tileset_canvas.xview)
        viewer_vbar.config(command=self.tileset_canvas.yview)
        self.tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        viewer_frame.grid_rowconfigure(0, weight=1)
        viewer_frame.grid_columnconfigure(0, weight=1)

        self.tileset_canvas.bind("<Button-1>", self.handle_tileset_click)
        self.tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.tileset_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)

        tile_button_frame = ttk.Frame(right_frame)
        tile_button_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(5, 0))

        self.add_tile_button = ttk.Button(
            tile_button_frame, text="Add New", command=self.handle_add_tile
        )
        self.add_tile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.insert_tile_button = ttk.Button(
            tile_button_frame, text="Insert", command=self.handle_insert_tile
        )
        self.insert_tile_button.pack(side=tk.LEFT, padx=3)

        self.delete_tile_button = ttk.Button(
            tile_button_frame, text="Delete", command=self.handle_delete_tile
        )
        self.delete_tile_button.pack(side=tk.LEFT, padx=3)

        self.tile_info_label = ttk.Label(right_frame, text="Tile: 0/0")
        self.tile_info_label.grid(row=3, column=0, sticky=tk.W, pady=(2, 0))

    def create_supertile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10))

        # Supertile Definition Frame (Row 0)
        def_frame = ttk.LabelFrame(
            left_frame, text="Supertile Definition (Click to place selected tile)"
        )
        def_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew")
        
        # Calculate definition canvas size dynamically
        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile in the editor (e.g., 32)
        def_canvas_width_actual = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
        def_canvas_height_actual = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
        # Ensure minimum size if dimensions are very small, e.g. 1x1 supertile
        def_canvas_width_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_width_actual)
        def_canvas_height_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_height_actual)

        self.supertile_def_canvas = tk.Canvas(
            def_frame, width=def_canvas_width_actual, height=def_canvas_height_actual, bg="darkgrey"
        )
        self.supertile_def_canvas.grid(row=0, column=0) # Consider adding sticky="nsew" if def_frame can resize
        def_frame.grid_rowconfigure(0, weight=1) # Allow canvas to expand if def_frame resizes
        def_frame.grid_columnconfigure(0, weight=1)


        self.supertile_def_canvas.bind("<Button-1>", self.handle_supertile_def_click)
        self.supertile_def_canvas.bind("<B1-Motion>", self.handle_supertile_def_drag)
        self.supertile_def_canvas.bind(
            "<ButtonRelease-1>", self.handle_supertile_def_release
        )
        self.supertile_def_canvas.bind(
            "<Button-3>", self.handle_supertile_def_right_click
        )
        self.supertile_def_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.supertile_def_canvas.bind("<Leave>", self._reset_cursor)

        # Info Labels Frame (Row 1)
        info_labels_frame = ttk.Frame(left_frame)
        info_labels_frame.grid(
            row=1, column=0, pady=(0, 5), sticky="ew"
        )
        self.supertile_def_info_label = ttk.Label(
            info_labels_frame, text=f"Editing Supertile: {current_supertile_index}"
        )
        self.supertile_def_info_label.pack(anchor=tk.W)
        self.supertile_tile_select_label = ttk.Label(
            info_labels_frame,
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}",
        )
        self.supertile_tile_select_label.pack(anchor=tk.W)

        # Transformation Frame (Row 2)
        st_transform_frame = ttk.LabelFrame(left_frame, text="Transform Supertile")
        st_transform_frame.grid(
            row=2, column=0, pady=(0, 5), sticky="ew"
        )

        st_flip_h_button = ttk.Button(
            st_transform_frame, text="Flip H", command=self.flip_supertile_horizontal
        )
        st_flip_h_button.grid(row=0, column=0, padx=3, pady=(5, 3))
        st_flip_v_button = ttk.Button(
            st_transform_frame, text="Flip V", command=self.flip_supertile_vertical
        )
        st_flip_v_button.grid(row=0, column=1, padx=3, pady=(5, 3))
        
        # Store reference to the rotate button
        self.st_rotate_button = ttk.Button(
            st_transform_frame, text="Rotate", command=self.rotate_supertile_90cw
        )
        self.st_rotate_button.grid(row=0, column=2, padx=3, pady=(5, 3))

        st_shift_up_button = ttk.Button(
            st_transform_frame, text="Shift Up", command=self.shift_supertile_up
        )
        st_shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        st_shift_down_button = ttk.Button(
            st_transform_frame, text="Shift Down", command=self.shift_supertile_down
        )
        st_shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        st_shift_left_button = ttk.Button(
            st_transform_frame, text="Shift Left", command=self.shift_supertile_left
        )
        st_shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        st_shift_right_button = ttk.Button(
            st_transform_frame, text="Shift Right", command=self.shift_supertile_right
        )
        st_shift_right_button.grid(row=1, column=3, padx=3, pady=3)

        # --- Mark Unused Button (Row 3 in left_frame) ---
        self.mark_unused_st_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_supertiles_and_tiles
        )
        self.mark_unused_st_button.grid(row=3, column=0, pady=(5, 10), sticky="ew")

        # Right Frame
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E))
        main_frame.grid_columnconfigure(1, weight=1)
        main_frame.grid_rowconfigure(0, weight=1)

        # Tileset Viewer Frame
        tileset_viewer_frame = ttk.LabelFrame(
            right_frame, text="Tileset (Click to select tile for definition)"
        )
        tileset_viewer_frame.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0, 10)
        )
        right_frame.grid_rowconfigure(0, weight=1)

        viewer_canvas_width_tiles = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1 # Keep using constant for tile viewer
        num_rows_in_tile_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS)
        viewer_canvas_height_tiles = num_rows_in_tile_viewer * (VIEWER_TILE_SIZE + 1) + 1

        st_viewer_hbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.HORIZONTAL)
        st_viewer_vbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.VERTICAL)
        self.st_tileset_canvas = tk.Canvas(
            tileset_viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width_tiles, viewer_canvas_height_tiles),
            xscrollcommand=st_viewer_hbar.set,
            yscrollcommand=st_viewer_vbar.set,
        )

        st_viewer_hbar.config(command=self.st_tileset_canvas.xview)
        st_viewer_vbar.config(command=self.st_tileset_canvas.yview)
        self.st_tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        st_viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        tileset_viewer_frame.grid_rowconfigure(0, weight=1)
        tileset_viewer_frame.grid_columnconfigure(0, weight=1)

        self.st_tileset_canvas.bind("<Button-1>", self.handle_st_tileset_click)
        self.st_tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.st_tileset_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )

        # Supertile Selector Frame
        st_selector_frame = ttk.LabelFrame(
            right_frame, text="Supertile Selector (Click to edit)"
        )
        st_selector_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(1, weight=1)

        # Scrollregion for supertile selector will be set dynamically in draw_supertile_selector
        # For initial setup, provide a minimal valid scrollregion.
        # Canvas width aims for 256px (TARGET_SELECTOR_CANVAS_WIDTH), height determined by content.
        target_selector_width = 256 # Matches the desired target layout width
        self.supertile_selector_canvas = tk.Canvas(
            st_selector_frame,
            bg="lightgrey",
            scrollregion=(0, 0, 1, 1), # Placeholder, will be updated
            width=target_selector_width # Request this width
        )
        st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        self.supertile_selector_canvas.config(
            xscrollcommand=st_sel_hbar.set,
            yscrollcommand=st_sel_vbar.set
        )
        st_sel_hbar.config(command=self.supertile_selector_canvas.xview)
        st_sel_vbar.config(command=self.supertile_selector_canvas.yview)

        self.supertile_selector_canvas.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E)
        )
        st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1) # Allow canvas to take space

        self.supertile_selector_canvas.bind(
            "<Button-1>", self.handle_supertile_selector_click
        )
        self.supertile_selector_canvas.bind(
            "<B1-Motion>", self.handle_viewer_drag_motion
        )
        self.supertile_selector_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )

        # Bottom Buttons/Labels Frame
        bottom_controls_frame = ttk.Frame(right_frame)
        bottom_controls_frame.grid(
            row=2, column=0, sticky="ew", pady=(5, 0)
        )
        right_frame.grid_rowconfigure(2, weight=0)

        self.add_supertile_button = ttk.Button(
            bottom_controls_frame, text="Add New", command=self.handle_add_supertile
        )
        self.add_supertile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.insert_supertile_button = ttk.Button(
            bottom_controls_frame, text="Insert", command=self.handle_insert_supertile
        )
        self.insert_supertile_button.pack(side=tk.LEFT, padx=3)

        self.delete_supertile_button = ttk.Button(
            bottom_controls_frame, text="Delete", command=self.handle_delete_supertile
        )
        self.delete_supertile_button.pack(side=tk.LEFT, padx=3)

        self.supertile_sel_info_label = ttk.Label(
            bottom_controls_frame, text=f"Supertiles: {num_supertiles}"
        )
        self.supertile_sel_info_label.pack(side=tk.LEFT, anchor=tk.W, padx=(10, 0))

    def create_map_editor_widgets(self, parent_frame):
        # Create the main container frame for this tab
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        # --- Create Left and Right Columns ---
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), padx=(0, 10))
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.N, tk.S))

        # --- Configure Main Frame Grid Weights ---
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_columnconfigure(1, weight=0)
        main_frame.grid_rowconfigure(0, weight=1)

        # --- Configure Left Frame Contents ---

        # Row 0: Map Size and Zoom Controls
        controls_frame = ttk.Frame(left_frame)
        controls_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        size_label = ttk.Label(controls_frame, text="Map Size:")
        size_label.grid(row=0, column=0, padx=(0, 5), pady=2)
        self.map_size_label = ttk.Label(
            controls_frame, text=f"{map_width} x {map_height}"
        )
        self.map_size_label.grid(row=0, column=1, padx=(0, 10), pady=2)
        zoom_frame = ttk.Frame(controls_frame)
        zoom_frame.grid(row=0, column=2, padx=(10, 0), pady=2)
        zoom_out_button = ttk.Button(
            zoom_frame,
            text="-",
            width=2,
            command=lambda: self.change_map_zoom_mult(1 / 1.25),
        )
        zoom_out_button.pack(side=tk.LEFT)
        self.map_zoom_label = ttk.Label(
            zoom_frame, text="100%", width=5, anchor=tk.CENTER
        )
        self.map_zoom_label.pack(side=tk.LEFT, padx=2)
        zoom_in_button = ttk.Button(
            zoom_frame,
            text="+",
            width=2,
            command=lambda: self.change_map_zoom_mult(1.25),
        )
        zoom_in_button.pack(side=tk.LEFT)
        zoom_reset_button = ttk.Button(
            zoom_frame, text="Reset", width=5, command=lambda: self.set_map_zoom(1.0)
        )
        zoom_reset_button.pack(side=tk.LEFT, padx=(5, 0))
        self.map_coords_label = ttk.Label(
            controls_frame, text="ST Coords: -, -", width=15
        )
        self.map_coords_label.grid(row=0, column=3, padx=(10, 5), sticky="w")

        # Row 1: Window View Toggle and Size Inputs
        win_controls_frame = ttk.Frame(left_frame)
        win_controls_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        win_view_check = ttk.Checkbutton(
            win_controls_frame,
            text="Show Window View",
            variable=self.show_window_view,
            command=self.toggle_window_view,
        )
        win_view_check.grid(row=0, column=0, padx=5, sticky="w")
        win_w_label = ttk.Label(win_controls_frame, text="Width:")
        win_w_label.grid(row=0, column=1, padx=(10, 0))
        self.win_view_w_entry = ttk.Entry(
            win_controls_frame, textvariable=self.window_view_tile_w, width=4
        )
        self.win_view_w_entry.grid(row=0, column=2)
        win_h_label = ttk.Label(win_controls_frame, text="Height:")
        win_h_label.grid(row=0, column=3, padx=(5, 0))
        self.win_view_h_entry = ttk.Entry(
            win_controls_frame, textvariable=self.window_view_tile_h, width=4
        )
        self.win_view_h_entry.grid(row=0, column=4)
        win_apply_button = ttk.Button(
            win_controls_frame,
            text="Apply Size",
            command=self.apply_window_size_from_entries,
        )
        win_apply_button.grid(row=0, column=5, padx=5)
        self.win_view_w_entry.bind(
            "<Return>", lambda e: self.apply_window_size_from_entries()
        )
        self.win_view_h_entry.bind(
            "<Return>", lambda e: self.apply_window_size_from_entries()
        )

        # Row 2: Grid Controls
        grid_controls_frame = ttk.Frame(left_frame)
        grid_controls_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        st_grid_check = ttk.Checkbutton(
            grid_controls_frame,
            text="Show Supertile Grid (Press 'G' to Cycle Colors)",
            variable=self.show_supertile_grid,
            command=self.toggle_supertile_grid,
        )
        st_grid_check.grid(row=0, column=0, padx=5, sticky="w")

        # Row 3: Map Canvas Frame
        map_canvas_frame = ttk.LabelFrame(left_frame, text="Map")
        map_canvas_frame.grid(row=3, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))

        # --- Configure Left Frame Grid Weights ---
        left_frame.grid_rowconfigure(0, weight=0)
        left_frame.grid_rowconfigure(1, weight=0)
        left_frame.grid_rowconfigure(2, weight=0)
        left_frame.grid_rowconfigure(3, weight=1)
        left_frame.grid_columnconfigure(0, weight=1)

        # --- Create Map Canvas and Scrollbars ---
        self.map_hbar = ttk.Scrollbar(map_canvas_frame, orient=tk.HORIZONTAL)
        self.map_vbar = ttk.Scrollbar(map_canvas_frame, orient=tk.VERTICAL)
        self.map_canvas = tk.Canvas(
            map_canvas_frame,
            bg="black", # Keep black background for map itself
            xscrollcommand=self.map_hbar.set,
            yscrollcommand=self.map_vbar.set,
        )
        self.map_hbar.config(command=self.map_canvas.xview)
        self.map_vbar.config(command=self.map_canvas.yview)
        self.map_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.map_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.map_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        # --- Configure Map Canvas Frame Grid Weights ---
        map_canvas_frame.grid_rowconfigure(0, weight=1)
        map_canvas_frame.grid_columnconfigure(0, weight=1)
        map_canvas_frame.grid_rowconfigure(1, weight=0) # Scrollbar
        map_canvas_frame.grid_columnconfigure(1, weight=0) # Scrollbar

        # --- Configure Right Frame Contents ---
        st_selector_frame = ttk.LabelFrame(
            right_frame, text="Supertile Palette (Click to select for map)"
        )
        st_selector_frame.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E)) # Allow it to use available space
        right_frame.grid_rowconfigure(0, weight=1) # Allow selector frame to expand vertically
        right_frame.grid_rowconfigure(1, weight=0) # Label below
        right_frame.grid_columnconfigure(0, weight=1) # Allow selector frame to expand horizontally (though its content aims for 256px)

        # Supertile Palette Canvas Setup (Map Tab)
        # Scrollregion will be set dynamically in draw_supertile_selector
        target_selector_width_map = 256 # Matches the desired target layout width
        self.map_supertile_selector_canvas = tk.Canvas(
            st_selector_frame,
            bg="lightgrey", # Background for the selector grid
            scrollregion=(0, 0, 1, 1), # Placeholder, will be updated
            width=target_selector_width_map # Request this width
        )
        map_st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        map_st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        self.map_supertile_selector_canvas.config(
             xscrollcommand=map_st_sel_hbar.set,
             yscrollcommand=map_st_sel_vbar.set
        )
        map_st_sel_hbar.config(command=self.map_supertile_selector_canvas.xview)
        map_st_sel_vbar.config(command=self.map_supertile_selector_canvas.yview)

        self.map_supertile_selector_canvas.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E)
        )
        map_st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        map_st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        st_selector_frame.grid_rowconfigure(0, weight=1) # Canvas takes most space
        st_selector_frame.grid_columnconfigure(0, weight=1) # Canvas takes most space
        st_selector_frame.grid_rowconfigure(1, weight=0) # Scrollbar
        st_selector_frame.grid_columnconfigure(1, weight=0) # Scrollbar

        self.map_supertile_selector_canvas.bind(
            "<Button-1>", self.handle_map_supertile_selector_click
        )
        self.map_supertile_selector_canvas.bind(
            "<B1-Motion>", self.handle_viewer_drag_motion
        )
        self.map_supertile_selector_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )

        self.map_supertile_select_label = ttk.Label(
            right_frame,
            text=f"Selected Supertile for Painting: {selected_supertile_for_map}",
        )
        self.map_supertile_select_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

    # --- Use this as the SINGLE definition for setting up bindings ---
    def _setup_map_canvas_bindings(self):
        """Sets up ALL event bindings for the map canvas and related root bindings.
        Includes initial unbind step for robustness.
        """
        canvas = self.map_canvas

        # --- Unbind ALL PREVIOUSLY POTENTIAL MAP CANVAS BINDINGS ---
        # ... (all unbind lines remain the same) ...
        canvas.unbind("<Button-1>")
        canvas.unbind("<B1-Motion>")
        canvas.unbind("<ButtonRelease-1>")
        canvas.unbind("<Button-3>")
        canvas.unbind("<Control-ButtonPress-1>")
        canvas.unbind("<Control-B1-Motion>")
        canvas.unbind("<Shift-ButtonPress-1>") 
        canvas.unbind("<Shift-B1-Motion>") 
        canvas.unbind("<Shift-ButtonRelease-1>") 
        canvas.unbind("<Control-MouseWheel>")
        canvas.unbind("<Control-Button-4>")
        canvas.unbind("<Control-Button-5>")
        canvas.unbind("<FocusIn>")
        canvas.unbind("<FocusOut>")
        canvas.unbind("<KeyPress-w>")
        canvas.unbind("<KeyPress-a>")
        canvas.unbind("<KeyPress-s>")
        canvas.unbind("<KeyPress-d>")
        canvas.unbind("<KeyPress-W>")
        canvas.unbind("<KeyPress-A>")
        canvas.unbind("<KeyPress-S>")
        canvas.unbind("<KeyPress-D>")
        canvas.unbind("<KeyPress-Escape>") 
        canvas.unbind("<Enter>")
        canvas.unbind("<Leave>")
        canvas.unbind("<Motion>")
        # --- End Unbind ---

        # --- Mouse Button 1 (Primary) - Checks Shift/Ctrl internally ---
        canvas.bind("<Button-1>", self.handle_map_click_or_drag_start)
        canvas.bind("<B1-Motion>", self.handle_map_drag)
        canvas.bind("<ButtonRelease-1>", self.handle_map_drag_release)

        # --- Mouse Button 3 (Right-Click for Selection) ---
        canvas.bind("<Button-3>", self.handle_map_canvas_right_click)

        # --- Panning (Ctrl + Mouse Button 1) - Checks Shift internally ---
        canvas.bind("<Control-ButtonPress-1>", self.handle_pan_start)
        canvas.bind("<Control-B1-Motion>", self.handle_pan_motion) # This will be modified

        # --- Selection (Shift + Mouse Button 1) ---
        canvas.bind("<Shift-ButtonPress-1>", self.handle_map_selection_start)
        canvas.bind("<Shift-B1-Motion>", self.handle_map_selection_motion)
        canvas.bind("<Shift-ButtonRelease-1>", self.handle_map_selection_release)

        # --- Zooming (Ctrl + Mouse Wheel) ---
        canvas.bind("<Control-MouseWheel>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-4>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-5>", self.handle_map_zoom_scroll)

        # --- Keyboard ---
        canvas.bind("<FocusIn>", lambda e: self.map_canvas.focus_set())
        canvas.bind("<FocusOut>", lambda e: self._update_map_cursor())
        canvas.bind("<KeyPress-w>", self.handle_map_keypress)
        canvas.bind("<KeyPress-a>", self.handle_map_keypress)
        canvas.bind("<KeyPress-s>", self.handle_map_keypress)
        canvas.bind("<KeyPress-d>", self.handle_map_keypress)
        canvas.bind("<KeyPress-W>", self.handle_map_keypress)
        canvas.bind("<KeyPress-A>", self.handle_map_keypress)
        canvas.bind("<KeyPress-S>", self.handle_map_keypress)
        canvas.bind("<KeyPress-D>", self.handle_map_keypress)
        canvas.bind("<KeyPress-Escape>", self.handle_map_escape)

        # --- Modifier Key State Tracking (Bound to root window) ---
        self.root.bind("<KeyPress-Control_L>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyPress-Control_R>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyRelease-Control_L>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyRelease-Control_R>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyPress-Shift_L>", self.handle_shift_press, add="+")
        self.root.bind("<KeyPress-Shift_R>", self.handle_shift_press, add="+")
        self.root.bind("<KeyRelease-Shift_L>", self.handle_shift_release, add="+")
        self.root.bind("<KeyRelease-Shift_R>", self.handle_shift_release, add="+")

        # --- Mouse Enter/Leave/Motion Canvas (for cursor updates) ---
        canvas.bind("<Enter>", self.handle_canvas_enter)
        canvas.bind("<Leave>", self.handle_canvas_leave)
        canvas.bind("<Motion>", self._update_map_cursor_and_coords)

        # --- Scrollbar Interaction (Update map canvas AND minimap) ---
        if hasattr(self, "map_hbar") and self.map_hbar:
            # For scrollbar drag (B1-Motion) and discrete clicks (ButtonRelease-1)
            self.map_hbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_hbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event) 
        if hasattr(self, "map_vbar") and self.map_vbar:
            self.map_vbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_vbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event)

    # --- Drawing Functions ---
    def update_all_displays(self, changed_level="all"):
        """Updates UI elements ONLY for the currently VISIBLE tab,
        based on the level of change indicated by changed_level.
        Also handles global updates like palette if necessary.
        """
        # Get current visible tab index (safer way)
        current_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab = self.notebook.select()
                if selected_tab:
                    current_tab_index = self.notebook.index(selected_tab)
        except tk.TclError:
            print("Warning: Could not get current tab index in update_all_displays.")
            return  # Avoid errors if notebook state is weird

        # --- Always handle Palette changes first, as they affect look of all tabs ---
        palette_changed = changed_level in ["all", "palette"]
        if palette_changed:
            # Update the palette editor widgets regardless of visibility
            # (They are cheap to update and data source for others)
            self.draw_current_palette()
            self.update_palette_info_labels()
            # Cache invalidation for palette changes is handled by the caller
            # (e.g., handle_rgb_apply, reset_palette...)

        # --- Update widgets ONLY for the VISIBLE tab ---

        # Palette Editor Tab (Index 0)
        if current_tab_index == 0:
            # Widgets already updated above if palette_changed is True.
            # No other data changes directly affect only this tab's display.
            pass  # print("Updating Palette Tab (Visible)")

        # Tile Editor Tab (Index 1)
        elif current_tab_index == 1:
            # Update if tile data changed OR palette changed (affects colors)
            if changed_level in ["all", "tile"] or palette_changed:
                # print(f"Updating Tile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_editor_canvas()
                self.draw_attribute_editor()
                self.draw_palette()  # Uses active_msx_palette
                self.draw_tileset_viewer(
                    self.tileset_canvas, current_tile_index
                )  # Main viewer
                self.update_tile_info_label()
                # We intentionally DO NOT update self.st_tileset_canvas here.
                # It will be updated when the Supertile tab becomes visible.

        # Supertile Editor Tab (Index 2)
        elif current_tab_index == 2:
            # Update if supertile data changed, underlying tile data changed, OR palette changed
            if changed_level in ["all", "supertile", "tile"] or palette_changed:
                # print(f"Updating Supertile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_supertile_definition_canvas()  # Uses tiles & palette
                self.draw_tileset_viewer(
                    self.st_tileset_canvas, selected_tile_for_supertile
                )  # Uses tiles & palette
                self.draw_supertile_selector(
                    self.supertile_selector_canvas, current_supertile_index
                )  # Uses tiles & palette
                self.update_supertile_info_labels()
                # We intentionally DO NOT update self.map_supertile_selector_canvas here.

        # Map Editor Tab (Index 3)
        elif current_tab_index == 3:
            # Update if map data changed, underlying supertile/tile data changed, OR palette changed
            if changed_level in ["all", "map", "supertile", "tile"] or palette_changed:
                # print(f"Updating Map Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                # Map canvas redraw is complex, redraw if map changed OR dependencies changed
                self.draw_map_canvas()  # Handles overlays, uses ST/Tiles/Palette
                self.draw_supertile_selector(
                    self.map_supertile_selector_canvas, selected_supertile_for_map
                )  # Uses ST/Tiles/Palette
                self.update_map_info_labels()  # Update size/zoom/window entries
                self.draw_minimap()  # Uses Map/ST/Tiles/Palette

    # ... (draw_editor_canvas, draw_attribute_editor, draw_palette unchanged) ...
    def draw_editor_canvas(self):
        self.editor_canvas.delete("all")
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        pattern = tileset_patterns[current_tile_index]
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            for c in range(TILE_WIDTH):
                try:
                    pixel_val = pattern[r][c]
                except IndexError:
                    pixel_val = 0
                color = fg_color if pixel_val == 1 else bg_color
                x1 = c * EDITOR_PIXEL_SIZE
                y1 = r * EDITOR_PIXEL_SIZE
                x2 = x1 + EDITOR_PIXEL_SIZE
                y2 = y1 + EDITOR_PIXEL_SIZE
                self.editor_canvas.create_rectangle(
                    x1, y1, x2, y2, fill=color, outline="darkgrey", width=1
                )

    def draw_attribute_editor(self):
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color_hex = self.active_msx_palette[fg_idx]
                bg_color_hex = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color_hex, bg_color_hex = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            self.attr_fg_labels[r].config(
                bg=fg_color_hex, fg=get_contrast_color(fg_color_hex)
            )
            self.attr_bg_labels[r].config(
                bg=bg_color_hex, fg=get_contrast_color(bg_color_hex)
            )

    def draw_palette(self):  # Renamed draw_palette to this for clarity
        """Draws the 16-color selector palette in the Tile Editor tab."""
        canvas = self.tile_editor_palette_canvas
        canvas.delete("all")
        size = PALETTE_SQUARE_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]  # Use active palette
            outline_color = "red" if i == selected_color_index else "grey"
            outline_width = 2 if i == selected_color_index else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_sel_{i}",
            )

    # --- vvv Palette Editor Drawing vvv ---
    def draw_current_palette(self):
        canvas = self.current_palette_canvas
        canvas.delete("all")
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]
            outline_color = "red" if i == self.selected_palette_slot else "grey"
            outline_width = 3 if i == self.selected_palette_slot else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_slot_{i}",
            )

    def draw_512_picker(self):
        canvas = self.msx2_picker_canvas
        canvas.delete("all")
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        for i in range(512):
            row, col = divmod(i, cols)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            hex_color = msx2_512_colors_hex[i]
            r, g, b = msx2_512_colors_rgb7[i]
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=hex_color,
                outline="grey",
                width=1,
                tags=(f"msx2_picker_{i}", f"msx2_rgb_{r}_{g}_{b}"),
            )

    def update_palette_info_labels(self):
        slot = self.selected_palette_slot
        if 0 <= slot < 16:
            color_hex = self.active_msx_palette[slot]
            rgb7 = (-1, -1, -1)
            try:
                idx512 = msx2_512_colors_hex.index(color_hex)
                rgb7 = msx2_512_colors_rgb7[idx512]
            except ValueError:
                pass
            self.selected_slot_label.config(text=f"Slot: {slot}")
            self.selected_slot_color_label.config(bg=color_hex)
            self.selected_slot_rgb_label.config(
                text=f"RGB: {color_hex} ({rgb7[0]},{rgb7[1]},{rgb7[2]})"
            )
            self.rgb_r_var.set(str(rgb7[0]) if rgb7[0] != -1 else "?")
            self.rgb_g_var.set(str(rgb7[1]) if rgb7[1] != -1 else "?")
            self.rgb_b_var.set(str(rgb7[2]) if rgb7[2] != -1 else "?")
        else:
            self.selected_slot_label.config(text="Slot: -")
            self.selected_slot_color_label.config(bg="grey")
            self.selected_slot_rgb_label.config(text="RGB: -")
            self.rgb_r_var.set("")
            self.rgb_g_var.set("")
            self.rgb_b_var.set("")

    def draw_tileset_viewer(self, canvas, highlighted_tile_index):
        """Draws tileset viewer, highlighting selected, dragged, or unused tile."""
        # Check if drag is active and involves a tile from *any* tileset viewer
        is_dragging_tile = self.drag_active and self.drag_item_type == "tile"
        dragged_tile_index = self.drag_start_index if is_dragging_tile else -1

        try:
            canvas.delete("all")
            padding = 1
            size = VIEWER_TILE_SIZE
            max_rows = math.ceil(num_tiles_in_set / NUM_TILES_ACROSS)
            canvas_height = max(1, max_rows * (size + padding) + padding)  
            canvas_width = max(
                1, NUM_TILES_ACROSS * (size + padding) + padding
            )  
            str_scroll = f"0 0 {float(canvas_width)} {float(canvas_height)}"

            # Safely get current scroll region
            current_scroll = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                if isinstance(current_scroll_val, tuple):
                    current_scroll = " ".join(map(str, current_scroll_val))
                else:
                    current_scroll = str(current_scroll_val)
            except tk.TclError:
                # Canvas might not be fully ready
                pass

            # Update scrollregion if needed
            if current_scroll != str_scroll:
                canvas.config(scrollregion=(0, 0, canvas_width, canvas_height))

            # Draw each tile
            for i in range(num_tiles_in_set):
                tile_r, tile_c = divmod(i, NUM_TILES_ACROSS)
                base_x = tile_c * (size + padding) + padding
                base_y = tile_r * (size + padding) + padding

                # Get cached image
                img = self.create_tile_image(i, size)
                canvas.create_image(
                    base_x,
                    base_y,
                    image=img,
                    anchor=tk.NW,
                    tags=(f"tile_img_{i}", "tile_image"),
                )

                # Determine outline style
                outline_color = "grey" 
                outline_width = 1
                if i == dragged_tile_index: # Highest priority: item being dragged
                    outline_color = "yellow" 
                    outline_width = 3
                elif i == highlighted_tile_index: # Next priority: current selection
                    outline_color = "red"
                    outline_width = 2
                elif i in self.marked_unused_tiles: # Then, check for unused highlight
                    outline_color = "blue" # Blue for unused
                    outline_width = 3 # Bold blue (width 3)

                # Draw the border rectangle
                bx1 = max(0, base_x - padding / 2)
                by1 = max(0, base_y - padding / 2)
                bx2 = base_x + size + padding / 2
                by2 = base_y + size + padding / 2
                canvas.create_rectangle(
                    bx1,
                    by1,
                    bx2,
                    by2,
                    outline=outline_color,
                    width=outline_width,
                    tags=f"tile_border_{i}",
                )

        except tk.TclError as e:
            # Catch errors if the canvas is destroyed during redraw
            print(f"TclError during draw_tileset_viewer: {e}")
        except Exception as e:
            print(f"Unexpected error during draw_tileset_viewer: {e}")

    def update_tile_info_label(self):
        self.tile_info_label.config(
            text=f"Tile: {current_tile_index}/{max(0, num_tiles_in_set-1)}"
        )

    def draw_supertile_definition_canvas(self):
        canvas = self.supertile_def_canvas
        canvas.delete("all")
        if not (0 <= current_supertile_index < num_supertiles):
            return

        definition = supertiles_data[current_supertile_index]
        
        # Ensure definition has expected structure based on current project dimensions
        # This is a safeguard. Data should ideally be consistent.
        if not definition or len(definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(definition[0]) != self.supertile_grid_width)):
            # print(f"Warning: Supertile {current_supertile_index} definition dimensions mismatch in draw_supertile_definition_canvas.")
            # Optionally draw an error indicator on the canvas
            canvas_w = canvas.winfo_width()
            canvas_h = canvas.winfo_height()
            canvas.create_text(canvas_w/2, canvas_h/2, text="Dim Mismatch!", fill="red", anchor="center")
            return

        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32x32 pixels)
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 

        for r_def in range(self.supertile_grid_height):
            for c_def in range(self.supertile_grid_width):
                try:
                    tile_idx = definition[r_def][c_def]
                except IndexError: # Should be caught by the check above, but for safety
                    # print(f"Error drawing ST def: index out of bounds for ST {current_supertile_index} at {r_def},{c_def}")
                    tile_idx = 0 # Default to tile 0 on error

                base_x = c_def * mini_tile_display_size
                base_y = r_def * mini_tile_display_size
                
                img = self.create_tile_image(tile_idx, mini_tile_display_size)
                canvas.create_image(
                    base_x, base_y, image=img, anchor=tk.NW, tags=f"def_tile_{r_def}_{c_def}"
                )
                canvas.create_rectangle(
                    base_x, base_y, base_x + mini_tile_display_size, base_y + mini_tile_display_size, outline="grey"
                )
    
    def draw_supertile_selector(self, canvas, highlighted_supertile_index):
        is_dragging_supertile = self.drag_active and self.drag_item_type == "supertile"
        dragged_supertile_index = self.drag_start_index if is_dragging_supertile else -1

        try:
            if not canvas.winfo_exists():
                return
            canvas.delete("all")
            
            # Item (preview) pixel dimensions are now the *actual* pixel dimensions of the supertile
            item_pixel_w = self.supertile_grid_width * TILE_WIDTH
            item_pixel_h = self.supertile_grid_height * TILE_HEIGHT
            padding = 1 

            if item_pixel_w <= 0 or item_pixel_h <= 0:
                return

            target_layout_width = 256
            actual_canvas_width = canvas.winfo_width()
            if actual_canvas_width <= 1: 
                 canvas.after(50, lambda: self.draw_supertile_selector(canvas, highlighted_supertile_index))
                 return

            effective_layout_width = min(target_layout_width, actual_canvas_width)
            
            items_across = 0
            for p_o_2 in [32, 16, 8, 4, 2, 1]: # Check powers of 2
                if p_o_2 == 0: continue
                required_width_for_po2 = (p_o_2 * item_pixel_w) + ((p_o_2 + 1) * padding)
                if required_width_for_po2 <= effective_layout_width:
                    items_across = p_o_2
                    break
            
            if items_across == 0: 
                if item_pixel_w + 2 * padding <= effective_layout_width: items_across = 1
                elif item_pixel_w <= effective_layout_width: items_across = 1
                else: items_across = 1 
            items_across = max(1, items_across)

            num_logical_rows = math.ceil(num_supertiles / items_across) if items_across > 0 else 0
            scroll_content_width = (items_across * item_pixel_w) + ((items_across + 1) * padding)
            scroll_content_height = (num_logical_rows * item_pixel_h) + ((num_logical_rows + 1) * padding)
            scroll_content_width = max(1.0, float(scroll_content_width))
            scroll_content_height = max(1.0, float(scroll_content_height))

            str_scroll = f"0 0 {scroll_content_width} {scroll_content_height}"
            current_scroll_val_str = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                current_scroll_val_str = " ".join(map(str, current_scroll_val)) if isinstance(current_scroll_val, tuple) else str(current_scroll_val)
            except tk.TclError: pass

            if current_scroll_val_str != str_scroll :
                try:
                    canvas.config(scrollregion=(0, 0, scroll_content_width, scroll_content_height))
                except tk.TclError: return

            view_y1 = canvas.canvasy(0)
            view_y2 = canvas.canvasy(canvas.winfo_height())
            start_draw_row = max(0, int(view_y1 // (item_pixel_h + padding)))
            end_draw_row = min(num_logical_rows, int(math.ceil(view_y2 / (item_pixel_h + padding))))

            for r_grid in range(start_draw_row, end_draw_row):
                for c_grid in range(items_across):
                    st_idx = r_grid * items_across + c_grid
                    if st_idx >= num_supertiles: break

                    base_x = (c_grid * (item_pixel_w + padding)) + padding
                    base_y = (r_grid * (item_pixel_h + padding)) + padding

                    # Call create_supertile_image with actual target width and height
                    img = self.create_supertile_image(st_idx, item_pixel_w, item_pixel_h) 
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_image(
                        base_x, base_y, image=img, anchor=tk.NW, tags=(f"st_img_{st_idx}", "st_image")
                    )

                    outline_color = "grey"
                    outline_width = 1
                    if st_idx == dragged_supertile_index: outline_color = "yellow"; outline_width = 3
                    elif st_idx == highlighted_supertile_index: outline_color = "red"; outline_width = 2
                    elif st_idx in self.marked_unused_supertiles: outline_color = "blue"; outline_width = 3
                    
                    bx1 = base_x - (padding / 2 if padding > 0 else 0.5) 
                    by1 = base_y - (padding / 2 if padding > 0 else 0.5)
                    bx2 = base_x + item_pixel_w + (padding / 2 if padding > 0 else 0.5) # Use item_pixel_w for border
                    by2 = base_y + item_pixel_h + (padding / 2 if padding > 0 else 0.5) # Use item_pixel_h for border
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_rectangle(
                        bx1, by1, bx2, by2, outline=outline_color, width=outline_width, tags=f"st_border_{st_idx}"
                    )
                if st_idx >= num_supertiles -1 : break
        except tk.TclError: pass
        except Exception as e: print(f"Unexpected error during draw_supertile_selector: {e}")

    def update_supertile_info_labels(self):
        self.supertile_def_info_label.config(
            text=f"Editing Supertile: {current_supertile_index}/{max(0, num_supertiles-1)}"
        )
        self.supertile_tile_select_label.config(
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}"
        )
        self.supertile_sel_info_label.config(text=f"Supertiles: {num_supertiles}")

    def draw_map_canvas(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return
        canvas.delete("all")

        # --- 1. Calculate Sizes ---
        zoomed_tile_size = self.get_zoomed_tile_size() 
        if zoomed_tile_size <= 0: return

        # Supertile dimensions in current zoom (pixels)
        # Uses self.supertile_grid_width/height from project settings
        zoomed_supertile_pixel_width, zoomed_supertile_pixel_height = self._get_zoomed_supertile_pixel_dims()
        if zoomed_supertile_pixel_width <= 0 or zoomed_supertile_pixel_height <= 0: return

        # --- 2. Update Scroll Region ---
        map_pixel_width_total = map_width * zoomed_supertile_pixel_width
        map_pixel_height_total = map_height * zoomed_supertile_pixel_height
        
        safe_scroll_width = max(1.0, float(map_pixel_width_total))
        safe_scroll_height = max(1.0, float(map_pixel_height_total))
        str_scroll = f"0 0 {safe_scroll_width} {safe_scroll_height}"
        current_scroll = ""
        try:
            current_scroll_val = canvas.cget("scrollregion")
            if isinstance(current_scroll_val, tuple):
                current_scroll = " ".join(map(str, current_scroll_val))
            else:
                current_scroll = str(current_scroll_val)
        except tk.TclError: pass

        if current_scroll != str_scroll:
            try:
                canvas.config(scrollregion=(0, 0, safe_scroll_width, safe_scroll_height))
            except tk.TclError: pass
        
        # --- 3. Draw Supertile Images ---
        # Determine visible supertile range for optimized drawing
        view_x1_map_draw = canvas.canvasx(0)
        view_y1_map_draw = canvas.canvasy(0)
        view_x2_map_draw = canvas.canvasx(canvas.winfo_width())
        view_y2_map_draw = canvas.canvasy(canvas.winfo_height())

        start_col_map_draw = max(0, int(view_x1_map_draw // zoomed_supertile_pixel_width))
        start_row_map_draw = max(0, int(view_y1_map_draw // zoomed_supertile_pixel_height))
        end_col_map_draw = min(map_width, int(math.ceil(view_x2_map_draw / zoomed_supertile_pixel_width)))
        end_row_map_draw = min(map_height, int(math.ceil(view_y2_map_draw / zoomed_supertile_pixel_height)))


        for r_map in range(start_row_map_draw, end_row_map_draw):
            for c_map in range(start_col_map_draw, end_col_map_draw):
                try:
                    supertile_idx = map_data[r_map][c_map]
                    base_x = c_map * zoomed_supertile_pixel_width
                    base_y = r_map * zoomed_supertile_pixel_height
                    
                    img = self.create_map_render_of_supertile(
                        supertile_idx, int(zoomed_supertile_pixel_width), int(zoomed_supertile_pixel_height)
                    )
                    
                    item_id = canvas.create_image(
                        base_x, base_y, image=img, anchor=tk.NW, tags=("map_supertile_image", f"map_cell_{r_map}_{c_map}")
                    )
                except IndexError:
                    pass
                except Exception as e:
                    pass

        # --- 4. Draw Supertile Grid (if enabled) ---
        if self.show_supertile_grid.get():
            grid_color = GRID_COLOR_CYCLE[self.grid_color_index]
            
            # Vertical lines: Iterate through columns that *could* have a line
            # Draw lines from 0 to map_pixel_height_total (map content boundary)
            # Tkinter canvas will clip lines that are partially or fully outside the visible area.
            for c_grid in range(map_width + 1): # Iterate all possible lines for the map width
                x_line = c_grid * zoomed_supertile_pixel_width
                # Only draw if the line itself is within the current view for minor optimization
                if x_line >= view_x1_map_draw and x_line <= view_x2_map_draw:
                     canvas.create_line(x_line, 0, x_line, map_pixel_height_total, 
                                        fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
                # Optimization: if x_line is already past the view, no need to check further c_grid for this specific view
                # However, this optimization is complex if scroll changes rapidly. Simpler to let Tkinter clip.
                # For small maps smaller than canvas, the loop range itself (map_width+1) limits lines.

            # Horizontal lines: Iterate through rows that *could* have a line
            # Draw lines from 0 to map_pixel_width_total (map content boundary)
            for r_grid in range(map_height + 1): # Iterate all possible lines for the map height
                y_line = r_grid * zoomed_supertile_pixel_height
                if y_line >= view_y1_map_draw and y_line <= view_y2_map_draw:
                    canvas.create_line(0, y_line, map_pixel_width_total, y_line,
                                       fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")

        # --- 5. Draw FINAL Selection Rectangle ---
        self._draw_selection_rectangle()

        # --- 6. Draw Window View Overlay (if enabled) ---
        if self.show_window_view.get():
            grid_color_win = GRID_COLOR_CYCLE[self.grid_color_index] 
            win_tx = self.window_view_tile_x 
            win_ty = self.window_view_tile_y
            win_tw = self.window_view_tile_w.get() 
            win_th = self.window_view_tile_h.get() 

            win_px_start = win_tx * zoomed_tile_size
            win_py_start = win_ty * zoomed_tile_size
            win_pixel_width_total = win_tw * zoomed_tile_size
            win_pixel_height_total = win_th * zoomed_tile_size

            canvas.create_rectangle(win_px_start, win_py_start, 
                                    win_px_start + win_pixel_width_total, 
                                    win_py_start + win_pixel_height_total, 
                                    outline=grid_color_win, width=2, tags=("window_view_rect", "window_view_item"))
            
            if win_th == MAX_WIN_VIEW_HEIGHT_TILES: 
                half_tile_h_px_zoomed = zoomed_tile_size / 2
                dark_y1 = win_py_start + win_pixel_height_total - half_tile_h_px_zoomed
                dark_y2 = win_py_start + win_pixel_height_total
                canvas.create_rectangle(win_px_start, dark_y1, 
                                        win_px_start + win_pixel_width_total, dark_y2, 
                                        fill="gray50", stipple="gray50", outline="", tags=("window_view_overscan", "window_view_item"))
            
            handle_size = WIN_VIEW_HANDLE_SIZE
            hs2 = handle_size // 2
            handle_fill = grid_color_win
            handle_outline = "black" if grid_color_win != "#000000" else "white"
            handles_coords = { 
                "nw": (win_px_start, win_py_start), 
                "n": (win_px_start + win_pixel_width_total / 2, win_py_start), 
                "ne": (win_px_start + win_pixel_width_total, win_py_start),
                "w": (win_px_start, win_py_start + win_pixel_height_total / 2),
                "e": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total / 2),
                "sw": (win_px_start, win_py_start + win_pixel_height_total), 
                "s": (win_px_start + win_pixel_width_total / 2, win_py_start + win_pixel_height_total), 
                "se": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total),
            }
            for tag_handle, (cx_handle, cy_handle) in handles_coords.items():
                x1h, y1h, x2h, y2h = cx_handle - hs2, cy_handle - hs2, cx_handle + hs2, cy_handle + hs2
                canvas.create_rectangle(x1h, y1h, x2h, y2h, fill=handle_fill, outline=handle_outline, width=1, tags=("window_view_handle", f"handle_{tag_handle}", "window_view_item"))

        # --- 7. Draw Paste Preview Rectangle ---
        self._clear_paste_preview_rect() 
        if self.map_clipboard_data:
            is_map_tab_active = False
            if self.notebook and self.notebook.winfo_exists():
                try:
                    if self.notebook.index(self.notebook.select()) == 3: # Map editor index
                        is_map_tab_active = True
                except tk.TclError: pass

            if is_map_tab_active:
                try:
                    pointer_x_widget = canvas.winfo_pointerx() - canvas.winfo_rootx()
                    pointer_y_widget = canvas.winfo_pointery() - canvas.winfo_rooty()
                    if (0 <= pointer_x_widget < canvas.winfo_width() and
                        0 <= pointer_y_widget < canvas.winfo_height()):
                        canvas_x_content = canvas.canvasx(pointer_x_widget)
                        canvas_y_content = canvas.canvasy(pointer_y_widget)
                        self._draw_paste_preview_rect(canvas_coords=(canvas_x_content, canvas_y_content))
                except Exception: pass 

        # --- 8. Update Zoom Label ---
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")

    def update_map_info_labels(self):
        self.map_size_label.config(text=f"{map_width} x {map_height}")
        self.map_supertile_select_label.config(
            text=f"Selected Supertile for Painting: {selected_supertile_for_map}"
        )
        # Update window size entries from state variables
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Ensure IntVar reflects internal state if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())
        # Zoom label updated in draw_map_canvas

    def on_tab_change(self, event):
        self._clear_marked_unused(trigger_redraw=False)

        current_tab_index = -1
        new_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_name = self.notebook.select()
                if selected_tab_name:
                    new_tab_index = self.notebook.index(selected_tab_name)
        except tk.TclError:
            pass

        if self.map_paste_preview_rect_id:
            self._clear_paste_preview_rect()

        self.update_all_displays(changed_level="all")
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state() # Update rotate button based on current ST dims

        try:
            self.root.unbind("<KeyPress-g>")
            self.root.unbind("<KeyPress-G>")
        except tk.TclError:
            pass

        if new_tab_index == 3:  # Map Editor Tab
            self.root.bind("<KeyPress-g>", self.handle_map_tab_keypress, add="+")
            self.root.bind("<KeyPress-G>", self.handle_map_tab_keypress, add="+")
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                self.root.after(50, self.map_canvas.focus_set)

            if self.map_clipboard_data:
                try:
                    if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                        pointer_x = self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                        pointer_y = self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                        if (0 <= pointer_x < self.map_canvas.winfo_width() and
                            0 <= pointer_y < self.map_canvas.winfo_height()):
                             canvas_x = self.map_canvas.canvasx(pointer_x)
                             canvas_y = self.map_canvas.canvasy(pointer_y)
                             self._draw_paste_preview_rect(canvas_coords=(canvas_x, canvas_y))
                except Exception:
                     pass

    # --- Palette Editor Handlers ---
    def handle_current_palette_click(self, event):
        canvas = self.current_palette_canvas
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_slot = row * 4 + col
        if 0 <= clicked_slot < 16:
            if self.selected_palette_slot != clicked_slot:
                self.selected_palette_slot = clicked_slot
                self.draw_current_palette()  # Redraw highlight
                self.update_palette_info_labels()  # Update info display

    def handle_512_picker_click(self, event):
        if not (0 <= self.selected_palette_slot < 16):
            return
        canvas = self.msx2_picker_canvas
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        col = int(canvas_x // (size + padding))
        row = int(canvas_y // (size + padding))
        clicked_index = row * cols + col
        
        if 0 <= clicked_index < 512:
            new_color_hex = msx2_512_colors_hex[clicked_index]
            target_slot = self.selected_palette_slot
            if self.active_msx_palette[target_slot] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot] = new_color_hex
                print(f"Set Palette Slot {target_slot} to {new_color_hex}")
                self.clear_all_caches()
                self.update_all_displays(changed_level="all")
        else:
            print("Clicked outside valid color range in picker.")

    def handle_rgb_apply(self):
        if not (0 <= self.selected_palette_slot < 16):
            return
        try:
            r_val = int(self.rgb_r_var.get()) # Renamed r
            g_val = int(self.rgb_g_var.get()) # Renamed g
            b_val = int(self.rgb_b_var.get()) # Renamed b
            if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                raise ValueError("RGB values must be 0-7.")
            
            new_color_hex = self._rgb7_to_hex(r_val, g_val, b_val)
            target_slot = self.selected_palette_slot
            
            if self.active_msx_palette[target_slot] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False): # Clear before palette change
                    pass # Full redraw will happen anyway
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot] = new_color_hex
                print(f"Set Palette Slot {target_slot} to {new_color_hex} via RGB")
                self.clear_all_caches()
                self.update_all_displays(changed_level="all") # "all" because palette affects everything
        except ValueError as e:
            messagebox.showerror("Invalid RGB", f"Invalid RGB input: {e}")

    def reset_palette_to_default(self):
        confirm = messagebox.askokcancel(
            "Reset Palette",
            "Reset the active palette to the MSX2 default colors?\nThis will affect the appearance of all tiles and supertiles.",
        )
        if confirm:
            new_default_palette = []
            for r_val, g_val, b_val in MSX2_RGB7_VALUES: # Renamed r,g,b
                new_default_palette.append(self._rgb7_to_hex(r_val, g_val, b_val))
            
            if self.active_msx_palette != new_default_palette:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                self._mark_project_modified()
                self.active_msx_palette = new_default_palette
                self.selected_palette_slot = 0
                global selected_color_index
                selected_color_index = 0 # Or WHITE_IDX depending on desired default
                self.clear_all_caches()
                self.update_all_displays(changed_level="all")
                print("Palette reset to MSX2 defaults.")
            else:
                print("Palette is already set to MSX2 defaults.")

    # --- Tile Editor Handlers ---
    def handle_editor_click(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        # --- Clear marked unused if an actual drawing action occurs ---
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE
        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            pixel_value_to_set = 1 if event.num == 1 else 0 # Determine based on left/right click
            if tileset_patterns[current_tile_index][r][c] != pixel_value_to_set:
                # Call _clear_marked_unused only if a change is about to be made
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                
                self._mark_project_modified()
                tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                self.invalidate_tile_cache(current_tile_index)
                # update_all_displays will be called again if marks were cleared,
                # otherwise, a more targeted update is fine.
                if not (self.marked_unused_tiles or self.marked_unused_supertiles): # if no marks were cleared
                    self.update_all_displays(changed_level="tile")
            last_drawn_pixel = (r, c)

    def handle_editor_drag(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE
        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if (r, c) != last_drawn_pixel:
                pixel_value_to_set = (
                    1 if event.state & 0x100 else (0 if event.state & 0x400 else -1)
                ) # Determine based on button state during drag
                if (
                    pixel_value_to_set != -1
                    and tileset_patterns[current_tile_index][r][c] != pixel_value_to_set
                ):
                    # Call _clear_marked_unused only if a change is about to be made
                    if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                        self.update_all_displays(changed_level="all") # Redraw if marks were cleared

                    self._mark_project_modified()
                    tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                    self.invalidate_tile_cache(current_tile_index)
                    if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                        self.update_all_displays(changed_level="tile")
                last_drawn_pixel = (r, c)

    def handle_tile_editor_palette_click(self, event):
        global selected_color_index
        canvas = self.tile_editor_palette_canvas
        size = PALETTE_SQUARE_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_index = row * 4 + col
        if 0 <= clicked_index < 16:
            if selected_color_index != clicked_index:
                selected_color_index = clicked_index
                self.draw_palette()  # Redraw this palette only

    def set_row_color(self, row, fg_or_bg):
        global tileset_colors, current_tile_index, selected_color_index
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        if not (0 <= selected_color_index < 16):
            return
        if 0 <= row < TILE_HEIGHT:
            current_fg_idx, current_bg_idx = tileset_colors[current_tile_index][row]
            changed = False
            if fg_or_bg == "fg" and current_fg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                tileset_colors[current_tile_index][row] = (
                    selected_color_index,
                    current_bg_idx,
                )
                changed = True
            elif fg_or_bg == "bg" and current_bg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                tileset_colors[current_tile_index][row] = (
                    current_fg_idx,
                    selected_color_index,
                )
                changed = True
            
            if changed:
                self._mark_project_modified()
                self.invalidate_tile_cache(current_tile_index)
                if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                    self.update_all_displays(changed_level="tile")

    def handle_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False 
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0 
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id) # Use current canvas
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x 
            self.drag_press_y = event.y 
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def flip_tile_horizontal(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        # Clear marks if any, and redraw if marks were present
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all") 

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            new_pattern[r] = current_pattern[r][::-1]
        tileset_patterns[current_tile_index] = new_pattern
        
        self.invalidate_tile_cache(current_tile_index)
        # If marks were not cleared above, do a targeted update
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} flipped horizontally.")

    def flip_tile_vertical(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        tileset_patterns[current_tile_index].reverse()
        tileset_colors[current_tile_index].reverse()
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} flipped vertically.")

    def rotate_tile_90cw(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0 for _ in range(TILE_WIDTH)] for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            for c in range(TILE_WIDTH):
                new_pattern[c][(TILE_HEIGHT - 1) - r] = current_pattern[r][c]
        tileset_patterns[current_tile_index] = new_pattern
        tileset_colors[current_tile_index] = [
            (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
        ]  
        
        self._mark_project_modified()
        messagebox.showinfo(
            "Rotation Complete", "Tile rotated.\nRow colors have been reset to default."
        )
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} rotated 90 CW (colors reset).")

    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        first_pattern_row = current_pattern[0]
        first_color_row = current_colors[0]
        for i in range(TILE_HEIGHT - 1):
            current_pattern[i] = current_pattern[i + 1]
            current_colors[i] = current_colors[i + 1]
        current_pattern[TILE_HEIGHT - 1] = first_pattern_row
        current_colors[TILE_HEIGHT - 1] = first_color_row
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted up.")

    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        last_pattern_row = current_pattern[TILE_HEIGHT - 1]
        last_color_row = current_colors[TILE_HEIGHT - 1]
        for i in range(TILE_HEIGHT - 1, 0, -1):
            current_pattern[i] = current_pattern[i - 1]
            current_colors[i] = current_colors[i - 1]
        current_pattern[0] = last_pattern_row
        current_colors[0] = last_color_row
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted down.")

    def shift_tile_left(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        for r_idx in range(TILE_HEIGHT): # Renamed r to r_idx to avoid conflict
            row_data = current_pattern[r_idx]
            first_pixel = 0 # Default if TILE_WIDTH is 0
            if TILE_WIDTH > 0:
                first_pixel = row_data[0]
            for c in range(TILE_WIDTH - 1):
                row_data[c] = row_data[c + 1]
            if TILE_WIDTH > 0: # Ensure assignment only if width > 0
                row_data[TILE_WIDTH - 1] = first_pixel
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted left.")

    def shift_tile_right(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        for r_idx in range(TILE_HEIGHT): # Renamed r to r_idx
            row_data = current_pattern[r_idx]
            last_pixel = 0 # Default if TILE_WIDTH is 0
            if TILE_WIDTH > 0:
                last_pixel = row_data[TILE_WIDTH - 1]
            for c in range(TILE_WIDTH - 1, 0, -1):
                row_data[c] = row_data[c - 1]
            if TILE_WIDTH > 0: # Ensure assignment only if width > 0
                row_data[0] = last_pixel
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted right.")

    # --- Supertile Editor Handlers ---
    def handle_st_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def handle_supertile_def_click(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            messagebox.showwarning("Place Tile", "Please select a valid tile first.")
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile in the editor
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_display_size <= 0 or not canvas.winfo_exists():
            return

        # Calculate col and row in the definition grid based on pixel size of mini-tiles
        col = event.x // mini_tile_display_size
        row = event.y // mini_tile_display_size

        # Reset drag state
        self.last_placed_supertile_cell = None

        # _place_tile_in_supertile will use self.supertile_grid_width/height for its internal bounds check
        placed = self._place_tile_in_supertile(row, col)

        if placed:
            self.last_placed_supertile_cell = (row, col)

    def handle_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    # --- Map Editor Handlers ---
    def handle_map_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def _paint_map_cell(self, canvas_x, canvas_y):
        global map_data, last_painted_map_cell, selected_supertile_for_map

        canvas = self.map_canvas
        
        # Get zoomed supertile pixel dimensions
        zoomed_st_w, zoomed_st_h = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_w <= 0 or zoomed_st_h <= 0:
            return

        # Calculate supertile column and row on the map
        c_map = int(canvas_x // zoomed_st_w)
        r_map = int(canvas_y // zoomed_st_h)

        if not (0 <= r_map < map_height and 0 <= c_map < map_width):
            return

        current_cell_id = (r_map, c_map)
        try:
            current_data_val = map_data[r_map][c_map]
        except IndexError:
            # print(f"  ERROR: IndexError accessing map_data[{r_map}][{c_map}]. Map size: {map_width}x{map_height}")
            return

        if current_cell_id != last_painted_map_cell:
            if current_data_val != selected_supertile_for_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    self.update_all_displays(changed_level="all")

                self._mark_project_modified()
                map_data[r_map][c_map] = selected_supertile_for_map
                self.invalidate_minimap_background_cache()

                base_x_draw = c_map * zoomed_st_w
                base_y_draw = r_map * zoomed_st_h
                
                # Use the new rendering function for map display
                img = self.create_map_render_of_supertile(
                    selected_supertile_for_map, int(zoomed_st_w), int(zoomed_st_h)
                )
                tag_cell = f"map_cell_{r_map}_{c_map}"

                items_found = canvas.find_withtag(tag_cell)
                if items_found:
                    canvas.itemconfig(items_found[0], image=img)
                else:
                    # This branch might not be strictly necessary if draw_map_canvas always pre-populates images
                    # but good for robustness if an image was somehow missed.
                    canvas.create_image(
                        base_x_draw,
                        base_y_draw,
                        image=img,
                        anchor=tk.NW,
                        tags=(tag_cell, "map_supertile_image"),
                    )
                    # Ensure new image is below grid if grid is visible
                    if self.show_supertile_grid.get():
                        if canvas.find_withtag("supertile_grid"):
                            canvas.tag_lower(tag_cell, "supertile_grid")
                
                self.draw_minimap()

            last_painted_map_cell = current_cell_id

    # --- Map Grid/Window Event Handlers ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()
        self.root.update_idletasks()
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES  # Use constant
            if not (min_w <= new_w <= max_w and min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Size",
                    f"Window width must be {min_w}-{max_w}, height {min_h}-{max_h}.",
                )
                # Reset entries to current state if invalid
                self.update_window_size_entries()
                return

            # If size changed, redraw the map
            # (IntVar should already hold the value, no need to set self.window_view_tile_w/h directly)
            self.draw_map_canvas()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
            self.update_window_size_entries()  # Reset on error
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")
            self.update_window_size_entries()

    def update_window_size_entries(self):
        """Updates the W/H entry boxes to match the current state."""
        # This ensures IntVars linked to entries have the correct value
        self.window_view_tile_w.set(self.window_view_tile_w.get())
        self.window_view_tile_h.set(self.window_view_tile_h.get())

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size() # Base tile (8x8 MSX) zoomed size
        if zoomed_tile_size <= 0:
            return

        delta_x = current_canvas_x - self.drag_start_x
        delta_y = current_canvas_y - self.drag_start_y

        delta_tile_x = round(delta_x / zoomed_tile_size)
        delta_tile_y = round(delta_y / zoomed_tile_size)

        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y
        
        # Max window position is based on total map tiles, not supertile grid directly here
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_tile_x_win = total_map_tiles_w - self.window_view_tile_w.get()
        max_tile_y_win = total_map_tiles_h - self.window_view_tile_h.get()
        
        # Ensure max is not negative if window is larger than map (should be prevented by other logic)
        max_tile_x_win = max(0, max_tile_x_win)
        max_tile_y_win = max(0, max_tile_y_win)

        clamped_tx = max(0, min(new_tx, max_tile_x_win))
        clamped_ty = max(0, min(new_ty, max_tile_y_win))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap during window drag

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th

        current_tile_x = round(current_canvas_x / zoomed_tile_size)
        current_tile_y = round(current_canvas_y / zoomed_tile_size)

        new_tx = start_tx
        new_ty = start_ty
        new_tw = start_tw
        new_th = start_th
        handle = self.window_view_resize_handle

        if "w" in handle:
            new_tx = min(current_tile_x, start_tx + start_tw - 1)
            new_tw = start_tw + (start_tx - new_tx)
        elif "e" in handle:
            new_tw = max(1, current_tile_x - start_tx + 1)

        if "n" in handle:
            new_ty = min(current_tile_y, start_ty + start_th - 1)
            new_th = start_th + (start_ty - new_ty)
        elif "s" in handle:
            new_th = max(1, current_tile_y - start_ty + 1)

        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        if "w" in handle and clamped_tw != new_tw:
            new_tx = start_tx + start_tw - clamped_tw
        if "n" in handle and clamped_th != new_th:
            new_ty = start_ty + start_th - clamped_th
        
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_map_tile_x_for_win = total_map_tiles_w
        max_map_tile_y_for_win = total_map_tiles_h
        
        clamped_tx = max(0, min(new_tx, max_map_tile_x_for_win - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y_for_win - clamped_th))
        
        # Final check if clamping position changed dimensions again
        final_tw = min(clamped_tw, max_map_tile_x_for_win - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y_for_win - clamped_ty)
        final_tw = max(1, final_tw) # Ensure min width of 1
        final_th = max(1, final_th) # Ensure min height of 1


        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw # Use final_tw/th
            or self.window_view_tile_h.get() != final_th
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)
            self.window_view_tile_h.set(final_th)
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        if not self.show_window_view.get():
            return

        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height
        
        # Max top-left position for the window view
        max_win_pos_x = total_map_tiles_w - current_w
        max_win_pos_y = total_map_tiles_h - current_h
        
        # Ensure max is not negative if window is larger than map
        max_win_pos_x = max(0, max_win_pos_x)
        max_win_pos_y = max(0, max_win_pos_y)

        clamped_tx = max(0, min(new_tx, max_win_pos_x))
        clamped_ty = max(0, min(new_ty, max_win_pos_y))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus (WASD, G)."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "g":  # MODIFIED CHECK
            self.cycle_grid_color()
            return "break"  # Prevent other 'g' bindings
        elif self.show_window_view.get():  # Only move window if visible
            moved = False
            if key == "w":
                self.move_window_view_keyboard(0, -1)
                moved = True
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)
                moved = True
            elif key == "s":
                self.move_window_view_keyboard(0, 1)
                moved = True
            elif key == "d":
                self.move_window_view_keyboard(1, 0)
                moved = True

            if moved:
                return "break"

    # --- Map Zoom Handlers ---
    def handle_map_zoom_scroll(self, event):
        canvas = self.map_canvas
        factor = 0.0
        if event.num == 4 or event.delta > 0: # Zoom In
            factor = 1.1
        elif event.num == 5 or event.delta < 0: # Zoom Out
            factor = 1 / 1.1
        else:
            return

        # --- Step 1: Get map coordinates under cursor BEFORE zoom ---
        # These are in the map's content coordinate system at the current zoom
        map_x_under_cursor_before_zoom = canvas.canvasx(event.x)
        map_y_under_cursor_before_zoom = canvas.canvasy(event.y)

        current_zoom_before = self.map_zoom_level # Store old zoom level

        # --- Step 2: Update zoom level (delegated) ---
        # zoom_map_at_point will set self.map_zoom_level and call draw_map_canvas,
        # which updates the scrollregion and redraws content.
        # The previous scroll adjustment logic within zoom_map_at_point was complex
        # and is now simplified. We will apply the scroll adjustment here.
        
        # Call a variant or directly update zoom level and then redraw.
        # For simplicity, let's assume zoom_map_at_point now primarily sets self.map_zoom_level
        # and calls draw_map_canvas. The point-fixing scroll is done here.

        min_zoom, max_zoom = 0.1, 6.0
        new_zoom_level = max(min_zoom, min(max_zoom, current_zoom_before * factor))

        if abs(new_zoom_level - current_zoom_before) < 1e-9:
            return # No significant zoom change

        self.map_zoom_level = new_zoom_level # Update the zoom level

        # --- Step 3: Redraw map with new zoom (updates scrollregion) ---
        # This is important so that subsequent calculations of total map dimensions are correct.
        self.draw_map_canvas() 
        # self.draw_minimap() will be called at the end

        # --- Step 4: Calculate new scroll position to keep point under cursor ---
        # After zoom and redraw (which set new scrollregion), the total map dimensions have changed.
        # We want the 'map_x_under_cursor_before_zoom' (which is a fixed point on the map's drawing)
        # to now appear under the screen coordinate event.x.

        # Total pixel dimensions of map content at the NEW zoom level
        # (get_zoomed_tile_size uses the new self.map_zoom_level)
        zoomed_tile_size_after = self.get_zoomed_tile_size()
        map_total_w_new = map_width * self.supertile_grid_width * zoomed_tile_size_after
        map_total_h_new = map_height * self.supertile_grid_height * zoomed_tile_size_after
        
        map_total_w_new = max(1.0, map_total_w_new) # Avoid division by zero
        map_total_h_new = max(1.0, map_total_h_new)

        # The desired new top-left of the viewport (scroll position in map units)
        # so that map_x_under_cursor_before_zoom appears at screen coordinate event.x
        # new_scroll_x_map_units = map_x_under_cursor_before_zoom - event.x # This is conceptual
        # We need to convert event.x (screen pixels) to how many map units it represents at new zoom.
        # Pixels per map unit at new zoom: self.map_zoom_level (if base is 1px=1unit) or related factor.
        # Here, "map units" are the scaled pixels used by canvasx.

        # Desired canvas.canvasx(0) = map_x_under_cursor_before_zoom - event.x
        # (No, this is not right. event.x is widget relative, canvasx is content relative)
        #
        # We want the map coordinate 'map_x_under_cursor_before_zoom'
        # to be at screen position 'event.x' after zooming.
        # Let new_vx = new canvas.canvasx(0).
        # event.x = map_x_under_cursor_before_zoom - new_vx  (if 1 screen pixel = 1 map unit at current zoom)
        # This is not quite right as canvasx itself depends on zoom.

        # Simpler scroll target using fractions, adapted from Tkinter examples:
        # The point on the map content (map_x_under_cursor_before_zoom) should now be
        # positioned at widget coordinate event.x.
        # The amount of canvas content to the left of event.x should be map_x_under_cursor_before_zoom.
        # So, canvas.canvasx(event.x) should ideally be map_x_under_cursor_before_zoom.
        #
        # canvas.xview_moveto(fraction)
        # fraction = (map_coord_of_interest - screen_coord_of_interest_relative_to_viewport_edge) / total_content_width
        
        # Target x-scroll fraction:
        # We want the content coordinate `map_x_under_cursor_before_zoom` to appear at `event.x` on screen.
        # The distance from the left edge of the content to `map_x_under_cursor_before_zoom` is `map_x_under_cursor_before_zoom`.
        # The distance from the left edge of the viewport to `event.x` is `event.x`.
        # So, the amount of content hidden to the left of the viewport should be:
        # `map_x_under_cursor_before_zoom - event.x` (if assuming 1:1 pixel mapping between content and screen for this formula part)
        # This is the new canvas.canvasx(0).
        
        new_scroll_offset_x = map_x_under_cursor_before_zoom - event.x
        new_scroll_offset_y = map_y_under_cursor_before_zoom - event.y
        
        # Convert absolute scroll offset to fraction for xview_moveto
        target_frac_x = new_scroll_offset_x / map_total_w_new
        target_frac_y = new_scroll_offset_y / map_total_h_new

        # Clamp fractions
        target_frac_x = max(0.0, min(1.0 - (canvas.winfo_width() / map_total_w_new), target_frac_x)) if map_total_w_new > canvas.winfo_width() else 0.0
        target_frac_y = max(0.0, min(1.0 - (canvas.winfo_height() / map_total_h_new), target_frac_y)) if map_total_h_new > canvas.winfo_height() else 0.0
        
        # Apply the scroll
        canvas.xview_moveto(target_frac_x)
        canvas.yview_moveto(target_frac_y)

        # Final redraw might be needed if moveto didn't trigger it, or to update minimap
        # self.draw_map_canvas() # Already called once, this might be redundant unless moveto is async
        self.draw_minimap()

    def change_map_zoom_mult(self, factor):
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        # Get current canvas view center
        cx = canvas.canvasx(canvas.winfo_width() / 2)
        cy = canvas.canvasy(canvas.winfo_height() / 2)
        # Zoom towards the center
        self.zoom_map_at_point(factor, cx, cy)

    def set_map_zoom(self, new_zoom_level):
        """Sets absolute zoom level, centered on current canvas center."""
        safe_zoom = max(0.1, min(6.0, float(new_zoom_level)))  # Clamp to new limits
        current_zoom = self.map_zoom_level
        if current_zoom != safe_zoom:
            factor = safe_zoom / current_zoom
            # Calculate center point to zoom around
            canvas = self.map_canvas
            cx = canvas.canvasx(canvas.winfo_width() / 2)
            cy = canvas.canvasy(canvas.winfo_height() / 2)
            # Apply zoom using the calculated factor
            self.zoom_map_at_point(factor, cx, cy)  # zoom_map_at_point handles redraw

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size (base 8x8) based on zoom."""
        # Base size for 100% zoom is 8 pixels per tile edge
        zoomed_size = 8 * self.map_zoom_level
        # Ensure minimum size of 1 pixel
        return max(1, int(zoomed_size))

    def zoom_map_at_point(self, factor, zoom_x_canvas, zoom_y_canvas):
        canvas = self.map_canvas
        current_zoom = self.map_zoom_level
        min_zoom, max_zoom = 0.1, 6.0
        new_zoom = max(min_zoom, min(max_zoom, current_zoom * factor))

        if abs(new_zoom - current_zoom) < 1e-9:
            return

        map_coord_x_at_cursor = canvas.canvasx(zoom_x_canvas) # This is canvasx from event.x, not event.x itself
        map_coord_y_at_cursor = canvas.canvasy(zoom_y_canvas) # This is canvasy from event.y

        scale_change = new_zoom / current_zoom
        self.map_zoom_level = new_zoom # Update state first

        # Ideal scroll position calculation
        new_map_coord_x_target = map_coord_x_at_cursor # The point under cursor should ideally stay the same *map* coordinate
        new_map_coord_y_target = map_coord_y_at_cursor

        # To keep new_map_coord_x_target at screen position zoom_x_canvas,
        # the new canvas.canvasx(0) should be:
        # new_scroll_x_abs = new_map_coord_x_target - zoom_x_canvas 
        # This interpretation was slightly off. Let's re-evaluate.
        #
        # The point on the map that was at (zoom_x_canvas, zoom_y_canvas) on screen
        # before zoom was (map_coord_x_at_cursor, map_coord_y_at_cursor) in map units.
        # After zoom, this map point (map_coord_x_at_cursor, map_coord_y_at_cursor)
        # should still appear at (zoom_x_canvas, zoom_y_canvas) on screen.
        #
        # Let S0 = old scroll offset (canvas.canvasx(0))
        # Let S1 = new scroll offset
        # zoom_x_canvas = map_coord_x_at_cursor_on_map_relative_to_origin / old_zoom_level - S0
        # zoom_x_canvas = map_coord_x_at_cursor_on_map_relative_to_origin / new_zoom_level - S1
        # This is getting complicated. Tkinter's own scaling:
        # canvas.scale("all", zoom_x_canvas, zoom_y_canvas, scale_change, scale_change)
        # This scales the *content*. Then we'd need to adjust scrollregion and redraw.
        #
        # Let's use the simpler scroll adjustment logic that worked before,
        # it relies on the fact that draw_map_canvas will correctly set the new scrollregion.

        # Calculate where the map point under the cursor *would* move to if we only scaled
        new_x_if_only_scaled = map_coord_x_at_cursor * scale_change # This is not quite right
        new_y_if_only_scaled = map_coord_y_at_cursor * scale_change

        # The amount the view origin needs to shift to keep the cursor point stationary
        # delta_x_scroll = new_x_if_only_scaled - map_coord_x_at_cursor # This is how much the map point moved
        # So canvas must scroll by this amount in map units.
        # If map_coord_x_at_cursor = C.canvasx(event.x)
        # then map_coord_x_at_cursor is already a coordinate in the current scrolled view.
        # After scaling, C.canvasx(event.x) * scale_change is where that point would be IF origin didn't move.
        # We want map_coord_x_at_cursor to remain at event.x (screen coordinate).
        
        # Calculate the new viewport origin such that the point under the cursor remains fixed.
        # (vx, vy) is the current top-left of the viewport in canvas coordinates.
        # We want to find (vx', vy')
        # zoom_x_canvas - vx = (map_point_x_under_cursor)
        # zoom_x_canvas - vx' = (map_point_x_under_cursor) / scale_change
        # vx' = zoom_x_canvas - (map_point_x_under_cursor / scale_change)
        # This is not how canvas.xview_scroll works. xview_scroll moves by delta units.

        # Original simpler logic for scroll adjustment:
        ideal_scroll_x_abs = (map_coord_x_at_cursor * scale_change) - zoom_x_canvas
        ideal_scroll_y_abs = (map_coord_y_at_cursor * scale_change) - zoom_y_canvas
        # This was for zoom_map_at_point when zoom_x_canvas was a screen coordinate.
        # Here, zoom_x_canvas is already a *map content* coordinate.

        # Simpler:
        # 1. Scale the canvas content around the specific point.
        #    This changes what map coordinates map to screen coordinates.
        #    Tkinter's canvas.scale() function does this.
        #    canvas.scale("all", zoom_x_canvas, zoom_y_canvas, scale_change, scale_change)
        #    This scales all *items* on the canvas. Since we redraw everything, this isn't what we want.

        # Let's use the previous "zoom_map_at_point" logic which seemed to work by adjusting scrollbars.
        # The key is that zoom_x_canvas and zoom_y_canvas are the *map content coordinates*
        # that should remain under the cursor.
        
        # Current view:
        # view_x1_old = canvas.canvasx(0)
        # view_y1_old = canvas.canvasy(0)
        
        # After zoom, the point (zoom_x_canvas, zoom_y_canvas) should still be at the same
        # relative position on the screen.
        # The offset of the cursor from the view origin is (zoom_x_canvas - view_x1_old)
        # This offset, when scaled, should be (zoom_x_canvas_new_scale - view_x1_new)
        # zoom_x_canvas * scale_change - view_x1_new = (zoom_x_canvas - view_x1_old) * scale_change
        # This is also complex.

        # Let's use the logic from the Tkinter wiki for zooming at a point:
        # This scrolls the view so that the canvas coordinate point (zoom_x_canvas, zoom_y_canvas)
        # appears at the same screen location after scaling the view.
        # Note: Tkinter's canvas view units are screen pixels.
        # Our zoom_x_canvas, zoom_y_canvas are already map content coords.
        
        # The amount of shift needed in the scroll view
        # This is how many *screen pixels* the view needs to shift.
        # Convert these screen pixel shifts to canvas "units" for scroll command.
        # This calculation was for when zoom_x_canvas was event.x (a screen coordinate)
        # If zoom_x_canvas is a map coordinate:
        # dx_scroll = (zoom_x_canvas * (1.0 - scale_change)) # Incorrect
        # dy_scroll = (zoom_y_canvas * (1.0 - scale_change)) # Incorrect

        # Simpler approach for scroll management (like before):
        # Calculate new total map dimensions
        zoomed_tile_size_new = self.get_zoomed_tile_size() # Uses updated self.map_zoom_level
        
        # These are the new total dimensions of the map content in pixels
        map_total_pixel_width_new = map_width * self.supertile_grid_width * zoomed_tile_size_new
        map_total_pixel_height_new = map_height * self.supertile_grid_height * zoomed_tile_size_new

        safe_map_width_new = max(1.0, map_total_pixel_width_new)
        safe_map_height_new = max(1.0, map_total_pixel_height_new)

        canvas_widget_width = canvas.winfo_width()
        canvas_widget_height = canvas.winfo_height()

        # The fraction of the map that zoom_x_canvas represents:
        frac_x = zoom_x_canvas / safe_map_width_new if current_zoom == 0 else zoom_x_canvas / (map_width * self.supertile_grid_width * (zoomed_tile_size_new / scale_change) )
        frac_y = zoom_y_canvas / safe_map_height_new if current_zoom == 0 else zoom_y_canvas / (map_height * self.supertile_grid_height * (zoomed_tile_size_new / scale_change) )
        
        # The screen coordinate where the zoom point should be fixed (relative to canvas widget)
        # This is NOT event.x, but the screen position of the map point zoom_x_canvas.
        # Let's assume zoom_x_canvas, zoom_y_canvas were the point under the *mouse cursor*.
        # We need to find where event.x, event.y was before the zoom,
        # then find where to scroll so that map point is still under event.x, event.y.

        # To keep `map_coord_x_at_cursor` (which *was* under the mouse) under the mouse *again*:
        # The mouse is at screen coordinate (event.x, event.y) relative to canvas widget.
        # New scroll left edge `s_x1` should be: `map_coord_x_at_cursor * scale_change - event.x`
        # (This assumes map_coord_x_at_cursor was from canvas.canvasx(event.x) using *old* zoom)
        
        # The effective map coordinate that should now be at the screen's event.x, event.y
        # is map_coord_x_at_cursor.
        # So, the new view's top-left (vx_new, vy_new) should be:
        # vx_new = map_coord_x_at_cursor - (event.x_relative_to_canvas * (1/new_zoom_level)) -> No, this uses absolute zoom.

        # Using the Tkinter canvas method of keeping a point stationary:
        # 1. Map the screen point (event.x, event.y) to canvas coordinates before zoom. (This is map_coord_x_at_cursor)
        # 2. Scale all canvas items by scale_change around that canvas coordinate.
        # Since we redraw items, we just need to adjust the view.
        # New scroll position:
        s_x = canvas.canvasx(0) # current scroll x
        s_y = canvas.canvasy(0) # current scroll y
        
        # zoom_x_canvas and zoom_y_canvas are already the map coordinates under the cursor
        
        # New scroll position needs to ensure that zoom_x_canvas (map coord)
        # is still at the same relative screen position it was.
        # This is equivalent to canvas.scan_mark(event.x,event.y) then canvas.scan_dragto but with scaling.

        # Calculate new scroll position to keep (zoom_x_canvas, zoom_y_canvas) stationary on screen
        # The delta applied to the scrollbar positions needs to be relative to the current view.
        # This means the logic from version 0.0.28 was likely more correct if it worked.
        # dx = zoom_x_canvas * (1.0 - 1.0/scale_change) # Amount to shift the view origin
        # dy = zoom_y_canvas * (1.0 - 1.0/scale_change)
        # canvas.xview_scroll(int(round(dx)), "units")
        # canvas.yview_scroll(int(round(dy)), "units")
        # This approach might be problematic because "units" for xview_scroll are poorly defined for scaled content.

        # A more reliable way: calculate absolute scroll fractions
        # The screen point (event.x, event.y) should correspond to map point (map_coord_x_at_cursor, map_coord_y_at_cursor)
        # after zoom.
        # The desired top-left canvas coordinate for the view (scroll position) would be:
        # new_scroll_abs_x = map_coord_x_at_cursor - (screen_pos_of_cursor_x * (1/self.map_zoom_level) )
        # This gets complex quickly.

        # Let's use the previous successful scroll adjustment from 0.0.28, assuming
        # zoom_x_canvas and zoom_y_canvas are the map coordinates that were under the cursor.
        # The screen position of the cursor (relative to canvas widget) must be known for this.
        # The handle_map_zoom_scroll passes event.x, event.y.
        # Let screen_cursor_x = event.x, screen_cursor_y = event.y from that handler.
        # So, map_coord_x_at_cursor = canvas.canvasx(screen_cursor_x) before zoom update.

        # Desired new canvas origin (scroll position)
        # new_vx = map_coord_x_at_cursor - screen_cursor_x * (1.0/self.map_zoom_level) # If map_zoom_level is pixel scale
        # new_vx = map_coord_x_at_cursor - screen_cursor_x # If map_zoom_level is just a factor relative to base
        # The 'units' for scroll are pixels of the *unzoomed* base if not careful.

        # Revert to the logic that shifts the view based on how the target point moves:
        # map_coord_x_at_cursor is the map coordinate.
        # Its new position if view didn't change: map_coord_x_at_cursor * scale_change (this is wrong, scale_change is for zoom level)
        # The point map_coord_x_at_cursor should remain at same screen spot.
        # Before zoom: screen_x = (map_coord_x_at_cursor - scroll_x_old) * old_pixel_per_map_unit
        # After zoom: screen_x = (map_coord_x_at_cursor - scroll_x_new) * new_pixel_per_map_unit
        # scroll_x_new = map_coord_x_at_cursor - (screen_x / new_pixel_per_map_unit)
        
        # The scroll factor is applied to the current view fractions.
        # This needs the event.x and event.y from the scroll handler.
        # For now, this method is called by change_map_zoom_mult (center zoom)
        # and handle_map_zoom_scroll (cursor zoom).
        # The parameters zoom_x_canvas, zoom_y_canvas are the *map coordinates* to keep fixed.
        
        # Initial scroll based on cursor point (map coordinates)
        # This attempts to keep the map point (zoom_x_canvas, zoom_y_canvas)
        # at the same fractional position within the viewport.
        current_xview_frac = canvas.xview()
        current_yview_frac = canvas.yview()

        # What fraction of the total map width/height does zoom_x_canvas represent BEFORE zoom?
        # Need pre-zoom total map dimensions.
        pre_zoom_tile_size = self.get_zoomed_tile_size() / scale_change # tile size before this zoom
        pre_map_total_w = map_width * self.supertile_grid_width * pre_zoom_tile_size
        pre_map_total_h = map_height * self.supertile_grid_height * pre_zoom_tile_size
        pre_map_total_w = max(1.0, pre_map_total_w) # Avoid division by zero
        pre_map_total_h = max(1.0, pre_map_total_h)

        frac_target_x = zoom_x_canvas / pre_map_total_w
        frac_target_y = zoom_y_canvas / pre_map_total_h
        
        # How much of the viewport width/height is visible (fraction of total map)
        view_frac_w = current_xview_frac[1] - current_xview_frac[0]
        view_frac_h = current_yview_frac[1] - current_yview_frac[0]
        
        # New scroll start fraction
        new_scroll_frac_x = frac_target_x - ( (zoom_x_canvas - canvas.canvasx(0)) / pre_map_total_w ) * (view_frac_w / (view_frac_w * scale_change) if view_frac_w > 0 else 1) # This needs event.x from scroll
        # This part is becoming overly complex again. The original simple shift worked if units were consistent.

        # Let's use the scroll adjustment based on how the fixed point moves relative to screen.
        # This requires the screen coordinates of the zoom point.
        # Assume zoom_x_canvas, zoom_y_canvas ARE the map points.
        # We need the event.x, event.y passed to handle_map_zoom_scroll.
        # This method should probably take event_x, event_y if it's cursor-centered.
        # If it's center-zoom, event_x/y are canvas.winfo_width/2.

        # If this method is called by handle_map_zoom_scroll, it will have event.x, event.y.
        # If called by change_map_zoom_mult, the zoom_x_canvas, zoom_y_canvas are center map points.
        
        # Simplified scroll adjustment:
        # This assumes zoom_x_canvas, zoom_y_canvas are the map coordinates that were under the mouse.
        # The view needs to shift such that this point remains under the mouse.
        # Let original scroll be (vx0, vy0).
        # Mouse screen pos: (mx, my).
        # Original map point under mouse: zoom_x_canvas = vx0 + mx / old_pixel_scale_factor
        # New scroll (vx1, vy1):
        # zoom_x_canvas = vx1 + mx / new_pixel_scale_factor
        # vx1 = zoom_x_canvas - mx / new_pixel_scale_factor
        # This requires screen mouse coords.
        
        # The critical part is that draw_map_canvas will correctly set the new scrollregion.
        # The scroll adjustment here is to keep the view centered or cursor-focused.
        # For now, let's assume a simple scroll to keep the *center of the new view*
        # roughly where the center of the old view was, scaled.
        # This means that the fractional scroll position should ideally remain similar.
        # canvas.xview_moveto(current_xview_frac[0])
        # canvas.yview_moveto(current_yview_frac[0])
        # This is too simple and doesn't zoom "to point".

        # The most reliable way is to adjust based on the delta of the fixed point.
        # This version relies on canvas.scan_dragto like behavior conceptually.
        # delta_x = zoom_x_canvas * (1.0 - scale_change) # Incorrect, scale_change is for zoom level
        # delta_y = zoom_y_canvas * (1.0 - scale_change)
        # canvas.xview_scroll(int(round(delta_x)), "units") # Units are problematic here.
        # canvas.yview_scroll(int(round(delta_y)), "units")
        
        # Reverting to a scroll logic that attempts to keep the *map point* stationary on screen.
        # This requires the screen coordinates of where that map point *was*.
        # If zoom_x_canvas, zoom_y_canvas ARE those map points:
        # Calculate the new desired scroll fractions based on keeping this point stationary
        # relative to the viewport's center, or a specific screen point if provided.
        # For now, just ensure clamping and full redraw. The scroll part needs a robust method.
        # The version from 0.0.29 for scroll adjustment was:
        # new_x = zoom_x_canvas * scale_change (incorrect if zoom_x_canvas is already a map coord of fixed point)
        # delta_x = new_x - zoom_x_canvas
        # canvas.xview_scroll(int(round(delta_x)), "units")
        # This scroll logic is the hardest to get right without Tk's direct item scaling.

        # The primary job of this function is to set self.map_zoom_level
        # and trigger a redraw. The scroll adjustment needs to be handled carefully
        # by the caller (handle_map_zoom_scroll) or by this function if it gets screen coords.

        # Clamping scroll position after any adjustment (or if no adjustment is made here)
        canvas_widget_width_after = canvas.winfo_width() # Re-query in case of changes
        canvas_widget_height_after = canvas.winfo_height()

        # This clamping ensures that if the map is smaller than the canvas, it's at 0,0.
        # It doesn't handle the zoom-to-point scrolling itself.
        if map_total_pixel_width_new < canvas_widget_width_after:
            canvas.xview_moveto(0.0)
        if map_total_pixel_height_new < canvas_widget_height_after:
            canvas.yview_moveto(0.0)
        
        # The crucial part: redraw the map. This function will use the new zoom level
        # and calculate the correct scroll region.
        self.draw_map_canvas()
        self.draw_minimap()

    # --- File Menu Commands ---
    # ... (new_project, save/load tileset/supertile/map remain mostly unchanged,
    #      ensure new_project resets new state like grid toggles, window view) ...
    def new_project(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        global supertiles_data, current_supertile_index, num_supertiles, selected_tile_for_supertile
        global map_data, map_width, map_height, selected_supertile_for_map, last_painted_map_cell
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data

        confirm_new = True
        if self.project_modified:
            confirm_new = messagebox.askokcancel(
                "New Project", "Discard all current unsaved changes and start new?"
            )

        if confirm_new:
            # --- Get New Supertile Dimensions ---
            temp_st_width = self.supertile_grid_width # Store current to revert if dialog cancelled
            temp_st_height = self.supertile_grid_height

            new_dim_w_str = simpledialog.askstring(
                "New Supertile Width",
                "Enter supertile grid width (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_width)
            )
            if new_dim_w_str is None: return # User cancelled

            try:
                new_dim_w = int(new_dim_w_str)
                if not (1 <= new_dim_w <= 32):
                    messagebox.showerror("Invalid Width", "Width must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Width must be a whole number.", parent=self.root)
                return

            new_dim_h_str = simpledialog.askstring(
                "New Supertile Height",
                "Enter supertile grid height (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_height)
            )
            if new_dim_h_str is None: return # User cancelled
            
            try:
                new_dim_h = int(new_dim_h_str)
                if not (1 <= new_dim_h <= 32):
                    messagebox.showerror("Invalid Height", "Height must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Height must be a whole number.", parent=self.root)
                return

            self.supertile_grid_width = new_dim_w
            self.supertile_grid_height = new_dim_h
            print(f"New project: Supertile dimensions set to {self.supertile_grid_width}W x {self.supertile_grid_height}H.")
            # --- End Get New Supertile Dimensions ---

            self._clear_marked_unused(trigger_redraw=False)

            tileset_patterns = [
                [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
            ]
            tileset_colors = [
                [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
                for _ in range(MAX_TILES)
            ]
            current_tile_index = 0
            num_tiles_in_set = 1
            selected_tile_for_supertile = 0

            # Initialize supertiles_data with new dimensions
            supertiles_data = [
                [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                for _st in range(MAX_SUPERTILES)
            ]
            current_supertile_index = 0
            num_supertiles = 1
            selected_supertile_for_map = 0

            map_width = DEFAULT_MAP_WIDTH
            map_height = DEFAULT_MAP_HEIGHT
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
            last_painted_map_cell = None

            tile_clipboard_pattern = None
            tile_clipboard_colors = None
            supertile_clipboard_data = None # This needs to be aware of ST dimensions if copied
            self.map_clipboard_data = None

            self.active_msx_palette = []
            for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
                 self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
            self.selected_palette_slot = 0
            global selected_color_index
            selected_color_index = WHITE_IDX

            self.map_zoom_level = 1.0
            self.show_supertile_grid.set(False)
            self.show_window_view.set(False)
            self.grid_color_index = 1
            self.window_view_tile_x = 0
            self.window_view_tile_y = 0
            self.window_view_tile_w.set(DEFAULT_WIN_VIEW_WIDTH_TILES)
            self.window_view_tile_h.set(DEFAULT_WIN_VIEW_HEIGHT_TILES)
            self.current_mouse_action = None
            self.window_view_resize_handle = None

            self._clear_map_selection()
            self._clear_paste_preview_rect()
            self.is_shift_pressed = False
            self.is_ctrl_pressed = False

            self.current_project_base_path = None
            self.project_modified = False # Reset modified flag AFTER asking and getting dimensions
            self._update_window_title()

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            
            # Reconfigure supertile definition canvas size if it exists
            self._reconfigure_supertile_definition_canvas()
            
            self._trigger_minimap_reconfigure() # In case map proportions change due to ST dim change
            self.update_all_displays(changed_level="all")

            self._update_editor_button_states()
            self._update_edit_menu_state()
            self._update_supertile_rotate_button_state() # Update based on new dimensions

    def save_palette(self, filepath=None):
        """Saves the current 16 active palette colors to a binary file.
        Returns True on success, False on failure/cancel.
        If filepath is None, prompts the user.
        """
        save_path = filepath
        # Prompt user if no path provided
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".msxpal",
                filetypes=[("MSX Palette File", "*.msxpal"), ("All Files", "*.*")],
                title="Save MSX Palette As...",
            )
        # Return False if user cancelled dialog
        if not save_path:
            return False

        try:
            # Open file in binary write mode
            with open(save_path, "wb") as f:
                # Sanity check palette length
                if len(self.active_msx_palette) != 16:
                    # Use internal print for non-interactive error
                    print("ERROR: Active palette length is not 16 during save!")
                    # Show message box only if called directly by user
                    if filepath is None:
                        messagebox.showerror(
                            "Palette Error",
                            "Internal Error: Active palette does not contain 16 colors.",
                        )
                    return False  # Indicate failure

                # Write each color as 3 bytes (R,G,B 0-7)
                for i in range(16):
                    hex_color = self.active_msx_palette[i]
                    r, g, b = self._hex_to_rgb7(hex_color)  # Convert hex to 0-7 range
                    packed_bytes = struct.pack("BBB", r, g, b)  # Pack as 3 bytes
                    f.write(packed_bytes)

            # Show success message ONLY if called directly by user
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Palette saved successfully to {os.path.basename(save_path)}",
                )
            return True  # Indicate success

        except Exception as e:
            # Always show error message on failure
            messagebox.showerror(
                "Save Palette Error",
                f"Failed to save palette file '{os.path.basename(save_path)}':\n{e}",
            )
            return False  # Indicate failure

    def open_palette(self, filepath=None):
        """Loads a 16-color palette from a binary file.
        Returns True on success, False on failure/cancel.
        If filepath is None, prompts the user.
        """
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Palette File", "*.msxpal"), ("All Files", "*.*")],
                title="Open MSX Palette",
            )
        if not load_path:
            return False

        try:
            expected_size = 16 * 3  
            new_palette_hex = []  

            with open(load_path, "rb") as f:
                palette_data = f.read(expected_size + 1)

                if len(palette_data) < expected_size:
                    raise ValueError(
                        f"Invalid file size. Expected {expected_size} bytes, got {len(palette_data)}."
                    )
                if len(palette_data) > expected_size:
                    print(
                        f"Warning: File '{os.path.basename(load_path)}' is larger than expected ({expected_size} bytes). Extra data ignored."
                    )

                for i in range(16):
                    offset = i * 3
                    r_val, g_val, b_val = struct.unpack_from("BBB", palette_data, offset) # Renamed r,g,b

                    if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                        print(
                            f"Warning: Invalid RGB ({r_val},{g_val},{b_val}) at slot {i} in '{os.path.basename(load_path)}'. Clamping."
                        )
                        r_val = max(0, min(7, r_val))
                        g_val = max(0, min(7, g_val))
                        b_val = max(0, min(7, b_val))

                    hex_color = self._rgb7_to_hex(r_val, g_val, b_val)
                    new_palette_hex.append(hex_color)

            confirm = True  
            if filepath is None:  
                confirm = messagebox.askokcancel(
                    "Load Palette",
                    "Replace the current active palette with data from this file?",
                )

            if confirm:
                # Clear marks BEFORE data change and full redraw
                if self._clear_marked_unused(trigger_redraw=False): 
                    # If marks were cleared, a full redraw will happen anyway via update_all_displays
                    pass # No need for immediate redraw here
                
                self.active_msx_palette = new_palette_hex
                self.selected_palette_slot = 0
                global selected_color_index
                selected_color_index = 0 # Default to first color
                
                self.clear_all_caches()
                self.invalidate_minimap_background_cache()  
                self.update_all_displays(changed_level="all") # This will redraw everything
                
                if filepath is None: # Only switch tab if loaded individually
                    self.notebook.select(self.tab_palette_editor)
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded palette from {os.path.basename(load_path)}",
                    )
                # Mark project modified only if loaded individually (project load handles its own flag)
                if filepath is None:
                    self._mark_project_modified()
                return True  

            else: # User cancelled confirmation
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (
            struct.error,
            ValueError,
            EOFError,
        ) as e:  
            messagebox.showerror(
                "Open Palette Error",
                f"Invalid data, size, or format in palette file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Palette Error",
                f"Failed to open or parse palette file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_tileset(self, filepath=None):
        """Saves the current tileset data to a binary file.
        Returns True on success, False on failure/cancel.
        If filepath is None, prompts the user.
        """
        global num_tiles_in_set, tileset_patterns, tileset_colors
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Tiles",
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Save Tileset As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write number of tiles
                num_byte = struct.pack("B", num_tiles_in_set)
                f.write(num_byte)
                # Write data for each tile
                for i in range(num_tiles_in_set):
                    # Write pattern data (8 bytes)
                    pattern = tileset_patterns[i]
                    for r in range(TILE_HEIGHT):
                        byte_val = 0
                        row_pattern = pattern[r]
                        for c in range(TILE_WIDTH):
                            if row_pattern[c] == 1:
                                byte_val = byte_val | (1 << (7 - c))
                        pattern_byte = struct.pack("B", byte_val)
                        f.write(pattern_byte)
                    # Write color data (8 bytes)
                    colors = tileset_colors[i]
                    for r in range(TILE_HEIGHT):
                        fg_idx, bg_idx = colors[r]
                        color_byte_val = ((fg_idx & 0x0F) << 4) | (bg_idx & 0x0F)
                        color_byte = struct.pack("B", color_byte_val)
                        f.write(color_byte)
            # Show success message ONLY if called directly by user
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Tileset saved successfully to {os.path.basename(save_path)}",
                )
            return True  # Indicate success
        except Exception as e:
            messagebox.showerror(
                "Save Tileset Error",
                f"Failed to save tileset file '{os.path.basename(save_path)}':\n{e}",
            )
            return False  # Indicate failure

    def open_tileset(self, filepath=None):
        """Loads tileset data from a binary file.
        Returns True on success, False on failure/cancel.
        If filepath is None, prompts the user.
        """
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, selected_tile_for_supertile
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Open Tileset",
            )
        if not load_path:
            return False

        try:
            with open(load_path, "rb") as f:
                num_tiles_byte = f.read(1)
                if not num_tiles_byte:
                    raise ValueError("File empty or missing tile count byte.")
                loaded_num_tiles = struct.unpack("B", num_tiles_byte)[0]
                if not (1 <= loaded_num_tiles <= MAX_TILES):
                    raise ValueError(
                        f"Invalid tile count in file: {loaded_num_tiles} (must be 1-{MAX_TILES})"
                    )

                new_patterns = [
                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]
                new_colors = [
                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]

                for i in range(loaded_num_tiles):
                    pattern_bytes = f.read(
                        TILE_HEIGHT
                    )  
                    if len(pattern_bytes) < TILE_HEIGHT:
                        raise EOFError(f"EOF pattern T:{i}")
                    for r_idx in range(TILE_HEIGHT): # Renamed r
                        byte_val = pattern_bytes[r_idx]  
                        for c in range(TILE_WIDTH):
                            pixel_bit = (byte_val >> (7 - c)) & 1
                            new_patterns[i][r_idx][c] = pixel_bit
                    color_bytes = f.read(TILE_HEIGHT)  
                    if len(color_bytes) < TILE_HEIGHT:
                        raise EOFError(f"EOF color T:{i}")
                    for r_idx in range(TILE_HEIGHT): # Renamed r
                        byte_val = color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        if not (0 <= fg_idx < 16 and 0 <= bg_idx < 16):
                            print(
                                f"Warning: Invalid palette index T:{i} R:{r_idx} ({fg_idx},{bg_idx}). Using default."
                            )
                            new_colors[i][r_idx] = (WHITE_IDX, BLACK_IDX)
                        else:
                            new_colors[i][r_idx] = (fg_idx, bg_idx)

            confirm = True
            if filepath is None:  
                confirm = messagebox.askokcancel(
                    "Load Tileset",
                    f"Replace current tileset with {loaded_num_tiles} tile(s) from this file?",
                )

            if confirm:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Full redraw will happen later
                
                tileset_patterns = new_patterns
                tileset_colors = new_colors
                num_tiles_in_set = loaded_num_tiles
                current_tile_index = max(
                    0, min(current_tile_index, num_tiles_in_set - 1)
                )
                selected_tile_for_supertile = max(
                    0, min(selected_tile_for_supertile, num_tiles_in_set - 1)
                )

                self.clear_all_caches()  
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()  
                self._update_edit_menu_state()  

                if filepath is None:
                    self.notebook.select(self.tab_tile_editor)
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_tiles_in_set} tiles from {os.path.basename(load_path)}",
                    )
                if filepath is None:
                    self._mark_project_modified()
                return True  
            else:
                return False  

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Tileset Error",
                f"Invalid data, size, or format in tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Tileset Error",
                f"Failed to open or parse tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_supertiles(self, filepath=None):
        global num_supertiles, supertiles_data # supertiles_data is global
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Super",
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Save Supertiles As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write count of supertiles
                f.write(struct.pack("B", num_supertiles))
                
                # Write supertile grid dimensions
                f.write(struct.pack("B", self.supertile_grid_width))
                f.write(struct.pack("B", self.supertile_grid_height))
                
                # Write data for each supertile
                for i in range(num_supertiles):
                    definition = supertiles_data[i] # Access global
                    # Basic check for consistency, though data should be correct by now
                    if len(definition) != self.supertile_grid_height or \
                       (self.supertile_grid_height > 0 and (len(definition[0]) != self.supertile_grid_width)):
                        # print(f"Warning: Supertile {i} has inconsistent dimensions during save. Attempting to save what's there.")
                        # This could lead to problems on load if not handled carefully.
                        # For robustness, one might choose to pad/truncate here, or skip saving this ST.
                        # For now, we proceed, assuming the loops below will handle "ragged" arrays gracefully
                        # by only iterating up to the project's self.supertile_grid_width/height.
                        pass


                    for r_st in range(self.supertile_grid_height):
                        # Handle case where definition might be shorter than expected (e.g. corrupted data)
                        if r_st < len(definition):
                            row_data = definition[r_st]
                            for c_st in range(self.supertile_grid_width):
                                if c_st < len(row_data):
                                    tile_index_val = row_data[c_st]
                                else: # Row is too short, pad with 0
                                    tile_index_val = 0
                                f.write(struct.pack("B", tile_index_val))
                        else: # Definition is too short in height, pad rows with 0s
                            for _ in range(self.supertile_grid_width):
                                f.write(struct.pack("B", 0))
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Supertiles saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Supertile Error",
                f"Failed to save supertiles file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_supertiles(self, filepath=None):
        global supertiles_data, num_supertiles, current_supertile_index, selected_supertile_for_map, num_tiles_in_set
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Open Supertiles",
            )
        if not load_path:
            return False

        try:
            loaded_grid_width_from_file = 0 # To store dimensions from file
            loaded_grid_height_from_file = 0
            loaded_num_st_from_file = 0
            
            # Temporary list to hold data read from file before committing to globals
            temp_supertiles_data_from_file = []


            with open(load_path, "rb") as f:
                num_st_byte = f.read(1)
                if not num_st_byte:
                    raise ValueError("File empty or missing supertile count.")
                loaded_num_st_from_file = struct.unpack("B", num_st_byte)[0]
                if not (0 <= loaded_num_st_from_file <= MAX_SUPERTILES): # Allow 0 for an empty set
                    raise ValueError(
                        f"Invalid supertile count in file: {loaded_num_st_from_file} (must be 0-{MAX_SUPERTILES})"
                    )
                if loaded_num_st_from_file == 0 : # Handle empty supertile set gracefully
                    # print("Info: Loaded empty supertile set (0 supertiles).")
                    loaded_grid_width_from_file = SUPERTILE_GRID_DIM # Use default if file is empty of STs
                    loaded_grid_height_from_file = SUPERTILE_GRID_DIM
                    # temp_supertiles_data_from_file will remain empty
                else: # Proceed to read dimensions and data if count > 0
                    dim_w_byte = f.read(1)
                    dim_h_byte = f.read(1)
                    if not dim_w_byte or not dim_h_byte:
                        raise ValueError("File missing supertile dimension bytes.")
                    
                    loaded_grid_width_from_file = struct.unpack("B", dim_w_byte)[0]
                    loaded_grid_height_from_file = struct.unpack("B", dim_h_byte)[0]

                    if not (1 <= loaded_grid_width_from_file <= 32 and 1 <= loaded_grid_height_from_file <= 32):
                        raise ValueError(f"Invalid supertile dimensions in file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")

                    # Initialize temp_supertiles_data_from_file structure
                    temp_supertiles_data_from_file = [
                        [[0 for _c in range(loaded_grid_width_from_file)] for _r in range(loaded_grid_height_from_file)]
                        for _st in range(loaded_num_st_from_file) # Only for the count in file
                    ]
                    
                    bytes_per_tile_val = 1
                    tiles_in_one_def = loaded_grid_width_from_file * loaded_grid_height_from_file
                    bytes_per_def = tiles_in_one_def * bytes_per_tile_val

                    for i in range(loaded_num_st_from_file):
                        st_bytes_read = f.read(bytes_per_def)
                        if len(st_bytes_read) < bytes_per_def:
                            raise EOFError(f"EOF reading data for supertile {i}")
                        byte_idx_val = 0
                        for r_load in range(loaded_grid_height_from_file):
                            for c_load in range(loaded_grid_width_from_file):
                                tile_idx_read = st_bytes_read[byte_idx_val]
                                byte_idx_val += 1
                                if not (0 <= tile_idx_read < num_tiles_in_set):
                                    # print(f"Warning: Invalid Tile index {tile_idx_read} in Supertile {i} at [{r_load},{c_load}]. Resetting to 0.")
                                    temp_supertiles_data_from_file[i][r_load][c_load] = 0
                                else:
                                    temp_supertiles_data_from_file[i][r_load][c_load] = tile_idx_read
            
            # At this point, file reading is done or an error was raised.

            confirm_load = True
            if filepath is None: # Only ask if opening stand-alone file
                confirm_load = messagebox.askokcancel(
                    "Load Supertiles",
                    f"Replace current supertiles with {loaded_num_st_from_file} definition(s) from this file?\n(Dimensions: {loaded_grid_width_from_file}W x {loaded_grid_height_from_file}H)",
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                # --- Commit loaded data to application state ---
                self.supertile_grid_width = loaded_grid_width_from_file
                self.supertile_grid_height = loaded_grid_height_from_file
                
                # Re-initialize global supertiles_data to MAX_SUPERTILES with new dimensions, then fill from temp
                supertiles_data = [
                    [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                    for _st_init in range(MAX_SUPERTILES)
                ]
                for i in range(loaded_num_st_from_file):
                    supertiles_data[i] = temp_supertiles_data_from_file[i]

                num_supertiles = loaded_num_st_from_file
                if num_supertiles == 0: # If loaded an empty set
                    num_supertiles = 1 # Ensure at least one supertile exists for the editor
                    # And ensure supertiles_data[0] is initialized correctly
                    supertiles_data[0] = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]


                current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
                selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

                self.supertile_image_cache.clear()
                self.invalidate_minimap_background_cache()
                
                self._reconfigure_supertile_definition_canvas() # Update canvas size
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()
                self._update_edit_menu_state()
                self._update_supertile_rotate_button_state() # Update rotate button state

                if filepath is None:
                    self.notebook.select(self.tab_supertile_editor)
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_supertiles} supertiles ({self.supertile_grid_width}x{self.supertile_grid_height}) from {os.path.basename(load_path)}",
                    )
                if filepath is None:
                    self._mark_project_modified()
                return True
            else: # User cancelled confirmation
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Invalid data, size, or format in supertile file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Failed to open or parse supertiles file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_map(self, filepath=None):
        """Saves the current map data to a binary file.
        Returns True on success, False on failure/cancel.
        If filepath is None, prompts the user.
        """
        global map_width, map_height, map_data
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Map",
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Save Map As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write dimensions (Big-endian)
                dim_bytes = struct.pack(">HH", map_width, map_height)
                f.write(dim_bytes)
                # Write map data
                for r in range(map_height):
                    row_data = map_data[r]
                    for c in range(map_width):
                        supertile_index = row_data[c]
                        index_byte = struct.pack("B", supertile_index)
                        f.write(index_byte)
            # Show success message ONLY if called directly
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Map saved successfully to {os.path.basename(save_path)}",
                )
            return True  # Indicate success
        except Exception as e:
            messagebox.showerror(
                "Save Map Error",
                f"Failed to save map file '{os.path.basename(save_path)}':\n{e}",
            )
            return False  # Indicate failure

    def open_map(self, filepath=None):
        global map_data, map_width, map_height, num_supertiles
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Open Map",
            )
        if not load_path:
            return False

        try:
            loaded_w_map = 0
            loaded_h_map = 0
            new_map_data_from_file = [] # Temp storage

            with open(load_path, "rb") as f:
                dim_bytes = f.read(4)
                if len(dim_bytes) < 4:
                    raise ValueError("Invalid map header: not enough bytes for dimensions.")
                loaded_w_map, loaded_h_map = struct.unpack(">HH", dim_bytes)
                
                min_dim_map, max_dim_map = 1, 1024
                if not (min_dim_map <= loaded_w_map <= max_dim_map and min_dim_map <= loaded_h_map <= max_dim_map):
                    raise ValueError(f"Invalid map dimensions in file: {loaded_w_map}x{loaded_h_map} (must be {min_dim_map}-{max_dim_map} per side)")

                new_map_data_from_file = [[0 for _c in range(loaded_w_map)] for _r in range(loaded_h_map)]

                for r_map_load in range(loaded_h_map):
                    for c_map_load in range(loaded_w_map):
                        st_idx_byte_read = f.read(1)
                        if not st_idx_byte_read:
                            raise EOFError(f"EOF reading map data at row {r_map_load}, col {c_map_load}")
                        
                        supertile_index_val_read = struct.unpack("B", st_idx_byte_read)[0]
                        
                        if not (0 <= supertile_index_val_read < num_supertiles): # Validate against current num_supertiles
                             # print(f"Warning: Invalid Supertile index {supertile_index_val_read} in Map at [{r_map_load},{c_map_load}]. Max is {num_supertiles-1}. Resetting to 0.")
                             new_map_data_from_file[r_map_load][c_map_load] = 0
                        else:
                            new_map_data_from_file[r_map_load][c_map_load] = supertile_index_val_read
            
            # File reading complete or error raised

            confirm_load_map = True
            if filepath is None: # Only ask if opening stand-alone
                confirm_load_map = messagebox.askokcancel("Load Map", "Replace current map with data from this file?")

            if confirm_load_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                map_width = loaded_w_map
                map_height = loaded_h_map
                map_data = new_map_data_from_file # Assign from temp

                self.invalidate_minimap_background_cache()
                # The change in supertile dimensions (from a previous open_supertiles) will affect map display
                self.update_all_displays(changed_level="all") 
                self._trigger_minimap_reconfigure()
                
                if filepath is None:
                    self.notebook.select(self.tab_map_editor)
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {map_width}x{map_height} map from {os.path.basename(load_path)}",
                    )
                if filepath is None:
                    self._mark_project_modified()
                return True
            else: # User cancelled
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Map Error",
                f"Invalid data, size, or format in map file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Map Error",
                f"Failed to open or parse map file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    # --- Project Save/Load Methods ---

    def save_project_as(self):
        """Prompts user for a base project name and saves all four component files."""
        # Ask for base path (user types name, selects directory)
        base_path = filedialog.asksaveasfilename(
            filetypes=[("MSX Project (Enter Base Name)", "*.*")],  # Filter description
            title="Save Project As (Enter Base Name)",
        )
        # Exit if cancelled
        if not base_path:
            return

        # Construct full paths for each component file
        pal_path = base_path + ".msxpal"
        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        # Attempt to save all components sequentially
        # Use the modified save methods which return True/False
        # Stop saving if any component fails
        success = True
        if success:
            success = self.save_palette(pal_path)
        if success:
            success = self.save_tileset(til_path)
        if success:
            success = self.save_supertiles(sup_path)
        if success:
            success = self.save_map(map_path)

        # Update state and UI if all saves were successful
        if success:
            self.current_project_base_path = base_path  # Store the base path
            self.project_modified = False
            self._update_window_title()
        else:
            # Individual error messages should have been shown by the failing save_* method
            messagebox.showerror(
                "Project Save Error", "One or more project components failed to save."
            )

    def save_project(self):
        """Saves the project using the current base path, or calls Save As if none."""
        # Check if a project path is already known
        if self.current_project_base_path:
            base_path = self.current_project_base_path
            # Construct component paths
            pal_path = base_path + ".msxpal"
            til_path = base_path + ".SC4Tiles"
            sup_path = base_path + ".SC4Super"
            map_path = base_path + ".SC4Map"

            # Attempt to save all components
            success = True
            if success:
                success = self.save_palette(pal_path)
            if success:
                success = self.save_tileset(til_path)
            if success:
                success = self.save_supertiles(sup_path)
            if success:
                success = self.save_map(map_path)

            # Show appropriate message
            if success:
                self.project_modified = False
                self._update_window_title()
            else:
                messagebox.showerror(
                    "Project Save Error",
                    "One or more project components failed to save.",
                )
        else:
            # If no project path is known, act like "Save As..."
            self.save_project_as()

    def open_project(self):
        """Prompts user to select ONE project file, then loads all four components."""
        filepath = filedialog.askopenfilename(
            filetypes=[
                (
                    "MSX Tileset File (*.SC4Tiles)", # Default to a common component
                    "*.SC4Tiles",
                ),  
                ("MSX Palette File (*.msxpal)", "*.msxpal"),
                ("MSX Supertile File (*.SC4Super)", "*.SC4Super"),
                ("MSX Map File (*.SC4Map)", "*.SC4Map"),
                ("All Files", "*.*"),
            ],
            title="Open Project (Select Any Component File)",
        )
        if not filepath:
            return

        directory = os.path.dirname(filepath)
        base_name_with_ext = os.path.basename(filepath)
        base_name, _ = os.path.splitext(base_name_with_ext)
        base_path = os.path.join(directory, base_name)

        pal_path = base_path + ".msxpal"
        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        missing_files = []
        if not os.path.exists(pal_path):
            missing_files.append(os.path.basename(pal_path))
        if not os.path.exists(til_path):
            missing_files.append(os.path.basename(til_path))
        if not os.path.exists(sup_path):
            missing_files.append(os.path.basename(sup_path))
        if not os.path.exists(map_path):
            missing_files.append(os.path.basename(map_path))

        if missing_files:
            messagebox.showerror(
                "Open Project Error",
                f"Cannot open project '{base_name}'.\n"
                f"Missing component file(s):\n" + "\n".join(missing_files),
            )
            return

        if self.project_modified:
            confirm_discard = messagebox.askokcancel(
                "Unsaved Changes",
                f"Discard current unsaved changes and open project '{base_name}'?",
                icon="warning"
            )
            if not confirm_discard:
                return
        
        self.is_ctrl_pressed = False
        self.is_shift_pressed = False
        self.current_mouse_action = None
        
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data
        tile_clipboard_pattern = None
        tile_clipboard_colors = None
        supertile_clipboard_data = None
        self.map_clipboard_data = None
        self._clear_map_selection() 
        self._clear_paste_preview_rect() 

        # Clear marked unused state BEFORE loading new data
        self._clear_marked_unused(trigger_redraw=False)

        self.clear_all_caches()
        self.invalidate_minimap_background_cache()

        success = True
        print(f"Loading project '{base_name}'...")

        # Load palette first, then tileset (STs depend on tiles, Map depends on STs)
        if success:
            print(f"  Loading palette: {pal_path}")
            success = self.open_palette(pal_path)
        if success:
            print(f"  Loading tileset: {til_path}")
            success = self.open_tileset(til_path) # Needs num_tiles_in_set for ST validation
        if success:
            print(f"  Loading supertiles: {sup_path}")
            success = self.open_supertiles(sup_path) # Needs num_supertiles for Map validation
        if success:
            print(f"  Loading map: {map_path}")
            success = self.open_map(map_path)

        self.is_ctrl_pressed = False
        self.is_shift_pressed = False
        self.current_mouse_action = None
        
        if success:
            self.project_modified = False 
            self.current_project_base_path = base_path
            self._update_window_title()
            self._update_editor_button_states()
            self.notebook.select(self.tab_map_editor) 
            self.update_all_displays(changed_level="all")
            self._update_edit_menu_state()
            self.root.after(10, self._update_map_cursor) 
        else:
            messagebox.showerror(
                "Project Open Error",
                f"Failed to load one or more components for project '{base_name}'. The application state might be inconsistent.",
            )
            self.project_modified = True 
            self._update_window_title()
            self._update_editor_button_states()
            self.update_all_displays(changed_level="all")
            self._update_edit_menu_state()
            self.root.after(10, self._update_map_cursor)

    # --- Edit Menu Commands ---

    def set_tileset_size(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        prompt = f"Enter number of tiles (1-{MAX_TILES}):"
        new_size_str = simpledialog.askstring(
            "Set Tileset Size", prompt, initialvalue=str(num_tiles_in_set)
        )

        if new_size_str:
            try:
                new_size = int(new_size_str)

                if not (1 <= new_size <= MAX_TILES):
                    messagebox.showerror(
                        "Invalid Size", f"Size must be between 1 and {MAX_TILES}."
                    )
                    return

                if new_size == num_tiles_in_set:
                    return

                reduced = new_size < num_tiles_in_set
                confirmed_resize = True # Renamed for clarity
                if reduced:
                    affected_supertiles_list = set() # Use a set to avoid duplicates
                    for del_idx_tile in range(new_size, num_tiles_in_set):
                        # _check_tile_usage uses self.supertile_grid_width/height internally
                        usage_list = self._check_tile_usage(del_idx_tile)
                        for st_idx_affected in usage_list:
                            affected_supertiles_list.add(st_idx_affected)

                    confirm_prompt_msg = f"Reducing size to {new_size} will discard tiles {new_size} to {num_tiles_in_set-1}."
                    if affected_supertiles_list:
                        confirm_prompt_msg += "\n\n*** WARNING! ***\nDiscarded tiles are used by Supertile(s):\n"
                        affected_list_sorted = sorted(list(affected_supertiles_list))
                        confirm_prompt_msg += ", ".join(map(str, affected_list_sorted[:10]))
                        if len(affected_list_sorted) > 10:
                            confirm_prompt_msg += "..."
                        confirm_prompt_msg += "\n\nReferences to discarded tiles in these Supertiles will be reset to Tile 0."

                    confirmed_resize = messagebox.askokcancel(
                        "Reduce Tileset Size", confirm_prompt_msg, icon="warning"
                    )

                if confirmed_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()

                    if reduced:
                        for del_idx_tile_loop in range(new_size, num_tiles_in_set):
                            # _update_supertile_refs_for_tile_change uses self.supertile_grid_width/height
                            self._update_supertile_refs_for_tile_change(
                                del_idx_tile_loop, "delete"
                            )
                            self._adjust_marked_indices_after_delete(self.marked_unused_tiles, del_idx_tile_loop)
                        for i in range(new_size, num_tiles_in_set):
                            self.invalidate_tile_cache(i) # Invalidate cache for tiles being removed from active set
                        
                        # Trim the lists
                        del tileset_patterns[new_size:]
                        del tileset_colors[new_size:]
                        # Ensure they are padded back to MAX_TILES if that's the desired behavior for fixed-size arrays
                        # For dynamic Python lists, this just shortens them.
                        # If MAX_TILES is a hard limit for array indexing elsewhere, pad them:
                        # while len(tileset_patterns) < MAX_TILES:
                        #     tileset_patterns.append([[0]*TILE_WIDTH for _r in range(TILE_HEIGHT)])
                        #     tileset_colors.append([(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)])


                    elif new_size > num_tiles_in_set: # Increasing size
                        # Add new blank tiles up to new_size, but not exceeding MAX_TILES
                        tiles_to_add = new_size - num_tiles_in_set
                        for _ in range(tiles_to_add):
                            if len(tileset_patterns) < MAX_TILES: # Check against actual list capacity
                                tileset_patterns.append(
                                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                                )
                                tileset_colors.append(
                                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                                )
                            else: # Should not happen if new_size <= MAX_TILES
                                break 
                    
                    num_tiles_in_set = new_size # Update the count of active tiles

                    current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
                    selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
                # print(f"Error setting tileset size: {e}")

    def set_supertile_count(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        prompt = f"Enter number of supertiles (1-{MAX_SUPERTILES}):"
        new_count_str = simpledialog.askstring(
            "Set Supertile Count", prompt, initialvalue=str(num_supertiles)
        )

        if new_count_str:
            try:
                new_count = int(new_count_str)

                if not (1 <= new_count <= MAX_SUPERTILES):
                    messagebox.showerror(
                        "Invalid Count",
                        f"Count must be between 1 and {MAX_SUPERTILES}.",
                    )
                    return

                if new_count == num_supertiles:
                    return

                reduced_count = new_count < num_supertiles # Renamed for clarity
                confirmed_st_resize = True # Renamed
                if reduced_count:
                    affected_map_cells_list = []
                    for del_idx_st in range(new_count, num_supertiles):
                        usage_on_map = self._check_supertile_usage(del_idx_st)
                        affected_map_cells_list.extend(usage_on_map)

                    confirm_prompt_st = f"Reducing count to {new_count} will discard supertiles {new_count} to {num_supertiles-1}."
                    if affected_map_cells_list: # Check if list is not empty
                        confirm_prompt_st += "\n\n*** WARNING! ***\nDiscarded supertiles are used on the Map."
                        confirm_prompt_st += (
                            "\n\nReferences on the Map will be reset to Supertile 0."
                        )

                    confirmed_st_resize = messagebox.askokcancel(
                        "Reduce Supertile Count", confirm_prompt_st, icon="warning"
                    )

                if confirmed_st_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()

                    if reduced_count:
                        for del_idx_st_loop in range(new_count, num_supertiles):
                            self._update_map_refs_for_supertile_change(
                                del_idx_st_loop, "delete"
                            )
                            self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, del_idx_st_loop)
                        
                        # Trim the supertiles_data list
                        del supertiles_data[new_count:]
                        # Pad back to MAX_SUPERTILES if it's meant to be fixed-size array for indexing
                        # For dynamic lists, this just shortens.
                        # If padding:
                        # while len(supertiles_data) < MAX_SUPERTILES:
                        #    supertiles_data.append(
                        #        [[0] * self.supertile_grid_width for _r in range(self.supertile_grid_height)]
                        #    )


                    elif new_count > num_supertiles: # Increasing count
                        st_to_add = new_count - num_supertiles
                        for _ in range(st_to_add):
                            if len(supertiles_data) < MAX_SUPERTILES:
                                supertiles_data.append(
                                    [[0] * self.supertile_grid_width for _r_add in range(self.supertile_grid_height)]
                                )
                            else: # Should not happen if new_count <= MAX_SUPERTILES
                                break
                    
                    num_supertiles = new_count # Update active count

                    current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
                    selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

                    self.supertile_image_cache.clear()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(
                        changed_level="all" # Changed to all for safety if map refs changed
                    )
                    self._update_editor_button_states()
                    self._update_edit_menu_state()
                    self._update_supertile_rotate_button_state() # Though ST count doesn't change W/H


            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
                # print(f"Error setting supertile count: {e}")

    def set_map_dimensions(self):
        global map_width, map_height, map_data

        prompt = "Enter new dimensions (Width x Height):"
        dims_str = simpledialog.askstring(
            "Set Map Dimensions", prompt, initialvalue=f"{map_width}x{map_height}"
        )

        if dims_str:
            try:
                parts = dims_str.lower().split("x")
                if len(parts) != 2:
                    raise ValueError("Format must be WidthxHeight")

                new_w_str = parts[0].strip()
                new_h_str = parts[1].strip()
                new_w = int(new_w_str)
                new_h = int(new_h_str)

                min_dim, max_dim = 1, 1024
                if not (min_dim <= new_w <= max_dim):
                    raise ValueError(f"Width must be between {min_dim} and {max_dim}")
                if not (min_dim <= new_h <= max_dim):
                    raise ValueError(f"Height must be between {min_dim} and {max_dim}")

                if new_w == map_width and new_h == map_height:
                    return  

                reducing = new_w < map_width or new_h < map_height
                confirmed = True  
                if reducing:
                    confirm_prompt = "Reducing map size will discard data outside boundaries. Proceed?"
                    confirmed = messagebox.askokcancel("Resize Map", confirm_prompt)

                if confirmed:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass
                    self._mark_project_modified()
                    new_map_data = [[0 for _ in range(new_w)] for _ in range(new_h)]
                    rows_to_copy = min(map_height, new_h)
                    cols_to_copy = min(map_width, new_w)
                    for r_idx in range(rows_to_copy): # Renamed r
                        for c_idx in range(cols_to_copy): # Renamed c
                            new_map_data[r_idx][c_idx] = map_data[r_idx][c_idx]

                    map_width = new_w
                    map_height = new_h
                    map_data = new_map_data

                    self.update_all_displays(changed_level="map")
                    self._trigger_minimap_reconfigure()  

            except ValueError as e:
                messagebox.showerror("Invalid Input", f"Error setting dimensions: {e}")
            except Exception as e:
                messagebox.showerror(
                    "Error", f"An unexpected error occurred during resize: {e}"
                )

    def clear_current_tile(self):
        global tileset_patterns, tileset_colors, current_tile_index, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        prompt = f"Clear pattern and reset colors for tile {current_tile_index}?"
        if messagebox.askokcancel("Clear Tile", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all") 

            self._mark_project_modified()
            tileset_patterns[current_tile_index] = [
                [0] * TILE_WIDTH for _ in range(TILE_HEIGHT)
            ]
            tileset_colors[current_tile_index] = [
                (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
            ]
            self.invalidate_tile_cache(current_tile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="tile")

    def clear_current_supertile(self):
        global supertiles_data, current_supertile_index # supertiles_data is global
        if not (0 <= current_supertile_index < num_supertiles):
            return
        prompt = f"Clear definition (set all to tile 0) for supertile {current_supertile_index}?"
        if messagebox.askokcancel("Clear Supertile", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            self._mark_project_modified()
            # Initialize with current project's supertile dimensions
            supertiles_data[current_supertile_index] = [
                [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            ]
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles): # If no marks were present
                self.update_all_displays(changed_level="supertile")
            else: # If marks were cleared, a full redraw (from above) already handled it or will.
                  # To be safe, if this branch is hit, ensure the supertile tab is updated.
                self.update_all_displays(changed_level="supertile")

    def clear_map(self):
        global map_data, map_width, map_height
        prompt = "Clear entire map (set all to supertile 0)?"
        if messagebox.askokcancel("Clear Map", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            self._mark_project_modified()
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
            self.invalidate_minimap_background_cache()
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="map")

    def copy_current_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Copy Tile", "No valid tile selected.")
            return
        tile_clipboard_pattern = copy.deepcopy(tileset_patterns[current_tile_index])
        tile_clipboard_colors = copy.deepcopy(tileset_colors[current_tile_index])
        print(f"Tile {current_tile_index} copied.")
        self._update_edit_menu_state()

    def paste_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if tile_clipboard_pattern is None or tile_clipboard_colors is None:
            messagebox.showinfo("Paste Tile", "Tile clipboard is empty.")
            return
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Paste Tile", "No valid tile selected to paste onto.") # Clarified message
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        self._mark_project_modified()
        tileset_patterns[current_tile_index] = copy.deepcopy(tile_clipboard_pattern)
        tileset_colors[current_tile_index] = copy.deepcopy(tile_clipboard_colors)
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        print(f"Pasted onto Tile {current_tile_index}.")

    def copy_current_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Copy Supertile", "No valid supertile selected.")
            return
        
        # The clipboard will store a definition matching current project's ST dimensions
        supertile_clipboard_data = copy.deepcopy(
            supertiles_data[current_supertile_index] # supertiles_data is global
        )
        # Store dimensions with clipboard data for safer paste
        if hasattr(self, 'supertile_grid_width') and hasattr(self, 'supertile_grid_height'):
             # This is a good idea, but supertile_clipboard_data is just the list of lists currently.
             # To store dimensions, we'd need to change it to a dictionary:
             # self.supertile_clipboard_data_with_dims = {
             #    "width": self.supertile_grid_width,
             #    "height": self.supertile_grid_height,
             #    "data": copy.deepcopy(supertiles_data[current_supertile_index])
             # }
             # For now, sticking to existing global structure of supertile_clipboard_data.
             # Paste operation will assume clipboard data matches current project ST dimensions.
             pass

        print(f"Supertile {current_supertile_index} copied.")
        self._update_edit_menu_state()

    def paste_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if supertile_clipboard_data is None:
            messagebox.showinfo("Paste Supertile", "Supertile clipboard is empty.")
            return
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Paste Supertile", "No valid supertile selected to paste onto.")
            return
        
        # --- Optional: Check for dimension mismatch if clipboard stored them ---
        # if hasattr(self, 'supertile_clipboard_data_with_dims'): # If clipboard was a dict
        #     clip_w = self.supertile_clipboard_data_with_dims["width"]
        #     clip_h = self.supertile_clipboard_data_with_dims["height"]
        #     clip_data_actual = self.supertile_clipboard_data_with_dims["data"]
        #     if clip_w != self.supertile_grid_width or clip_h != self.supertile_grid_height:
        #         if not messagebox.askokcancel("Dimension Mismatch",
        #             f"Clipboard ST is {clip_w}x{clip_h}, current project STs are {self.supertile_grid_width}x{self.supertile_grid_height}.\n"
        #             "Pasting may result in data truncation or padding. Continue?"):
        #             return
        #         # If continuing, would need logic to crop/pad clip_data_actual to fit current dimensions
        #         # For now, we assume direct copy of structure.
        #         # This is a placeholder for more advanced handling.
        # else:
        #     clip_data_actual = supertile_clipboard_data # Use as is

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        # Direct copy of list structure. Assumes dimensions match.
        # If clipboard_data is from a different ST dimension, this could lead to issues.
        try:
            # Check clipboard structure against current supertile dimensions
            # This is a basic check; more robust would be deep comparison or explicit padding/truncation.
            if len(supertile_clipboard_data) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(supertile_clipboard_data[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0):
                supertiles_data[current_supertile_index] = copy.deepcopy(
                    supertile_clipboard_data # Global clipboard data
                )
                self._mark_project_modified()
                self.invalidate_supertile_cache(current_supertile_index)
                self.invalidate_minimap_background_cache()
                if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                    self.update_all_displays(changed_level="supertile")
                else:
                    self.update_all_displays(changed_level="supertile") # Ensure supertile tab is updated
                print(f"Pasted onto Supertile {current_supertile_index}.")
            else:
                messagebox.showerror("Paste Error", "Supertile clipboard dimensions do not match current project supertile dimensions. Paste aborted.")
                # If marks were cleared but paste failed, redraw to reflect current state
                if self.marked_unused_tiles or self.marked_unused_supertiles:
                     self.update_all_displays(changed_level="all")

        except Exception as e:
            messagebox.showerror("Paste Error", f"Could not paste supertile data due to structure mismatch or error: {e}")
            # If marks were cleared but paste failed
            if self.marked_unused_tiles or self.marked_unused_supertiles:
                 self.update_all_displays(changed_level="all")

    def add_new_tile(self):
        global num_tiles_in_set, current_tile_index, WHITE_IDX, BLACK_IDX
        if num_tiles_in_set >= MAX_TILES:
            messagebox.showwarning("Maximum Tiles", f"Max {MAX_TILES} tiles reached.")
            return
        num_tiles_in_set += 1
        new_tile_idx = num_tiles_in_set - 1
        self._mark_project_modified()
        tileset_patterns[new_tile_idx] = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        tileset_colors[new_tile_idx] = [
            (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
        ]
        current_tile_index = new_tile_idx
        self.update_all_displays(changed_level="tile")
        self.scroll_viewers_to_tile(current_tile_index)

    def add_new_supertile(self):
        global num_supertiles, current_supertile_index, supertiles_data # supertiles_data is global
        if num_supertiles >= MAX_SUPERTILES:
            messagebox.showwarning(
                "Maximum Supertiles", f"Max {MAX_SUPERTILES} supertiles reached."
            )
            return
        
        if self._clear_marked_unused(trigger_redraw=False): # Clear marks before adding
            pass # Redraw will happen as part of update_all_displays

        num_supertiles += 1
        new_st_idx = num_supertiles - 1
        self._mark_project_modified()
        
        # Initialize new supertile with current project dimensions
        # supertiles_data is pre-allocated to MAX_SUPERTILES length.
        # We just need to set the definition for the new active supertile.
        if new_st_idx < len(supertiles_data): # Should always be true if num_supertiles <= MAX_SUPERTILES
            supertiles_data[new_st_idx] = [
                [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            ]
        else:
            # This case means MAX_SUPERTILES was exceeded by num_supertiles increment,
            # which should be caught by the check at the beginning.
            # However, as a safeguard if supertiles_data wasn't fully pre-allocated:
            # supertiles_data.append([
            #    [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            # ])
            print(f"Error: Attempted to add supertile beyond allocated 'supertiles_data' list size. Index: {new_st_idx}")
            num_supertiles -=1 # Revert count
            return


        current_supertile_index = new_st_idx
        
        self.supertile_image_cache.clear() # New ST might affect others if they were copies
        self.invalidate_minimap_background_cache() # Map data might change if this ST is used
        self.update_all_displays(changed_level="all") # Update all displays
        self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state() # Though adding doesn't change W/H
        print(f"Added new supertile {new_st_idx}")

    # ... (shift methods unchanged) ...
    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        first_pattern_row = current_pattern[0]
        first_color_row = current_colors[0]
        for i in range(TILE_HEIGHT - 1):
            current_pattern[i] = current_pattern[i + 1]
            current_colors[i] = current_colors[i + 1]
        current_pattern[TILE_HEIGHT - 1] = first_pattern_row
        current_colors[TILE_HEIGHT - 1] = first_color_row
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted up.")

    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        last_pattern_row = current_pattern[TILE_HEIGHT - 1]
        last_color_row = current_colors[TILE_HEIGHT - 1]
        for i in range(TILE_HEIGHT - 1, 0, -1):
            current_pattern[i] = current_pattern[i - 1]
            current_colors[i] = current_colors[i - 1]
        current_pattern[0] = last_pattern_row
        current_colors[0] = last_color_row
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted down.")

    def shift_tile_left(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        for r in range(TILE_HEIGHT):
            row_data = current_pattern[r]
            if TILE_WIDTH > 0:
                first_pixel = row_data[0]
            for c in range(TILE_WIDTH - 1):
                row_data[c] = row_data[c + 1]
            row_data[TILE_WIDTH - 1] = first_pixel
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted left.")

    def shift_tile_right(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        for r in range(TILE_HEIGHT):
            row_data = current_pattern[r]
            if TILE_WIDTH > 0:
                last_pixel = row_data[TILE_WIDTH - 1]
            for c in range(TILE_WIDTH - 1, 0, -1):
                row_data[c] = row_data[c - 1]
            row_data[0] = last_pixel
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted right.")

    # --- Zoom Methods ---
    def change_map_zoom_mult(self, factor):  # Renamed from change_map_zoom
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        view_x1, view_y1, view_x2, view_y2 = (
            canvas.xview()[0],
            canvas.yview()[0],
            canvas.xview()[1],
            canvas.yview()[1],
        )
        center_x_canvas = canvas.canvasx(
            (canvas.winfo_width() / 2)
        )  # Approximation of center
        center_y_canvas = canvas.canvasy((canvas.winfo_height() / 2))
        self.zoom_map_at_point(factor, center_x_canvas, center_y_canvas)

    def set_map_zoom(self, new_zoom_level):
        """Sets absolute zoom level, centered on current canvas center."""
        min_zoom, max_zoom = 0.1, 6.0  # New limits
        safe_zoom = max(min_zoom, min(max_zoom, float(new_zoom_level)))
        current_zoom = self.map_zoom_level
        if abs(current_zoom - safe_zoom) > 1e-9:  # Avoid floating point noise
            factor = safe_zoom / current_zoom if current_zoom > 1e-9 else 1.0
            canvas = self.map_canvas
            center_x_canvas = canvas.canvasx(canvas.winfo_width() / 2)
            center_y_canvas = canvas.canvasy(canvas.winfo_height() / 2)
            self.zoom_map_at_point(factor, center_x_canvas, center_y_canvas)

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size based on 8x8 base and zoom."""
        base_tile_size = 8  # 100% zoom = 8 pixels
        zoomed_size = base_tile_size * self.map_zoom_level
        return max(1, int(zoomed_size))  # Ensure at least 1 pixel

    def zoom_map_at_point(self, factor, zoom_x_canvas, zoom_y_canvas):
        """Zooms the map by 'factor', keeping the point (zoom_x/y_canvas) stationary,
        and clamps scroll to prevent gaps and ensure edges align correctly."""
        canvas = self.map_canvas
        current_zoom = self.map_zoom_level
        min_zoom, max_zoom = 0.1, 6.0
        new_zoom = max(min_zoom, min(max_zoom, current_zoom * factor))

        # Only proceed if zoom actually changes significantly
        if abs(new_zoom - current_zoom) < 1e-9:
            return

        # --- 1. Get map coordinates under cursor BEFORE zoom ---
        map_coord_x_at_cursor = canvas.canvasx(zoom_x_canvas)
        map_coord_y_at_cursor = canvas.canvasy(zoom_y_canvas)

        # --- 2. Update zoom level ---
        scale_change = new_zoom / current_zoom
        self.map_zoom_level = new_zoom  # Update state

        # --- 3. Calculate IDEAL scroll position (absolute pixels) for zoom-to-cursor ---
        # The map point map_coord_x_at_cursor should end up at the screen
        # position zoom_x_canvas after zooming.
        new_map_coord_x = map_coord_x_at_cursor * scale_change
        new_map_coord_y = map_coord_y_at_cursor * scale_change

        # Ideal absolute coordinate for the viewport's top-left (scroll position):
        ideal_scroll_x_abs = new_map_coord_x - zoom_x_canvas
        ideal_scroll_y_abs = new_map_coord_y - zoom_y_canvas

        # --- 4. Calculate new total map dimensions and widget size ---
        zoomed_tile_size_new = (
            self.get_zoomed_tile_size()
        )  # Uses updated self.map_zoom_level
        map_total_pixel_width_new = (
            map_width * SUPERTILE_GRID_DIM * zoomed_tile_size_new
        )
        map_total_pixel_height_new = (
            map_height * SUPERTILE_GRID_DIM * zoomed_tile_size_new
        )

        # Ensure dimensions are at least 1 for calculations
        safe_map_width = max(1.0, map_total_pixel_width_new)
        safe_map_height = max(1.0, map_total_pixel_height_new)

        canvas_widget_width = canvas.winfo_width()
        canvas_widget_height = canvas.winfo_height()

        # --- 5. Calculate the MAXIMUM possible scroll position (absolute pixels) ---
        # This is how far the top-left corner can move from (0,0) before the
        # map's right/bottom edge hits the canvas's right/bottom edge.
        # If map is smaller than canvas, max scroll is 0.
        max_scroll_x_abs = max(0.0, map_total_pixel_width_new - canvas_widget_width)
        max_scroll_y_abs = max(0.0, map_total_pixel_height_new - canvas_widget_height)

        # --- 6. Clamp the IDEAL scroll position to the valid range [0, max_scroll_abs] ---
        final_scroll_x_abs = max(0.0, min(ideal_scroll_x_abs, max_scroll_x_abs))
        final_scroll_y_abs = max(0.0, min(ideal_scroll_y_abs, max_scroll_y_abs))

        # --- 7. Convert the FINAL absolute clamped scroll position to fractions ---
        # This handles the case where the map is smaller than the canvas automatically,
        # because max_scroll_x_abs/max_scroll_y_abs would be 0, clamping final_scroll_*_abs to 0.
        # The fraction is relative to the total map size.
        final_x_fraction = final_scroll_x_abs / safe_map_width
        final_y_fraction = final_scroll_y_abs / safe_map_height

        # --- 8. Apply the FINAL definite scroll position using moveto ---
        # Ensure fractions are within [0, 1] just in case of float issues, although clamping should handle it.
        canvas.xview_moveto(max(0.0, min(1.0, final_x_fraction)))
        canvas.yview_moveto(max(0.0, min(1.0, final_y_fraction)))

        # --- 9. Final Redraw ---
        # Redraw the map. This uses the final scroll position set by moveto
        # and updates the scrollregion based on the new total map dimensions.
        self.draw_map_canvas()

        # Update the minimap viewport
        self.draw_minimap()

    def handle_map_zoom_scroll(self, event):
        """Handles Ctrl+MouseWheel zooming, centered on cursor."""
        factor = 0.0
        # Determine zoom direction and set multiplicative factor
        if event.num == 4 or event.delta > 0:  # Zoom In
            factor = 1.1  # Smaller steps often feel better for scroll wheel
        elif event.num == 5 or event.delta < 0:  # Zoom Out
            factor = 1 / 1.1
        else:
            return  # Ignore other wheel events

        # Get mouse position relative to canvas content (scrolled coords)
        canvas = self.map_canvas
        zoom_x_canvas = canvas.canvasx(event.x)
        zoom_y_canvas = canvas.canvasy(event.y)

        # Perform zoom centered on the cursor
        self.zoom_map_at_point(factor, zoom_x_canvas, zoom_y_canvas)

    # --- Scrolling Methods ---

    def scroll_viewers_to_tile(self, tile_index):
        """Scrolls the tileset viewers to make the specified tile index visible."""
        # Basic input validation
        if tile_index < 0:
            return

        # Define layout parameters
        padding = 1
        tile_size = VIEWER_TILE_SIZE
        items_per_row = NUM_TILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(tile_index, items_per_row)
        target_y = row * (tile_size + padding)

        # --- Scroll main viewer ---
        canvas_main = self.tileset_canvas
        try:
            # Get scroll region info (might be tuple or string)
            scroll_info_tuple = canvas_main.cget("scrollregion")
            # Convert to string and split for consistent parsing
            scroll_info = str(scroll_info_tuple).split()

            # Check if format is valid ("0 0 width height")
            if len(scroll_info) == 4:
                # Extract total height
                total_height = float(scroll_info[3])

                # Avoid division by zero
                if total_height > 0:
                    # Calculate scroll fraction
                    fraction = target_y / total_height
                    # Clamp fraction to valid range [0.0, 1.0]
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    # Perform the scroll
                    canvas_main.yview_moveto(clamped_fraction)
            # else: (Optional: handle invalid scrollregion format if needed)
            #     print(f"Warning: Invalid scrollregion format for main tileset viewer: {scroll_info}")

        except Exception as e:
            # Catch any error during scrolling
            print(f"Error scrolling main tileset viewer: {e}")

        # --- Scroll Supertile tab's viewer ---
        canvas_st = self.st_tileset_canvas
        try:
            scroll_info_st_tuple = canvas_st.cget("scrollregion")
            scroll_info_st = str(scroll_info_st_tuple).split()

            if len(scroll_info_st) == 4:
                total_height_st = float(scroll_info_st[3])

                if total_height_st > 0:
                    fraction_st = target_y / total_height_st
                    clamped_fraction_st = min(1.0, max(0.0, fraction_st))
                    canvas_st.yview_moveto(clamped_fraction_st)
            # else:
            #     print(f"Warning: Invalid scrollregion format for ST tileset viewer: {scroll_info_st}")

        except Exception as e:
            print(f"Error scrolling ST tileset viewer: {e}")

    def scroll_selectors_to_supertile(self, supertile_index):
        """Scrolls the supertile selectors to make the specified index visible."""
        # Basic input validation
        if supertile_index < 0:
            return

        # Define layout parameters
        padding = 1
        item_size = SUPERTILE_SELECTOR_PREVIEW_SIZE
        items_per_row = NUM_SUPERTILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(supertile_index, items_per_row)
        target_y = row * (item_size + padding)

        # --- Scroll Supertile tab's selector ---
        canvas_st = self.supertile_selector_canvas
        try:
            scroll_info_tuple = canvas_st.cget("scrollregion")
            scroll_info = str(scroll_info_tuple).split()

            if len(scroll_info) == 4:
                total_height = float(scroll_info[3])

                if total_height > 0:
                    fraction = target_y / total_height
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    canvas_st.yview_moveto(clamped_fraction)
            # else:
            #     print(f"Warning: Invalid scrollregion format for ST selector: {scroll_info}")

        except Exception as e:
            print(f"Error scrolling ST selector: {e}")

        # --- Scroll Map tab's selector ---
        canvas_map = self.map_supertile_selector_canvas
        try:
            scroll_info_map_tuple = canvas_map.cget("scrollregion")
            scroll_info_map = str(scroll_info_map_tuple).split()

            if len(scroll_info_map) == 4:
                total_height_map = float(scroll_info_map[3])

                if total_height_map > 0:
                    fraction_map = target_y / total_height_map
                    clamped_fraction_map = min(1.0, max(0.0, fraction_map))
                    canvas_map.yview_moveto(clamped_fraction_map)
            # else:
            #     print(f"Warning: Invalid scrollregion format for Map selector: {scroll_info_map}")

        except Exception as e:
            print(f"Error scrolling Map selector: {e}")

    # --- vvv NEW Grid/Window Handlers vvv ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide window view
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
            valid = True
            if not (min_w <= new_w <= max_w):
                messagebox.showerror(
                    "Invalid Width", f"Window width must be {min_w}-{max_w}."
                )
                valid = False
            if not (min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Height", f"Window height must be {min_h}-{max_h}."
                )
                valid = False

            if not valid:
                # Reset entries to current state if invalid
                self._update_window_size_vars_from_state()  # Use internal helper
                return

            # If size changed (or even if not, just redraw for simplicity)
            self._clamp_window_view_position()  # Ensure position is valid for new size
            self.draw_map_canvas()
            self.draw_minimap()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:  # Handles non-integer input in IntVars
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
            self._update_window_size_vars_from_state()  # Reset on error
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")
            self._update_window_size_vars_from_state()

    def _update_window_size_vars_from_state(self):
        """Internal helper to set IntVars from the state variables."""
        # Needed because the IntVars are bound to entries, direct setting is best
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Trigger update if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())

    def _clamp_window_view_position(self):
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        # Max top-left position for the window view
        max_tile_x_clamp = total_map_tiles_w - current_w
        max_tile_y_clamp = total_map_tiles_h - current_h

        # Ensure max is not negative
        max_tile_x_clamp = max(0, max_tile_x_clamp)
        max_tile_y_clamp = max(0, max_tile_y_clamp)
        
        self.window_view_tile_x = max(0, min(self.window_view_tile_x, max_tile_x_clamp))
        self.window_view_tile_y = max(0, min(self.window_view_tile_y, max_tile_y_clamp))

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        """Moves the window view by dx, dy TILE steps."""
        if not self.show_window_view.get():
            return  # Only move if visible

        # Calculate new target position
        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        # Clamp within map bounds (recalculate max based on current size)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update if position changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "c":
            self.cycle_grid_color()
        elif self.show_window_view.get():  # Only move window if visible
            if key == "w":
                self.move_window_view_keyboard(0, -1)  # Move up
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)  # Move left
            elif key == "s":
                self.move_window_view_keyboard(0, 1)  # Move down
            elif key == "d":
                self.move_window_view_keyboard(1, 0)  # Move right

    # --- Window View Drag/Resize Handlers ---
    def _get_handle_at(self, canvas_x, canvas_y):
        """Checks if the click is on a resize handle, returns handle tag ('nw', 'n', etc.) or None."""
        if not self.show_window_view.get():
            return None
        # Find items tagged 'window_view_handle' near the click
        search_radius = WIN_VIEW_HANDLE_SIZE  # Search slightly larger than handle
        items = self.map_canvas.find_overlapping(
            canvas_x - search_radius,
            canvas_y - search_radius,
            canvas_x + search_radius,
            canvas_y + search_radius,
        )
        for item_id in items:
            tags = self.map_canvas.gettags(item_id)
            if "window_view_handle" in tags:
                for t in tags:
                    if t.startswith("handle_"):
                        return t.split("_")[1]  # Return 'nw', 'n', etc.
        return None  # No handle found

    def _is_inside_window_view(self, canvas_x, canvas_y):
        """Checks if the click is inside the window view rectangle bounds."""
        if not self.show_window_view.get():
            return False
        zoomed_tile_size = self.get_zoomed_tile_size()
        win_px = self.window_view_tile_x * zoomed_tile_size
        win_py = self.window_view_tile_y * zoomed_tile_size
        win_pw = self.window_view_tile_w.get() * zoomed_tile_size
        win_ph = self.window_view_tile_h.get() * zoomed_tile_size
        return (
            win_px <= canvas_x < win_px + win_pw
            and win_py <= canvas_y < win_py + win_ph
        )

    def handle_map_click_or_drag_start(self, event):
        """Handles initial NON-CTRL click: determines action (paint/window drag/resize).
        Sets up state AND performs the initial paint action if applicable.
        Also clears map selection if starting a paint/window action.
        """
        global last_painted_map_cell

        # --- Check for active modifiers that override this handler ---
        if self.is_shift_pressed:
            # print("Shift pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if ctrl_pressed_at_click:
            # print("Ctrl pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        if self.current_mouse_action is not None:
            # print(f"Warning: Button-1 pressed while action '{self.current_mouse_action}' active.")
            return "break"
        # --- End Modifier Check ---

        # --- Clear previous selection when starting a new action ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        canvas = self.map_canvas
        canvas.focus_set()
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        action_determined = None
        handle = self._get_handle_at(canvas_x, canvas_y)

        # Determine action based on click location
        if handle and self.show_window_view.get():
            action_determined = "window_resizing"
            self.current_mouse_action = action_determined
            self.window_view_resize_handle = handle
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self.drag_start_win_tw = self.window_view_tile_w.get()
            self.drag_start_win_th = self.window_view_tile_h.get()

        elif (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            action_determined = "window_dragging"
            self.current_mouse_action = action_determined
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y

        else:  # Painting case
            action_determined = "painting"
            self.current_mouse_action = action_determined
            last_painted_map_cell = None  # Reset for this paint sequence
            self._paint_map_cell(canvas_x, canvas_y)  # Perform first paint

        self._update_map_cursor()  # Update cursor based on the determined action

        return "break"

    def handle_map_drag(self, event):
        """Handles motion for non-panning actions (paint, window drag/resize)."""

        # Ignore if panning or no suitable action is set from Button-1 press
        # This prevents interference if Ctrl was pressed *after* Button-1 was down but before motion.
        if self.current_mouse_action not in [
            "painting",
            "window_dragging",
            "window_resizing",
        ]:
            return  # Don't handle if not in a valid non-pan drag state

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Perform action based on the current state
        if self.current_mouse_action == "painting":
            self._paint_map_cell(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_dragging":
            self._do_window_move_drag(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_resizing":
            self._do_window_resize_drag(canvas_x, canvas_y)

        return "break"  # Prevent other B1-Motion bindings

    def handle_map_drag_release(self, event):
        """Handles mouse button release: ends the current action (paint, pan, window ops)."""
        global last_painted_map_cell  # Ensure global is accessible
        action_at_release = self.current_mouse_action

        last_painted_map_cell = None  # Stop continuous paint if it was happening

        # Reset the current action state FIRST
        self.current_mouse_action = None

        # Perform any finalization based on the action that just finished
        if action_at_release == "panning":
            pass  # No explicit action needed, scan_dragto stopped with motion

        elif action_at_release == "window_dragging":
            # Position is already snapped during drag, just update minimap (done below)
            pass

        elif action_at_release == "window_resizing":
            # Clamp final position and update entries/IntVar state just in case
            self._clamp_window_view_position()
            self._update_window_size_vars_from_state()  # Sync IntVars post-resize
            self.window_view_resize_handle = None
            # Redraw needed to finalize visual state and ensure entries match
            self.draw_map_canvas()  # Redraw map canvas to remove potential temp visuals

        elif action_at_release == "painting":
            pass  # No specific finalization needed

        self._update_map_cursor()
        self.draw_minimap()

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window movement during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        delta_x_pixels = current_canvas_x - self.drag_start_x
        delta_y_pixels = current_canvas_y - self.drag_start_y

        # Calculate movement in TILE units, snapping to grid
        # Use floor for consistent snapping direction
        delta_tile_x = math.floor(delta_x_pixels / zoomed_tile_size)
        delta_tile_y = math.floor(delta_y_pixels / zoomed_tile_size)

        # Calculate potential new top-left TILE coordinate
        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y

        # Clamp position within map bounds (using current W/H)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update state and redraw ONLY if position actually changes
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window resize during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        # Starting state in TILE units
        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th
        start_br_tx = start_tx + start_tw  # Bottom-right tile X (exclusive)
        start_br_ty = start_ty + start_th  # Bottom-right tile Y (exclusive)

        # Current mouse position snapped to TILE grid
        current_tile_x = math.floor(current_canvas_x / zoomed_tile_size)
        current_tile_y = math.floor(current_canvas_y / zoomed_tile_size)

        # Calculate new potential corners based on handle
        new_tx = start_tx
        new_ty = start_ty
        new_br_tx = start_br_tx
        new_br_ty = start_br_ty
        handle = self.window_view_resize_handle

        # Adjust based on handle dragged
        if "n" in handle:
            new_ty = current_tile_y
        if "s" in handle:
            new_br_ty = current_tile_y + 1  # +1 because BR is exclusive
        if "w" in handle:
            new_tx = current_tile_x
        if "e" in handle:
            new_br_tx = current_tile_x + 1

        # Ensure top-left is never beyond bottom-right
        new_tx = min(new_tx, new_br_tx - 1)  # Ensure width >= 1
        new_ty = min(new_ty, new_br_ty - 1)  # Ensure height >= 1
        new_br_tx = max(new_br_tx, new_tx + 1)
        new_br_ty = max(new_br_ty, new_ty + 1)

        # Calculate new width and height in tiles
        new_tw = new_br_tx - new_tx
        new_th = new_br_ty - new_ty

        # Clamp dimensions to allowed limits
        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        # Adjust position if clamping changed dimensions, preserving the fixed corner/edge
        if "n" in handle and clamped_th != new_th:
            new_ty = new_br_ty - clamped_th
        if "w" in handle and clamped_tw != new_tw:
            new_tx = new_br_tx - clamped_tw
        if "s" in handle:
            new_br_ty = (
                new_ty + clamped_th
            )  # Recalculate needed? No, height is clamped.
        if "e" in handle:
            new_br_tx = new_tx + clamped_tw

        # Clamp position to stay within map boundaries
        max_map_tile_x = map_width * SUPERTILE_GRID_DIM
        max_map_tile_y = map_height * SUPERTILE_GRID_DIM
        clamped_tx = max(0, min(new_tx, max_map_tile_x - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y - clamped_th))

        # Final check if clamping position changed dimensions again (shouldn't drastically)
        final_tw = min(clamped_tw, max_map_tile_x - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y - clamped_ty)

        # Update state only if position or size changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw
            or self.window_view_tile_h.get() != final_th
        ):
            #
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)  # Update IntVars
            self.window_view_tile_h.set(final_th)
            # self._update_window_size_vars_from_state() # Update entries
            self.draw_map_canvas()  # Redraw to show resize
            self.draw_minimap()

    # --- Minimap Methods ---

    def toggle_minimap(self):
        """Opens/raises the resizable minimap window."""
        if self.minimap_window is None or not tk.Toplevel.winfo_exists(
            self.minimap_window
        ):
            self.minimap_window = tk.Toplevel(self.root)
            self.minimap_window.title("Minimap")
            # Set initial size, but allow resizing
            self.minimap_window.geometry(
                f"{MINIMAP_INITIAL_WIDTH}x{MINIMAP_INITIAL_HEIGHT}"
            )
            # self.minimap_window.resizable(False, False) # REMOVE or set True

            self.minimap_canvas = tk.Canvas(
                self.minimap_window, bg="dark slate gray", highlightthickness=0
            )
            # Make canvas fill the resizable window
            self.minimap_canvas.pack(fill=tk.BOTH, expand=True)  # MODIFIED pack options
            self.minimap_window.protocol("WM_DELETE_WINDOW", self._on_minimap_close)
            self.minimap_window.bind("<Configure>", self._on_minimap_configure)

            # Initial draw (will use initial geometry)
            # Need to ensure canvas has dimensions before first draw
            self.minimap_window.update_idletasks()  # Process geometry requests
            self.draw_minimap()
        else:
            self.minimap_window.lift()
            self.minimap_window.focus_set()

    def _on_minimap_close(self):
        """Handles the closing of the minimap window."""
        if self.minimap_window:
            self.minimap_window.destroy()  # Destroy the window
        self.minimap_window = None  # Reset state variable
        self.minimap_canvas = None

    def draw_minimap(self):
        if self.minimap_window is None or self.minimap_canvas is None:
            return
        if not tk.Toplevel.winfo_exists(self.minimap_window):
            self._on_minimap_close()
            return

        canvas_mm = self.minimap_canvas # Renamed
        canvas_mm.delete("all")

        current_minimap_w_px = canvas_mm.winfo_width()
        current_minimap_h_px = canvas_mm.winfo_height()
        if current_minimap_w_px <= 1 or current_minimap_h_px <= 1:
            return

        if (
            self.minimap_background_cache is None
            or self.minimap_bg_rendered_width != current_minimap_w_px
            or self.minimap_bg_rendered_height != current_minimap_h_px
        ):
            self.minimap_background_cache = self._create_minimap_background_image(
                current_minimap_w_px, current_minimap_h_px
            )

        if self.minimap_background_cache:
            canvas_mm.create_image(
                0, 0, image=self.minimap_background_cache, anchor=tk.NW, tags="minimap_bg_image"
            )
        else:
            canvas_mm.create_rectangle(
                0, 0, current_minimap_w_px, current_minimap_h_px, fill="gray10"
            )

        # Total map dimensions in base MSX pixels
        map_total_msx_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_total_msx_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT
        
        if map_total_msx_pixel_w <= 0 or map_total_msx_pixel_h <= 0:
            return

        scale_x_overlay = current_minimap_w_px / map_total_msx_pixel_w
        scale_y_overlay = current_minimap_h_px / map_total_msx_pixel_h
        scale_overlay = min(scale_x_overlay, scale_y_overlay)

        scaled_map_content_w_overlay = map_total_msx_pixel_w * scale_overlay
        scaled_map_content_h_overlay = map_total_msx_pixel_h * scale_overlay
        offset_x_overlay_render = (current_minimap_w_px - scaled_map_content_w_overlay) / 2
        offset_y_overlay_render = (current_minimap_h_px - scaled_map_content_h_overlay) / 2

        try:
            main_map_canvas = self.map_canvas # Renamed
            scroll_x_fractions = main_map_canvas.xview()
            scroll_y_fractions = main_map_canvas.yview()

            # Total BASE map dimensions in MSX pixels (same as map_total_msx_pixel_w/h above)
            # This is what the scroll fractions are relative to.
            # map_total_base_msx_w = map_width * self.supertile_grid_width * TILE_WIDTH
            # map_total_base_msx_h = map_height * self.supertile_grid_height * TILE_HEIGHT
            # No need to recalculate, use map_total_msx_pixel_w/h

            if map_total_msx_pixel_w > 0 and map_total_msx_pixel_h > 0:
                map_viewport_msx_px_x1 = scroll_x_fractions[0] * map_total_msx_pixel_w
                map_viewport_msx_px_y1 = scroll_y_fractions[0] * map_total_msx_pixel_h
                map_viewport_msx_px_x2 = scroll_x_fractions[1] * map_total_msx_pixel_w
                map_viewport_msx_px_y2 = scroll_y_fractions[1] * map_total_msx_pixel_h

                vp_x1_draw = offset_x_overlay_render + map_viewport_msx_px_x1 * scale_overlay
                vp_y1_draw = offset_y_overlay_render + map_viewport_msx_px_y1 * scale_overlay
                vp_x2_draw = offset_x_overlay_render + map_viewport_msx_px_x2 * scale_overlay
                vp_y2_draw = offset_y_overlay_render + map_viewport_msx_px_y2 * scale_overlay

                canvas_mm.create_rectangle(
                    vp_x1_draw, vp_y1_draw, vp_x2_draw, vp_y2_draw,
                    outline=self.MINIMAP_VIEWPORT_COLOR, width=2, tags="minimap_viewport"
                )
        except Exception as e:
            # print(f"Error drawing minimap viewport: {e}")
            pass

        if self.show_window_view.get():
            try:
                win_tx_mm = self.window_view_tile_x # In base tiles
                win_ty_mm = self.window_view_tile_y
                win_tw_mm = self.window_view_tile_w.get()
                win_th_mm = self.window_view_tile_h.get()

                # Window view dimensions in MSX pixels
                win_map_msx_px1 = win_tx_mm * TILE_WIDTH
                win_map_msx_py1 = win_ty_mm * TILE_HEIGHT
                win_map_msx_px2 = win_map_msx_px1 + (win_tw_mm * TILE_WIDTH)
                win_map_msx_py2 = win_map_msx_py1 + (win_th_mm * TILE_HEIGHT)

                wv_x1_draw = offset_x_overlay_render + win_map_msx_px1 * scale_overlay
                wv_y1_draw = offset_y_overlay_render + win_map_msx_py1 * scale_overlay
                wv_x2_draw = offset_x_overlay_render + win_map_msx_px2 * scale_overlay
                wv_y2_draw = offset_y_overlay_render + win_map_msx_py2 * scale_overlay

                canvas_mm.create_rectangle(
                    wv_x1_draw, wv_y1_draw, wv_x2_draw, wv_y2_draw,
                    outline=self.MINIMAP_WIN_VIEW_COLOR, width=2, dash=(4, 4), tags="minimap_window_view"
                )
            except Exception as e:
                # print(f"Error drawing minimap window view: {e}")
                pass

    def _on_minimap_configure(self, event):
        """Callback when the minimap window is resized/moved."""
        # We only care about size changes for redrawing
        # Basic debouncing: wait a short time after the last configure event
        # before redrawing to avoid excessive calls during drag-resizing.
        debounce_ms = 150  # Adjust as needed (milliseconds)

        # Cancel any pending redraw timer
        if self.minimap_resize_timer is not None:
            self.root.after_cancel(self.minimap_resize_timer)

        # Schedule a new redraw after the debounce period
        self.minimap_resize_timer = self.root.after(
            debounce_ms, self._redraw_minimap_after_resize
        )

    def _redraw_minimap_after_resize(self):
        self.minimap_resize_timer = None 

        if not self.minimap_window or not tk.Toplevel.winfo_exists(self.minimap_window):
            return

        if self._minimap_resizing_internally:
            return

        try:
            current_width_mm_cfg = self.minimap_window.winfo_width()
            current_height_mm_cfg = self.minimap_window.winfo_height()

            # Map aspect ratio based on total MSX pixels
            map_total_msx_pixel_w_cfg = map_width * self.supertile_grid_width * TILE_WIDTH
            map_total_msx_pixel_h_cfg = map_height * self.supertile_grid_height * TILE_HEIGHT

            if map_total_msx_pixel_h_cfg <= 0 or map_total_msx_pixel_w_cfg <= 0 or \
               current_width_mm_cfg <= 1 or current_height_mm_cfg <= 1:
                self.invalidate_minimap_background_cache()
                self.draw_minimap()
                return

            map_aspect_ratio_cfg = map_total_msx_pixel_w_cfg / map_total_msx_pixel_h_cfg
            ideal_height_cfg = int(round(current_width_mm_cfg / map_aspect_ratio_cfg))

            if abs(current_height_mm_cfg - ideal_height_cfg) > 1: # Allow 1px tolerance
                self._minimap_resizing_internally = True
                new_geometry_cfg = f"{current_width_mm_cfg}x{ideal_height_cfg}"
                # print(f"Minimap Configure: Forcing aspect ratio. New geometry: {new_geometry_cfg}")
                self.minimap_window.geometry(new_geometry_cfg)
                self.root.after(50, setattr, self, "_minimap_resizing_internally", False)
                # Redraw will be triggered by the geometry change causing another <Configure>
                return 
        except Exception as e:
            # print(f"Error during minimap aspect ratio enforcement: {e}")
            self._minimap_resizing_internally = False # Ensure flag is reset

        # print(f"Minimap Configure: Aspect ratio OK or no change needed. Redrawing.")
        self.invalidate_minimap_background_cache()
        self.draw_minimap()

    def _trigger_minimap_reconfigure(self):
        """Forces the minimap to re-evaluate its size and aspect ratio if it exists."""
        if self.minimap_window and tk.Toplevel.winfo_exists(self.minimap_window):
            # A simple way to trigger <Configure> is to slightly change the size
            # We can just call the resize logic directly though.
            print("Map dimensions changed, triggering minimap aspect check/redraw.")
            # Reset the resize timer to avoid duplicate calls if configure is also pending
            if self.minimap_resize_timer is not None:
                self.root.after_cancel(self.minimap_resize_timer)
                self.minimap_resize_timer = None
            # Directly call the logic that handles resizing and drawing
            self._redraw_minimap_after_resize()

    def invalidate_minimap_background_cache(self):
        """Clears the cached minimap background image."""
        self.minimap_background_cache = None
        # Reset rendered size trackers too
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0

    def _create_minimap_background_image(self, target_width_mm, target_height_mm): # Renamed params
        if target_width_mm <= 0 or target_height_mm <= 0:
            return None

        minimap_img_bg = tk.PhotoImage(width=target_width_mm, height=target_height_mm) # Renamed
        
        # Base map pixel dimensions (MSX pixels, assuming TILE_WIDTH/HEIGHT are base tile MSX pixels)
        map_base_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_base_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT

        if map_base_pixel_w <= 0 or map_base_pixel_h <= 0:
            # print("Warning: Invalid base map pixel dimensions for minimap background.")
            minimap_img_bg.put("black", to=(0, 0, target_width_mm, target_height_mm))
            # Update cache trackers even for fallback
            self.minimap_bg_rendered_width = target_width_mm
            self.minimap_bg_rendered_height = target_height_mm
            self.minimap_background_cache = minimap_img_bg
            return minimap_img_bg

        scale_x_mm = target_width_mm / map_base_pixel_w
        scale_y_mm = target_height_mm / map_base_pixel_h
        scale_mm = min(scale_x_mm, scale_y_mm)
        
        scaled_map_content_w = map_base_pixel_w * scale_mm
        scaled_map_content_h = map_base_pixel_h * scale_mm
        offset_x_mm_render = (target_width_mm - scaled_map_content_w) / 2
        offset_y_mm_render = (target_height_mm - scaled_map_content_h) / 2
        
        bg_fill_color_mm = "#000000" # Black for letter/pillarbox

        for y_pix_mm in range(target_height_mm):
            row_hex_colors_mm = []
            for x_pix_mm in range(target_width_mm):
                pixel_color_hex_mm = bg_fill_color_mm

                if (offset_x_mm_render <= x_pix_mm < offset_x_mm_render + scaled_map_content_w and
                    offset_y_mm_render <= y_pix_mm < offset_y_mm_render + scaled_map_content_h):

                    map_src_base_x = (x_pix_mm - offset_x_mm_render) / max(1e-9, scale_mm)
                    map_src_base_y = (y_pix_mm - offset_y_mm_render) / max(1e-9, scale_mm)

                    map_src_base_x = max(0, min(map_base_pixel_w - 1, map_src_base_x))
                    map_src_base_y = max(0, min(map_base_pixel_h - 1, map_src_base_y))

                    map_pixel_col_src = int(map_src_base_x)
                    map_pixel_row_src = int(map_src_base_y)

                    # Pixels per supertile width/height
                    pixels_per_st_w = self.supertile_grid_width * TILE_WIDTH
                    pixels_per_st_h = self.supertile_grid_height * TILE_HEIGHT
                    if pixels_per_st_w <=0 : pixels_per_st_w = 1 # Avoid div by zero
                    if pixels_per_st_h <=0 : pixels_per_st_h = 1


                    st_col_mm = map_pixel_col_src // pixels_per_st_w
                    st_row_mm = map_pixel_row_src // pixels_per_st_h

                    tile_col_in_st_mm = (map_pixel_col_src % pixels_per_st_w) // TILE_WIDTH
                    tile_row_in_st_mm = (map_pixel_row_src % pixels_per_st_h) // TILE_HEIGHT
                    
                    pixel_col_in_tile_mm = map_pixel_col_src % TILE_WIDTH
                    pixel_row_in_tile_mm = map_pixel_row_src % TILE_HEIGHT
                    
                    try:
                        # Ensure st_row_mm, st_col_mm are within map_data bounds
                        if 0 <= st_row_mm < map_height and 0 <= st_col_mm < map_width:
                            supertile_idx_mm = map_data[st_row_mm][st_col_mm]
                            if 0 <= supertile_idx_mm < num_supertiles:
                                # Ensure definition structure is valid for current ST dimensions
                                st_def_mm = supertiles_data[supertile_idx_mm]
                                if st_def_mm and len(st_def_mm) == self.supertile_grid_height and \
                                   (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(st_def_mm[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) and \
                                   0 <= tile_row_in_st_mm < self.supertile_grid_height and \
                                   0 <= tile_col_in_st_mm < self.supertile_grid_width:

                                    tile_idx_mm = st_def_mm[tile_row_in_st_mm][tile_col_in_st_mm]
                                    if 0 <= tile_idx_mm < num_tiles_in_set:
                                        # Check bounds for tile pattern/color access
                                        if 0 <= pixel_row_in_tile_mm < TILE_HEIGHT and \
                                           0 <= pixel_col_in_tile_mm < TILE_WIDTH:
                                            pattern_val_mm = tileset_patterns[tile_idx_mm][pixel_row_in_tile_mm][pixel_col_in_tile_mm]
                                            fg_idx_mm, bg_idx_mm = tileset_colors[tile_idx_mm][pixel_row_in_tile_mm]
                                            
                                            # Validate palette indices
                                            if not (0 <= fg_idx_mm < len(self.active_msx_palette) and \
                                                    0 <= bg_idx_mm < len(self.active_msx_palette)):
                                                # print(f"Warning: Invalid palette indices ({fg_idx_mm}, {bg_idx_mm}) in minimap render.")
                                                fg_idx_mm = WHITE_IDX; bg_idx_mm = BLACK_IDX # Fallback

                                            fg_color_mm = self.active_msx_palette[fg_idx_mm]
                                            bg_color_mm = self.active_msx_palette[bg_idx_mm]
                                            pixel_color_hex_mm = fg_color_mm if pattern_val_mm == 1 else bg_color_mm
                                        else: pixel_color_hex_mm = INVALID_TILE_COLOR # pixel in tile out of bounds
                                    else: pixel_color_hex_mm = INVALID_TILE_COLOR # tile_idx_mm out of bounds
                                else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # ST def structure issue or tile in ST out of bounds
                            else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # supertile_idx_mm out of bounds
                        else: pixel_color_hex_mm = "#808080" # Grey for outside map supertile grid
                    except IndexError:
                        pixel_color_hex_mm = "#FF0000" # Bright Red for major error
                
                row_hex_colors_mm.append(pixel_color_hex_mm)

            try:
                minimap_img_bg.put("{" + " ".join(row_hex_colors_mm) + "}", to=(0, y_pix_mm))
            except tk.TclError:
                # print(f"Warning [Minimap BG]: TclError put row {y_pix_mm}: {e}")
                if row_hex_colors_mm:
                    minimap_img_bg.put(row_hex_colors_mm[0], to=(0, y_pix_mm, target_width_mm, y_pix_mm + 1))

        # print("Minimap background generated.")
        self.minimap_bg_rendered_width = target_width_mm
        self.minimap_bg_rendered_height = target_height_mm
        self.minimap_background_cache = minimap_img_bg
        return minimap_img_bg

    def _update_window_title(self):
        """Updates the main window title based on the current project path."""
        base_title = "MSX Tile Forge"
        modifier = "*" if self.project_modified else ""

        if self.current_project_base_path:
            # Extract just the filename part
            project_name = os.path.basename(self.current_project_base_path)
            self.root.title(
                f"{base_title} - {project_name}{modifier}"
            )  # Prepend modifier
        else:
            self.root.title(f"{base_title} - Untitled{modifier}")  # Prepend modifier

    def _update_map_cursor(self):
        """Sets the map canvas cursor based on current action and modifier keys."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        new_cursor = ""  # Default arrow cursor

        # Determine cursor based on the active operation FIRST
        if self.current_mouse_action == "panning":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_dragging":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_resizing":
            new_cursor = "sizing"  # Generic resize
        elif self.map_selection_active:  # NEW: Selection in progress
            new_cursor = "crosshair"
        # --- Modifier key hints (if NO mouse action is active) ---
        elif self.is_ctrl_pressed:
            try:  # Check location for hinting
                canvas_x = self.map_canvas.canvasx(
                    self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                )
                canvas_y = self.map_canvas.canvasy(
                    self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                )
                handle = (
                    self._get_handle_at(canvas_x, canvas_y)
                    if self.show_window_view.get()
                    else None
                )
                if handle:
                    new_cursor = "sizing"  # Hint resize
                elif (
                    self._is_inside_window_view(canvas_x, canvas_y)
                    and self.show_window_view.get()
                ):
                    new_cursor = "fleur"  # Hint window drag
                else:
                    new_cursor = "hand2"  # Hint panning
            except tk.TclError:
                new_cursor = "hand2"  # Default hint for Ctrl pressed
        elif self.is_shift_pressed:  # NEW: Shift held, no action -> hint selection
            new_cursor = "crosshair"
        # --- Default action (if no action and no relevant modifier) ---
        else:
            new_cursor = "pencil"  # Default paint cursor

        # Only change the cursor if it's different
        try:
            current_cursor = self.map_canvas.cget("cursor")
            if current_cursor != new_cursor:
                self.map_canvas.config(cursor=new_cursor)
        except tk.TclError:
            pass

    def handle_ctrl_press(self, event):
        """Handles Control key press."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state and cursor if Ctrl wasn't already considered pressed
            if not self.is_ctrl_pressed:
                self.is_ctrl_pressed = True
                # Update cursor only if no mouse action is currently happening
                # If a mouse button is down, let the existing action determine cursor
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_ctrl_release(self, event):
        """Handles Control key release. Stops panning if active."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state if Ctrl was actually considered pressed
            if self.is_ctrl_pressed:
                self.is_ctrl_pressed = False
                # If panning was the current action, stop it.
                # Window dragging/resizing continues until mouse release even if Ctrl comes up.
                if self.current_mouse_action == "panning":
                    self.current_mouse_action = None
                self._update_map_cursor()

    def handle_pan_start(self, event):
        """Handles the start of panning (Ctrl + Left Click) OR window dragging with Ctrl."""
        # --- Check for Shift modifier ---
        if self.is_shift_pressed:
            # print("Shift pressed, ignoring Ctrl-Button-1 for pan/window drag.")
            return "break"
        # --- End Shift Check ---

        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if not ctrl_pressed_at_click or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # --- Clear previous selection when starting pan/window drag ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        if (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            self.current_mouse_action = "window_dragging"
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self._update_map_cursor()
        else:
            # Initiate PANNING
            self.current_mouse_action = "panning"
            canvas.scan_mark(event.x, event.y)
            self._update_map_cursor()

        return "break"

    def handle_pan_motion(self, event):
        """Handles mouse motion during panning OR window dragging with Ctrl."""
        if self.current_mouse_action not in ["panning", "window_dragging"]:
            return

        canvas = self.map_canvas

        if self.current_mouse_action == "panning":
            canvas.scan_dragto(event.x, event.y, gain=1)
            # After scan_dragto, the view has changed, so redraw the map content
            self.draw_map_canvas() # <<< ADDED THIS LINE
            self.draw_minimap()    # Minimap was already being updated

        elif self.current_mouse_action == "window_dragging":
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)
            self._do_window_move_drag(canvas_x, canvas_y) # This calls draw_map_canvas internally if needed

        return "break"

    def handle_canvas_enter(self, event):
        """Handles mouse entering the canvas area."""
        # Set cursor based on current state
        self._update_map_cursor()

        # --- >> ADDED: Draw paste preview on enter if applicable << ---
        if event.widget == self.map_canvas:
            is_map_tab_active = False
            if self.notebook and self.notebook.winfo_exists():
                try:
                     selected_tab_index = self.notebook.index(self.notebook.select())
                     if selected_tab_index == 3: # Map Editor tab index
                         is_map_tab_active = True
                except tk.TclError:
                    pass # Ignore if notebook not ready

            # Draw preview if map tab active and clipboard has data
            if is_map_tab_active and self.map_clipboard_data:
                self._draw_paste_preview_rect(event=event)

    def handle_canvas_leave(self, event):
        """Handles mouse leaving the canvas area."""
        # Reset cursor to default when leaving, unless an action is in progress
        if self.current_mouse_action is None:
            # Only reset if the specific widget leaving is the map canvas
            if event.widget == self.map_canvas:
                try:
                    if self.map_canvas.winfo_exists():
                        self.map_canvas.config(cursor="")
                except tk.TclError:
                    pass # Ignore if destroyed

        # Reset coordinate display when mouse leaves map canvas
        if event.widget == self.map_canvas and hasattr(self, "map_coords_label"):
            self.map_coords_label.config(text="ST Coords: -, -")

        # Clear paste preview when leaving map canvas
        if event.widget == self.map_canvas:
            self._clear_paste_preview_rect()

    def _update_edit_menu_state(self):
        """Updates the state (enabled/disabled) and labels of generic Edit menu items
        based on the active tab and clipboard state.
        """
        if not self.edit_menu:
            return  # Menu not ready
        if self.copy_menu_item_index == -1 or self.paste_menu_item_index == -1:
            return  # Cannot proceed if indices weren't stored correctly

        selected_tab_index = 0  # Default
        try:
            if self.notebook and self.notebook.winfo_exists():
                current_selection = self.notebook.select()
                if current_selection:
                    selected_tab_index = self.notebook.index(current_selection)
        except tk.TclError:
            selected_tab_index = 0

        can_copy = False
        can_paste = False
        copy_label = "Copy"
        paste_label = "Paste"

        if selected_tab_index == 1:  # Tile Editor Tab (index 1)
            copy_label = "Copy Tile"
            paste_label = "Paste Tile"
            can_copy = 0 <= current_tile_index < num_tiles_in_set
            can_paste = (
                tile_clipboard_pattern is not None
                and 0 <= current_tile_index < num_tiles_in_set
            )

        elif selected_tab_index == 2:  # Supertile Editor Tab (index 2)
            copy_label = "Copy Supertile"
            paste_label = "Paste Supertile"
            can_copy = 0 <= current_supertile_index < num_supertiles
            can_paste = (
                supertile_clipboard_data is not None
                and 0 <= current_supertile_index < num_supertiles
            )

        elif selected_tab_index == 3:  # Map Editor Tab (index 3)
            copy_label = "Copy Map Region"
            paste_label = "Paste Map Region"
            can_copy = (
                self.map_selection_start_st is not None
                and self.map_selection_end_st is not None
            )
            can_paste = self.map_clipboard_data is not None

        else:  # Palette (0) tab
            copy_label = "Copy"
            paste_label = "Paste"
            can_copy = False
            can_paste = False

        copy_state = tk.NORMAL if can_copy else tk.DISABLED
        paste_state = tk.NORMAL if can_paste else tk.DISABLED

        try:
            current_copy_type = self.edit_menu.type(self.copy_menu_item_index)
            current_paste_type = self.edit_menu.type(self.paste_menu_item_index)
            if current_copy_type == "command":
                self.edit_menu.entryconfig(
                    self.copy_menu_item_index, state=copy_state, label=copy_label
                )
            # else:
            # print(f"  ERROR: Item at copy index {self.copy_menu_item_index} is not a 'command' type!")

            if current_paste_type == "command":
                self.edit_menu.entryconfig(
                    self.paste_menu_item_index, state=paste_state, label=paste_label
                )
            # else:
            # print(f"  ERROR: Item at paste index {self.paste_menu_item_index} is not a 'command' type!")

        except tk.TclError as e:
            # print(f"  ERROR during entryconfig: {e}")
            pass
        except Exception as e:
            # print(f"  UNEXPECTED ERROR during menu update: {e}")
            pass

    def handle_generic_copy(self):
        """Handles the generic 'Copy' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return # Cannot determine active tab

        # Clear map clipboard and preview ONLY if copy action is NOT for map region
        if active_tab_index != 3:
            # Check if map clipboard actually needs clearing before doing work
            if self.map_clipboard_data is not None:
                self.map_clipboard_data = None
                self._clear_paste_preview_rect()
                # Update menu state since map paste is now disabled
                self._update_edit_menu_state() # Update only if clipboard was cleared

        # Perform copy based on active tab
        if active_tab_index == 1:  # Tile Editor Tab
            self.copy_current_tile()
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.copy_current_supertile()
        elif active_tab_index == 3:  # Map Editor Tab
            norm_coords = self._get_normalized_selection_st()
            if norm_coords: # If a selection exists, perform the copy
                min_c, min_r, max_c, max_r = norm_coords
                sel_w = max_c - min_c + 1
                sel_h = max_r - min_r + 1
                copied_data = []
                for r_idx in range(min_r, max_r + 1):
                    row_data = []
                    for c_idx in range(min_c, max_c + 1):
                        if 0 <= r_idx < map_height and 0 <= c_idx < map_width:
                            row_data.append(map_data[r_idx][c_idx])
                        else:
                            row_data.append(0)  # Append default if outside map
                    copied_data.append(row_data)

                # Set the map clipboard
                self.map_clipboard_data = {
                    "width": sel_w,
                    "height": sel_h,
                    "data": copied_data,
                }
                # Clear selection visual/state after successful copy
                self._clear_map_selection()
                # Explicitly clear any old paste preview visual
                self._clear_paste_preview_rect()
                # Redraw map canvas to remove selection rectangle
                self.draw_map_canvas()
                # Update menu state (enables Paste)
                self._update_edit_menu_state()
                # Attempt to draw the *new* paste preview based on current mouse pos
                try:
                    pointer_x = self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                    pointer_y = self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                    if (0 <= pointer_x < self.map_canvas.winfo_width() and
                        0 <= pointer_y < self.map_canvas.winfo_height()):
                        canvas_x = self.map_canvas.canvasx(pointer_x)
                        canvas_y = self.map_canvas.canvasy(pointer_y)
                        self._draw_paste_preview_rect(canvas_coords=(canvas_x, canvas_y))
                except Exception:
                     pass # Ignore errors getting pointer position

            # else: # If no selection exists, simply do nothing for the map clipboard
            #    print("Copy Map Region: No selection active.") # Optional info message

    def handle_generic_paste(self):
        """Handles the generic 'Paste' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return 

        # Clear marks before any paste operation, if they are active
        # This needs to be done carefully to ensure the correct redraw happens.
        marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)

        if active_tab_index == 1:  # Tile Editor Tab
            self.paste_tile() # This will call update_all_displays if marks were not cleared
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.paste_supertile() # This will call update_all_displays if marks were not cleared
        elif active_tab_index == 3:  # Map Editor Tab 
            if self.map_clipboard_data:
                canvas = self.map_canvas
                try:
                    pointer_x = canvas.winfo_pointerx()
                    pointer_y = canvas.winfo_pointery()
                    root_x = canvas.winfo_rootx()
                    root_y = canvas.winfo_rooty()
                    canvas_x = canvas.canvasx(pointer_x - root_x)
                    canvas_y = canvas.canvasy(pointer_y - root_y)
                except tk.TclError:
                    messagebox.showerror("Paste Error", "Could not get mouse position.")
                    if marks_were_cleared: self.update_all_displays(changed_level="all") # Redraw if marks cleared but paste failed
                    return

                paste_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)
                if paste_coords is None:
                    if marks_were_cleared: self.update_all_displays(changed_level="all")
                    return

                paste_st_col, paste_st_row = paste_coords
                clip_w = self.map_clipboard_data["width"]
                clip_h = self.map_clipboard_data["height"]
                clip_data = self.map_clipboard_data["data"]
                modified = False

                for r_offset in range(clip_h):
                    for c_offset in range(clip_w):
                        target_map_row = paste_st_row + r_offset
                        target_map_col = paste_st_col + c_offset

                        if (0 <= target_map_row < map_height and 0 <= target_map_col < map_width):
                            if r_offset < len(clip_data) and c_offset < len(clip_data[r_offset]):
                                st_index_to_paste = clip_data[r_offset][c_offset]
                                if map_data[target_map_row][target_map_col] != st_index_to_paste:
                                    map_data[target_map_row][target_map_col] = st_index_to_paste
                                    modified = True

                if modified:
                    self._mark_project_modified()
                    self.invalidate_minimap_background_cache()
                    # If marks were already cleared, this redraw is fine.
                    # If not, paste_tile/paste_supertile would have handled a more targeted redraw.
                    # For map paste, a full map canvas redraw is generally needed.
                    self.draw_map_canvas()  
                    self.draw_minimap()  
                # else:
                #    print("Paste: No changes made to map.")

            else:
                messagebox.showinfo("Paste", "Map clipboard is empty.")
                # If marks were cleared but no paste happened, still need to redraw
                if marks_were_cleared: self.update_all_displays(changed_level="all")

        # If marks were cleared by this paste operation and no specific redraw happened in the branches
        if marks_were_cleared and active_tab_index not in [1, 2, 3]: # e.g. if on palette tab
            self.update_all_displays(changed_level="all")

    def _setup_global_key_bindings(self):
        """Sets up global keyboard shortcuts (accelerators) for menu commands."""
        # File Menu Bindings
        self.root.bind_all("<Control-n>", lambda event: self.new_project())
        self.root.bind_all("<Control-o>", lambda event: self.open_project())
        self.root.bind_all("<Control-s>", lambda event: self.save_project())
        # Note: Use <Control-Shift-KeyPress-S> for Ctrl+Shift+S reliably
        self.root.bind_all(
            "<Control-Shift-KeyPress-S>", lambda event: self.save_project_as()
        )
        self.root.bind_all("<Control-q>", lambda event: self.root.quit())

        # Edit Menu Bindings (Call the generic handlers)
        # Check state *within* the handler to see if action is allowed for the current tab
        self.root.bind_all("<Control-c>", lambda event: self.handle_generic_copy())
        self.root.bind_all("<Control-v>", lambda event: self.handle_generic_paste())

        # View Menu Bindings
        self.root.bind_all("<Control-m>", lambda event: self.toggle_minimap())

        # Add a print statement for confirmation (optional)
        print("Global key bindings set up.")

        # IMPORTANT: Prevent default text widget bindings for Copy/Paste if needed
        # This stops Ctrl+C/V from trying to act on focused widgets like Entries
        # if you want the menu action to ALWAYS take precedence.
        # Use with caution, might interfere with expected text editing.
        # self.root.event_delete("<<Copy>>", "<Control-c>")
        # self.root.event_delete("<<Paste>>", "<Control-v>")

    def handle_map_tab_keypress(self, event):
        """Handles key presses specifically bound when the Map Tab is active."""
        key = event.keysym.lower()

        if key == "g":  # MODIFIED CHECK
            # Only cycle color if the key is 'g' (this handler is only active on map tab)
            self.cycle_grid_color()
            return "break"  # Prevent any other default actions for 'g'

    def _place_tile_in_supertile(self, r_place, c_place): # Renamed r, c
        global supertiles_data, current_supertile_index, selected_tile_for_supertile # Globals
        
        if not (0 <= current_supertile_index < num_supertiles):
            return False
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return False
        
        # Check against current project's supertile dimensions
        if not (0 <= r_place < self.supertile_grid_height and 0 <= c_place < self.supertile_grid_width):
            return False

        # Ensure definition structure is consistent before trying to access/modify
        current_definition_place = supertiles_data[current_supertile_index]
        if not current_definition_place or len(current_definition_place) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition_place[0]) != self.supertile_grid_width)):
            # print(f"Warning: Supertile {current_supertile_index} dim mismatch in _place_tile_in_supertile.")
            return False


        if current_definition_place[r_place][c_place] != selected_tile_for_supertile:
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            # Modify the global supertiles_data directly
            supertiles_data[current_supertile_index][r_place][c_place] = selected_tile_for_supertile
            
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="supertile")
            else: # Marks were cleared
                self.update_all_displays(changed_level="all") # Ensure full redraw
            self._mark_project_modified()
            return True
        else:
            return False

    def handle_supertile_def_drag(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile
        mini_tile_dsize = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_dsize <= 0 or not canvas.winfo_exists():
            return

        col_drag = event.x // mini_tile_dsize
        row_drag = event.y // mini_tile_dsize

        current_cell_drag = (row_drag, col_drag)

        # Check bounds against current project's supertile dimensions
        # The _place_tile_in_supertile will do the ultimate bounds check against self.sgw/sgh
        if (0 <= row_drag < self.supertile_grid_height and \
            0 <= col_drag < self.supertile_grid_width and \
            current_cell_drag != self.last_placed_supertile_cell):

            placed_drag = self._place_tile_in_supertile(row_drag, col_drag)

            if placed_drag:
                self.last_placed_supertile_cell = current_cell_drag

    def handle_supertile_def_release(self, event):
        """Resets the drag state when the mouse button is released over the supertile definition canvas."""
        self.last_placed_supertile_cell = None

    def _update_map_coords_display(self, event):
        """Updates the coordinate label based on mouse motion over the map canvas."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        canvas = self.map_canvas
        try:
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)

            # Calculate supertile size at current zoom USING PROJECT DIMENSIONS
            zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims() # <--- USE THIS

            if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0: # Check both
                if hasattr(self, "map_coords_label"):
                    self.map_coords_label.config(text="ST Coords: Error")
                return

            # Calculate supertile row/col
            st_col = int(canvas_x // zoomed_st_pixel_w) # Use width for col
            st_row = int(canvas_y // zoomed_st_pixel_h) # Use height for row

            if 0 <= st_row < map_height and 0 <= st_col < map_width:
                coords_text = f"ST Coords: {st_col}, {st_row}"
            else:
                coords_text = "ST Coords: Out"

            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text=coords_text)

        except Exception as e:
            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text="ST Coords: Error")

    def _mark_project_modified(self):
        """Sets the project modified flag to True and updates the window title if needed."""
        if not self.project_modified:
            self.project_modified = True
            self._update_window_title()  # Update title when first marked as modified

    def flip_supertile_horizontal(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        if not (0 <= current_supertile_index < num_supertiles):
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition = supertiles_data[current_supertile_index]
        
        # Ensure definition structure matches project settings before modification
        if not current_definition or len(current_definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition[0]) != self.supertile_grid_width)):
            # print(f"Warning: Supertile {current_supertile_index} dimensions mismatch for horizontal flip.")
            # Optionally show error or skip
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile") # Redraw to show original if error
            return

        new_definition_flipped = []
        for r_flip_h in range(self.supertile_grid_height): # Iterate through rows
            # Ensure row exists and is a list before reversing
            if r_flip_h < len(current_definition) and isinstance(current_definition[r_flip_h], list):
                 new_definition_flipped.append(current_definition[r_flip_h][::-1]) # Reverse each row
            else: # Handle malformed row, append a blank row of correct width
                 new_definition_flipped.append([0] * self.supertile_grid_width)


        supertiles_data[current_supertile_index] = new_definition_flipped

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else: # Marks were cleared
            self.update_all_displays(changed_level="all") # Ensure full redraw
        print(f"Supertile {current_supertile_index} flipped horizontally.")

    def flip_supertile_vertical(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        if not (0 <= current_supertile_index < num_supertiles):
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_to_flip = supertiles_data[current_supertile_index]
        
        # Optional: Check if current_definition_to_flip actual height matches self.supertile_grid_height
        if len(current_definition_to_flip) != self.supertile_grid_height:
            # print(f"Warning: Supertile {current_supertile_index} height mismatch for vertical flip. Proceeding with actual length.")
            # This might indicate inconsistent data. For robustness, one might pad/truncate current_definition_to_flip
            # to self.supertile_grid_height before reversing, or create a new list.
            # For now, we reverse what's there.
            pass

        current_definition_to_flip.reverse() # Reverses the list of rows

        # No need to reassign to supertiles_data[current_supertile_index] as reverse() is in-place

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} flipped vertically.")

    def rotate_supertile_90cw(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        if not (0 <= current_supertile_index < num_supertiles):
            return

        # --- Disable rotation for non-square supertiles ---
        if self.supertile_grid_width != self.supertile_grid_height:
            messagebox.showinfo("Rotate Supertile", "Rotation is only enabled for square supertiles.", parent=self.root)
            return
        # --- End disable ---

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_rotate = supertiles_data[current_supertile_index]
        
        # Since it's square, dim_rotate = self.supertile_grid_width (or height)
        dim_rotate = self.supertile_grid_width 
        
        # Ensure definition structure matches before rotation
        if not current_definition_rotate or len(current_definition_rotate) != dim_rotate or \
           (dim_rotate > 0 and (len(current_definition_rotate[0]) != dim_rotate)):
            # print(f"Warning: Supertile {current_supertile_index} dimensions mismatch for rotation.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        new_definition_rotated = [[0 for _c in range(dim_rotate)] for _r in range(dim_rotate)]

        for r_rot in range(dim_rotate):
            for c_rot in range(dim_rotate):
                # Check bounds just in case definition was malformed despite earlier check
                if r_rot < len(current_definition_rotate) and c_rot < len(current_definition_rotate[r_rot]):
                    new_definition_rotated[c_rot][(dim_rotate - 1) - r_rot] = current_definition_rotate[r_rot][c_rot]
                # Else, new_definition_rotated already has 0 for that cell

        supertiles_data[current_supertile_index] = new_definition_rotated

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} rotated 90 CW.")

    def shift_supertile_up(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_height = self.supertile_grid_height # Use current project setting
        if not (0 <= current_supertile_index < num_supertiles) or current_st_height <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift = supertiles_data[current_supertile_index]
        
        # Ensure definition structure matches project settings
        if not current_definition_shift or len(current_definition_shift) != current_st_height:
            # print(f"Warning: Supertile {current_supertile_index} height mismatch for shift up.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return
        
        # Store the first row (which will wrap around to the bottom)
        # Ensure it's a deepcopy if rows themselves are mutable lists and you want to avoid aliasing issues,
        # though for lists of integers (tile indices), direct assignment is fine for the row itself.
        first_row_data = current_definition_shift[0][:] # Shallow copy of the row is sufficient

        for r_shift_up in range(current_st_height - 1):
            current_definition_shift[r_shift_up] = current_definition_shift[r_shift_up + 1]

        current_definition_shift[current_st_height - 1] = first_row_data
        
        # No need to reassign to supertiles_data as modification is in-place

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted up.")

    def shift_supertile_down(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_height = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_height <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_d = supertiles_data[current_supertile_index]

        if not current_definition_shift_d or len(current_definition_shift_d) != current_st_height:
            # print(f"Warning: Supertile {current_supertile_index} height mismatch for shift down.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return
            
        last_row_data = current_definition_shift_d[current_st_height - 1][:] # Shallow copy

        for r_shift_d in range(current_st_height - 1, 0, -1):
            current_definition_shift_d[r_shift_d] = current_definition_shift_d[r_shift_d - 1]

        current_definition_shift_d[0] = last_row_data

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted down.")

    def shift_supertile_left(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_w = self.supertile_grid_width
        current_st_h = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w <= 0 or current_st_h <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_l = supertiles_data[current_supertile_index]

        # Basic structure check
        if not current_definition_shift_l or len(current_definition_shift_l) != current_st_h or \
           (current_st_h > 0 and (len(current_definition_shift_l[0]) != current_st_w)):
            # print(f"Warning: Supertile {current_supertile_index} dimensions mismatch for shift left.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        for r_shift_l in range(current_st_h): # Iterate through each row
            # Ensure row exists (it should, based on height check)
            if r_shift_l < len(current_definition_shift_l):
                row_data_list = current_definition_shift_l[r_shift_l]
                # Ensure row_data_list has expected width
                if len(row_data_list) == current_st_w and current_st_w > 0 :
                    first_tile_in_row = row_data_list[0]
                    for c_shift_l in range(current_st_w - 1):
                        row_data_list[c_shift_l] = row_data_list[c_shift_l + 1]
                    row_data_list[current_st_w - 1] = first_tile_in_row
                # else: Malformed row width, skip shifting this row or pad/error. For now, skip.
            # else: Malformed definition (too few rows), skip.

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted left.")

    def shift_supertile_right(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global

        current_st_w = self.supertile_grid_width
        current_st_h = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w <= 0 or current_st_h <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_r = supertiles_data[current_supertile_index]

        if not current_definition_shift_r or len(current_definition_shift_r) != current_st_h or \
           (current_st_h > 0 and (len(current_definition_shift_r[0]) != current_st_w)):
            # print(f"Warning: Supertile {current_supertile_index} dimensions mismatch for shift right.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        for r_shift_r in range(current_st_h):
            if r_shift_r < len(current_definition_shift_r):
                row_data_list_r = current_definition_shift_r[r_shift_r]
                if len(row_data_list_r) == current_st_w and current_st_w > 0:
                    last_tile_in_row = row_data_list_r[current_st_w - 1]
                    for c_shift_r in range(current_st_w - 1, 0, -1):
                        row_data_list_r[c_shift_r] = row_data_list_r[c_shift_r - 1]
                    row_data_list_r[0] = last_tile_in_row
                # else: Malformed row width
            # else: Malformed definition

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted right.")

    def handle_supertile_def_right_click(self, event):
        global selected_tile_for_supertile, current_supertile_index, num_supertiles, num_tiles_in_set, supertiles_data

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile in editor
        mini_tile_disp_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_disp_size <= 0 or not canvas.winfo_exists():
            return

        col = event.x // mini_tile_disp_size
        row = event.y // mini_tile_disp_size

        # Check click against current project's supertile dimensions
        if (
            0 <= row < self.supertile_grid_height
            and 0 <= col < self.supertile_grid_width
            and 0 <= current_supertile_index < num_supertiles
        ):
            try:
                # Ensure definition structure matches before accessing
                definition_rc = supertiles_data[current_supertile_index]
                if not definition_rc or len(definition_rc) != self.supertile_grid_height or \
                   (self.supertile_grid_height > 0 and (len(definition_rc[0]) != self.supertile_grid_width)):
                    # print(f"Warning: ST def {current_supertile_index} dim mismatch in right_click.")
                    return

                clicked_tile_index_val = definition_rc[row][col]

                if 0 <= clicked_tile_index_val < num_tiles_in_set:
                    if selected_tile_for_supertile != clicked_tile_index_val:
                        selected_tile_for_supertile = clicked_tile_index_val
                        # print(f"Right-click selected Tile: {selected_tile_for_supertile}")
                        self.draw_tileset_viewer(
                            self.st_tileset_canvas, selected_tile_for_supertile
                        )
                        self.update_supertile_info_labels()
                        self.scroll_viewers_to_tile(selected_tile_for_supertile)
                # else:
                    # print(f"Right-click: Tile index {clicked_tile_index_val} at ST def [{row},{col}] is out of tile bounds (max {num_tiles_in_set-1}).")

            except IndexError: # Should be caught by structure check above
                # print(f"Right-click: IndexError accessing supertile data for ST {current_supertile_index} at def [{row},{col}].")
                pass
            except Exception as e:
                # print(f"Right-click: Unexpected error in supertile def handler: {e}")
                pass
        # else: Click was outside the definition grid based on current W/H dimensions

    def handle_map_canvas_right_click(self, event):
        """Handles right-click on the map canvas to select the clicked supertile."""
        global selected_supertile_for_map, map_data, map_width, map_height, num_supertiles

        # Prevent interference with panning or other actions
        if self.current_mouse_action is not None:
            return "break"  # Stop event propagation if another action is active

        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        # Calculate zoomed supertile size
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return
        zoomed_supertile_size = SUPERTILE_GRID_DIM * zoomed_tile_size
        if zoomed_supertile_size <= 0:
            return

        # Get canvas coordinates (handles scrolling)
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Calculate map column and row in supertile units
        map_col = int(canvas_x // zoomed_supertile_size)
        map_row = int(canvas_y // zoomed_supertile_size)

        # Check if the click is within the map bounds
        if 0 <= map_row < map_height and 0 <= map_col < map_width:
            try:
                # Get the supertile index at the clicked map cell
                clicked_supertile_index = map_data[map_row][map_col]

                # Check if the retrieved supertile index is valid
                if 0 <= clicked_supertile_index < num_supertiles:
                    # Check if the selection actually changed
                    if selected_supertile_for_map != clicked_supertile_index:
                        selected_supertile_for_map = clicked_supertile_index
                        print(
                            f"Right-click selected Supertile: {selected_supertile_for_map}"
                        )
                        # Redraw the supertile selector in the map tab
                        self.draw_supertile_selector(
                            self.map_supertile_selector_canvas,
                            selected_supertile_for_map,
                        )
                        # Update the info label
                        self.update_map_info_labels()
                        # Scroll the selector to the selected supertile
                        self.scroll_selectors_to_supertile(selected_supertile_for_map)
                else:
                    print(
                        f"Right-click: Supertile index {clicked_supertile_index} at map [{map_row},{map_col}] is out of bounds (max {num_supertiles-1})."
                    )

            except IndexError:
                print(
                    f"Right-click: Error accessing map data at [{map_row},{map_col}]."
                )
            except Exception as e:
                print(f"Right-click: Unexpected error in map canvas handler: {e}")

    def _check_tile_usage(self, tile_index_check): # Renamed tile_index
        used_in_supertiles_list = [] # Renamed
        if not (0 <= tile_index_check < num_tiles_in_set):
            return used_in_supertiles_list

        for st_idx_check in range(num_supertiles):
            definition_check = supertiles_data[st_idx_check] # global
            
            # Check consistency of this definition with project settings
            if not definition_check or len(definition_check) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_check[0]) != self.supertile_grid_width)):
                # print(f"Warning: Supertile {st_idx_check} has inconsistent dimensions in _check_tile_usage. Skipping.")
                continue # Skip this malformed supertile definition

            found_in_current_st = False
            for r_check in range(self.supertile_grid_height):
                for c_check in range(self.supertile_grid_width):
                    # Bounds check for r_check, c_check within definition_check already done by loops
                    # and the initial structure check.
                    if definition_check[r_check][c_check] == tile_index_check:
                        if st_idx_check not in used_in_supertiles_list:
                            used_in_supertiles_list.append(st_idx_check)
                        found_in_current_st = True
                        break 
                if found_in_current_st:
                    break 
        return used_in_supertiles_list

    def _check_supertile_usage(self, supertile_index):
        """Checks if a supertile_index is used in the map data.
        Returns a list of (row, col) map coordinates that use it.
        """
        used_in_map = []
        if not (0 <= supertile_index < num_supertiles):
            return used_in_map  # Invalid index

        for r in range(map_height):
            for c in range(map_width):
                if map_data[r][c] == supertile_index:
                    used_in_map.append((r, c))
        return used_in_map

    # --- NEW: Reference Update Helpers ---
    def _update_supertile_refs_for_tile_change(self, tile_idx_changed, action_type): # Renamed index, action
        # This method assumes supertiles_data (global) is correctly structured
        # according to self.supertile_grid_width and self.supertile_grid_height.

        for st_idx_update in range(num_supertiles):
            current_definition_update = supertiles_data[st_idx_update] # global

            # Basic check for definition consistency
            if not current_definition_update or len(current_definition_update) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(current_definition_update[0]) != self.supertile_grid_width)):
                # print(f"Warning: Supertile {st_idx_update} has inconsistent dimensions in _update_supertile_refs. Skipping.")
                continue

            for r_update in range(self.supertile_grid_height):
                for c_update in range(self.supertile_grid_width):
                    # Bounds for r_update, c_update are implicitly handled by loops
                    # and the consistency check above.
                    current_tile_ref = current_definition_update[r_update][c_update]
                    
                    if action_type == "insert":
                        if current_tile_ref >= tile_idx_changed:
                            # current_definition_update[r_update][c_update] += 1
                            # It's safer to modify the global directly if that's the pattern
                            supertiles_data[st_idx_update][r_update][c_update] += 1
                    elif action_type == "delete":
                        if current_tile_ref == tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] = 0 # Replace deleted with tile 0
                        elif current_tile_ref > tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] -= 1
                    # else: No action for unknown action_type (already printed warning if that happened)
        
        # No specific warning for unknown action_type here, assumed to be handled by caller or design.

    def _update_map_refs_for_supertile_change(self, index, action):
        """Updates supertile indices in the map data after a supertile insert/delete.

        Args:
            index (int): The index where the supertile insert/delete occurred.
            action (str): 'insert' or 'delete'.
        """
        if action == "insert":
            # Increment references >= index
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] >= index:
                        map_data[r][c] += 1
        elif action == "delete":
            # Decrement references > index, set == index to 0
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] == index:
                        map_data[r][c] = 0  # Replace deleted with supertile 0
                    elif map_data[r][c] > index:
                        map_data[r][c] -= 1
        else:
            print(
                f"Warning: Unknown action '{action}' in _update_map_refs_for_supertile_change"
            )

    def _insert_tile(self, index):
        """Core logic to insert a blank tile at the specified index.

        Args:
            index (int): The index at which to insert.

        Returns:
            bool: True if insertion was successful, False otherwise.
        """
        global num_tiles_in_set, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX

        if not (
            0 <= index <= num_tiles_in_set
        ):  # Allow inserting at the end (index == count)
            print(
                f"Error: Insert tile index {index} out of range [0, {num_tiles_in_set}]."
            )
            return False
        if num_tiles_in_set >= MAX_TILES:
            print("Error: Cannot insert tile, maximum tiles reached.")
            # Optionally show messagebox if needed later, but core logic just returns False
            # messagebox.showwarning("Maximum Tiles", f"Cannot insert: Max {MAX_TILES} tiles reached.")
            return False

        # Create blank tile data
        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]

        # Insert into data lists
        tileset_patterns.insert(index, blank_pattern)
        tileset_colors.insert(index, blank_colors)
        # Remove the overflow if MAX_TILES was exceeded by insert (shouldn't happen due to check)
        # Although Python lists grow, our MAX_TILES implies a fixed-size array conceptually
        if len(tileset_patterns) > MAX_TILES:
            tileset_patterns.pop()
        if len(tileset_colors) > MAX_TILES:
            tileset_colors.pop()

        # Update references in supertiles
        self._update_supertile_refs_for_tile_change(index, "insert")

        # Mark modified AFTER successful data changes
        self._mark_project_modified()
        return True

    def _delete_tile(self, index):
        """Core logic to delete the tile at the specified index.

        Args:
            index (int): The index of the tile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global num_tiles_in_set, tileset_patterns, tileset_colors

        if not (0 <= index < num_tiles_in_set):
            print(
                f"Error: Delete tile index {index} out of range [0, {num_tiles_in_set - 1}]."
            )
            return False
        if num_tiles_in_set <= 1:
            print("Error: Cannot delete the last tile.")
            # messagebox.showwarning("Cannot Delete", "Cannot delete the last remaining tile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data lists
        del tileset_patterns[index]
        del tileset_colors[index]

        # Append dummy data to keep list size MAX_TILES (conceptually)
        # Or adjust MAX_TILES usage if lists are truly dynamic
        # For now, let's assume we might refill later, so keep placeholders?
        # Alternative: just let list shrink. Let's let it shrink.
        # tileset_patterns.append([[0]*TILE_WIDTH for _ in range(TILE_HEIGHT)])
        # tileset_colors.append([(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)])

        # Update references in supertiles
        self._update_supertile_refs_for_tile_change(index, "delete")

        # Mark modified AFTER successful data changes
        self._mark_project_modified()
        return True

    def _insert_supertile(self, index_to_insert_at): # Renamed index
        global num_supertiles, supertiles_data # supertiles_data is global

        if not (0 <= index_to_insert_at <= num_supertiles):
            # print(f"Error: Insert supertile index {index_to_insert_at} out of range [0, {num_supertiles}].")
            return False
        if num_supertiles >= MAX_SUPERTILES:
            # print("Error: Cannot insert supertile, maximum reached.")
            return False

        # Create blank supertile data using current project dimensions
        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]

        supertiles_data.insert(index_to_insert_at, blank_st_definition) # Inserts into global
        
        # If supertiles_data is meant to be strictly MAX_SUPERTILES in length (padded)
        if len(supertiles_data) > MAX_SUPERTILES:
            supertiles_data.pop() # Remove the last one if insertion exceeded MAX_SUPERTILES conceptual limit

        self._update_map_refs_for_supertile_change(index_to_insert_at, "insert")
        self._mark_project_modified()
        return True

    def _delete_supertile(self, index):
        """Core logic to delete the supertile at the specified index.

        Args:
            index (int): The index of the supertile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global num_supertiles, supertiles_data

        if not (0 <= index < num_supertiles):
            print(
                f"Error: Delete supertile index {index} out of range [0, {num_supertiles - 1}]."
            )
            return False
        if num_supertiles <= 1:
            print("Error: Cannot delete the last supertile.")
            # messagebox.showwarning("Cannot Delete", "Cannot delete the last remaining supertile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data list
        del supertiles_data[index]
        # Let list shrink

        # Update references in map
        self._update_map_refs_for_supertile_change(index, "delete")

        self._mark_project_modified()
        return True

    def _update_editor_button_states(self):
        """Updates the enable/disable state of Add/Insert/Delete buttons."""
        global num_tiles_in_set, num_supertiles

        # --- Tile Editor Buttons ---
        can_add_tile = num_tiles_in_set < MAX_TILES
        can_insert_tile = num_tiles_in_set < MAX_TILES
        can_delete_tile = num_tiles_in_set > 1

        if hasattr(self, "add_tile_button"):
            self.add_tile_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED
            )
        if hasattr(self, "insert_tile_button"):
            self.insert_tile_button.config(
                state=tk.NORMAL if can_insert_tile else tk.DISABLED
            )
        if hasattr(self, "delete_tile_button"):
            self.delete_tile_button.config(
                state=tk.NORMAL if can_delete_tile else tk.DISABLED
            )

        # --- Supertile Editor Buttons ---
        can_add_supertile = num_supertiles < MAX_SUPERTILES
        can_insert_supertile = num_supertiles < MAX_SUPERTILES
        can_delete_supertile = num_supertiles > 1

        if hasattr(self, "add_supertile_button"):
            self.add_supertile_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED
            )
        if hasattr(self, "insert_supertile_button"):
            self.insert_supertile_button.config(
                state=tk.NORMAL if can_insert_supertile else tk.DISABLED
            )
        if hasattr(self, "delete_supertile_button"):
            self.delete_supertile_button.config(
                state=tk.NORMAL if can_delete_supertile else tk.DISABLED
            )

    def handle_add_tile(self):  
        global num_tiles_in_set, current_tile_index
        
        # Clear marks BEFORE any modification that changes usage or indices
        if self._clear_marked_unused(trigger_redraw=False):
            # If marks were cleared, ensure a full redraw happens after other operations
            # by setting a flag or letting update_all_displays in success path handle it.
            # For simplicity here, we'll rely on the update_all_displays in the success path.
            pass

        success = self._insert_tile(num_tiles_in_set)  # Insert at the very end

        if success:
            num_tiles_in_set += 1
            new_tile_idx = num_tiles_in_set - 1
            current_tile_index = new_tile_idx  # Select the newly added tile

            self.clear_all_caches()  
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")  # Update everything
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()  
            # self._mark_project_modified() is called within _insert_tile
            print(f"Added new tile {new_tile_idx}")
        else:
            messagebox.showwarning(
                "Add Tile Failed", f"Could not add tile. Maximum {MAX_TILES} reached?"
            )

    def handle_insert_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if self._clear_marked_unused(trigger_redraw=False):
            pass # Full redraw will happen if successful

        insert_idx = current_tile_index
        success = self._insert_tile(insert_idx)

        if success:
            num_tiles_in_set += 1
            current_tile_index = insert_idx # Selection stays at the new blank tile

            if selected_tile_for_supertile >= insert_idx:
                selected_tile_for_supertile += 1
            # Clamp to be safe, though _insert_tile should ensure num_tiles_in_set is valid for this
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_tile
            print(f"Inserted tile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Tile Failed",
                f"Could not insert tile. Maximum {MAX_TILES} reached?",
            )

    def handle_delete_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if num_tiles_in_set <= 1:
            messagebox.showinfo("Delete Tile", "Cannot delete the last tile.")
            return

        delete_idx = current_tile_index
        if not (0 <= delete_idx < num_tiles_in_set):
            messagebox.showerror("Delete Tile Error", "Invalid tile index selected.")
            return

        usage = self._check_tile_usage(delete_idx)
        confirm_msg = f"Delete Tile {delete_idx}?"
        if usage:
            confirm_msg += "\n\n*** WARNING! ***\nThis tile is used by the following Supertile(s):\n"
            confirm_msg += ", ".join(map(str, usage[:10]))  
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += (
                f"\n\nReferences in these Supertiles will be reset to Tile 0."
            )

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"):
            return
        
        # Adjust marked set BEFORE actual data deletion and BEFORE _delete_tile
        # because _delete_tile will change num_tiles_in_set which might affect _adjust_marked logic
        # if it relied on the old num_tiles_in_set.
        self._adjust_marked_indices_after_delete(self.marked_unused_tiles, delete_idx)

        success = self._delete_tile(delete_idx) # Core logic does NOT clear marks

        if success:
            num_tiles_in_set -= 1
            # Adjust selection: stay at index if possible, else clamp to new max
            current_tile_index = min(delete_idx, num_tiles_in_set - 1)
            current_tile_index = max(0, current_tile_index) # Ensure not -1 if last tile deleted

            # Adjust other selections if they pointed to deleted or higher index
            if selected_tile_for_supertile == delete_idx:
                selected_tile_for_supertile = 0 # Default to 0 if deleted
            elif selected_tile_for_supertile > delete_idx:
                selected_tile_for_supertile -= 1
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)
            selected_tile_for_supertile = max(0, selected_tile_for_supertile)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # This will redraw with adjusted marks
            self.scroll_viewers_to_tile(current_tile_index)  
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _delete_tile
            print(f"Deleted tile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Tile Failed", "An error occurred during tile deletion."
            )

    def handle_add_supertile(self):  
        global num_supertiles, current_supertile_index

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        success = self._insert_supertile(num_supertiles)  

        if success:
            num_supertiles += 1
            new_st_idx = num_supertiles - 1
            current_supertile_index = new_st_idx  

            self.supertile_image_cache.clear()  
            self.invalidate_minimap_background_cache()
            self.update_all_displays(
                changed_level="all" # Changed to all
            )  
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_supertile
            print(f"Added new supertile {new_st_idx}")
        else:
            messagebox.showwarning(
                "Add Supertile Failed",
                f"Could not add supertile. Maximum {MAX_SUPERTILES} reached?",
            )

    def handle_insert_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        insert_idx = current_supertile_index
        success = self._insert_supertile(insert_idx)

        if success:
            num_supertiles += 1
            current_supertile_index = insert_idx

            if selected_supertile_for_map >= insert_idx:
                selected_supertile_for_map += 1
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles -1)

            self.supertile_image_cache.clear()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # Changed to all
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_supertile
            print(f"Inserted supertile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Supertile Failed",
                f"Could not insert supertile. Maximum {MAX_SUPERTILES} reached?",
            )

    def handle_delete_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        if num_supertiles <= 1:
            messagebox.showinfo("Delete Supertile", "Cannot delete the last supertile.")
            return

        delete_idx = current_supertile_index
        if not (0 <= delete_idx < num_supertiles):
            messagebox.showerror(
                "Delete Supertile Error", "Invalid supertile index selected."
            )
            return

        usage = self._check_supertile_usage(delete_idx)
        confirm_msg = f"Delete Supertile {delete_idx}?"
        if usage:
            map_coords_str = ", ".join(
                [f"({r_idx},{c_idx})" for r_idx, c_idx in usage[:10]] # Renamed r,c
            )  
            confirm_msg += (
                "\n\n*** WARNING! ***\nThis supertile is used on the Map at:\n"
            )
            confirm_msg += map_coords_str
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += f"\n\nReferences on the Map will be reset to Supertile 0."

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"):
            return
        
        self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, delete_idx)

        success = self._delete_supertile(delete_idx) # Does not clear marks

        if success:
            num_supertiles -= 1
            current_supertile_index = min(delete_idx, num_supertiles - 1)
            current_supertile_index = max(0, current_supertile_index)


            if selected_supertile_for_map == delete_idx:
                selected_supertile_for_map = 0
            elif selected_supertile_for_map > delete_idx:
                selected_supertile_for_map -= 1
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles - 1)
            selected_supertile_for_map = max(0, selected_supertile_for_map)


            self.supertile_image_cache.clear()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # Redraws with adjusted marks
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is in _delete_supertile
            print(f"Deleted supertile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Supertile Failed",
                "An error occurred during supertile deletion.",
            )

    def _reposition_tile(self, source_index_tile, target_index_tile): # Renamed
        global num_tiles_in_set, tileset_patterns, tileset_colors # Globals
        global current_tile_index, selected_tile_for_supertile, supertiles_data # Globals

        if not (0 <= source_index_tile < num_tiles_in_set):
            # print(f"Error: Invalid source index {source_index_tile} for tile move.")
            return False
        
        # Clamp target_index_tile to be within valid bounds for insertion [0, num_tiles_in_set]
        # If target_index_tile == num_tiles_in_set, it means move to the very end.
        clamped_target_index_tile = max(0, min(target_index_tile, num_tiles_in_set))

        if source_index_tile == clamped_target_index_tile or \
           (clamped_target_index_tile == num_tiles_in_set and source_index_tile == num_tiles_in_set -1) : # Moving last item to end
             if source_index_tile == clamped_target_index_tile -1 and clamped_target_index_tile == num_tiles_in_set : # Moving last to end is okay
                  pass # Allow moving last to effectively be "at the end" which is its current pos + 1 for insert
             elif source_index_tile == clamped_target_index_tile :
                  return False # No move needed if source is already at target (and not the special end case)


        # print(f"Repositioning Tile: From {source_index_tile} to {clamped_target_index_tile}")

        moved_pattern_data = tileset_patterns.pop(source_index_tile)
        moved_colors_data = tileset_colors.pop(source_index_tile)

        # Actual insertion index if target was after source (due to pop)
        actual_insert_idx = clamped_target_index_tile
        if clamped_target_index_tile > source_index_tile:
            actual_insert_idx -= 1
        actual_insert_idx = max(0, actual_insert_idx) # Ensure not negative after adjustment

        tileset_patterns.insert(actual_insert_idx, moved_pattern_data)
        tileset_colors.insert(actual_insert_idx, moved_colors_data)

        # Update Supertile References
        for st_idx_refo in range(num_supertiles):
            definition_refo = supertiles_data[st_idx_refo] # global
            if not definition_refo or len(definition_refo) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_refo[0]) != self.supertile_grid_width)):
                # print(f"Warning: ST {st_idx_refo} dim mismatch in _reposition_tile. Skipping ref update.")
                continue

            for r_refo in range(self.supertile_grid_height):
                for c_refo in range(self.supertile_grid_width):
                    current_ref_val = definition_refo[r_refo][c_refo]
                    new_ref_val = current_ref_val

                    if current_ref_val == source_index_tile:
                        new_ref_val = actual_insert_idx
                    elif source_index_tile < actual_insert_idx: # Moved DOWN (target > source logically, actual_insert_idx reflects this)
                        if source_index_tile < current_ref_val <= actual_insert_idx:
                             new_ref_val = current_ref_val - 1
                    elif source_index_tile > actual_insert_idx: # Moved UP (target < source logically)
                        if actual_insert_idx <= current_ref_val < source_index_tile:
                             new_ref_val = current_ref_val + 1
                    
                    if new_ref_val != current_ref_val:
                         supertiles_data[st_idx_refo][r_refo][c_refo] = new_ref_val # Update global

        # Update Selections
        if current_tile_index == source_index_tile:
            current_tile_index = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < current_tile_index <= actual_insert_idx:
            current_tile_index -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= current_tile_index < source_index_tile:
            current_tile_index += 1

        if selected_tile_for_supertile == source_index_tile:
            selected_tile_for_supertile = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < selected_tile_for_supertile <= actual_insert_idx:
            selected_tile_for_supertile -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= selected_tile_for_supertile < source_index_tile:
            selected_tile_for_supertile += 1

        current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
        selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

        self._mark_project_modified()
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        # print(f"  Successfully moved Tile {source_index_tile} to {actual_insert_idx}")
        return True

    def _reposition_supertile(self, source_index_st, target_index_st): # Renamed
        global num_supertiles, supertiles_data, map_data, map_width, map_height # Globals
        global current_supertile_index, selected_supertile_for_map 

        if not (0 <= source_index_st < num_supertiles):
            # print(f"Error: Invalid source index {source_index_st} for supertile move.")
            return False
        
        clamped_target_index_st = max(0, min(target_index_st, num_supertiles))

        if source_index_st == clamped_target_index_st or \
           (clamped_target_index_st == num_supertiles and source_index_st == num_supertiles -1) :
             if source_index_st == clamped_target_index_st -1 and clamped_target_index_st == num_supertiles :
                  pass
             elif source_index_st == clamped_target_index_st :
                  return False

        # print(f"Repositioning Supertile: From {source_index_st} to {clamped_target_index_st}")

        moved_st_definition = supertiles_data.pop(source_index_st) # Global

        actual_insert_idx_st = clamped_target_index_st
        if clamped_target_index_st > source_index_st:
            actual_insert_idx_st -= 1
        actual_insert_idx_st = max(0, actual_insert_idx_st)

        supertiles_data.insert(actual_insert_idx_st, moved_st_definition) # Global

        # Update Map References
        for r_map_refo in range(map_height):
            for c_map_refo in range(map_width):
                current_map_ref = map_data[r_map_refo][c_map_refo] # Global
                new_map_ref = current_map_ref

                if current_map_ref == source_index_st:
                    new_map_ref = actual_insert_idx_st
                elif source_index_st < actual_insert_idx_st: 
                    if source_index_st < current_map_ref <= actual_insert_idx_st:
                         new_map_ref = current_map_ref - 1
                elif source_index_st > actual_insert_idx_st: 
                    if actual_insert_idx_st <= current_map_ref < source_index_st:
                         new_map_ref = current_map_ref + 1
                
                if new_map_ref != current_map_ref:
                     map_data[r_map_refo][c_map_refo] = new_map_ref # Global

        # Update Selections
        if current_supertile_index == source_index_st:
            current_supertile_index = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < current_supertile_index <= actual_insert_idx_st:
            current_supertile_index -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= current_supertile_index < source_index_st:
            current_supertile_index += 1

        if selected_supertile_for_map == source_index_st:
            selected_supertile_for_map = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < selected_supertile_for_map <= actual_insert_idx_st:
            selected_supertile_for_map -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= selected_supertile_for_map < source_index_st:
            selected_supertile_for_map += 1

        current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
        selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

        self._mark_project_modified()
        self.supertile_image_cache.clear() # Clear all ST cache as many could have effectively changed ID
        self.invalidate_minimap_background_cache()
        # print(f"  Successfully moved Supertile {source_index_st} to {actual_insert_idx_st}")
        return True

    def _get_index_from_canvas_coords(self, canvas, x_event, y_event, item_type_str): # Renamed parameters
        padding = 1 
        items_across_calc = 0
        item_render_w = 0
        item_render_h = 0
        max_items_count = 0

        if item_type_str == "tile":
            items_across_calc = NUM_TILES_ACROSS # Constant for tile viewers
            item_render_w = VIEWER_TILE_SIZE
            item_render_h = VIEWER_TILE_SIZE
            max_items_count = num_tiles_in_set
        elif item_type_str == "supertile":
            # For supertile selectors, calculate dynamic items_across
            item_render_w = self.supertile_grid_width * TILE_WIDTH # Actual pixel W of ST preview
            item_render_h = self.supertile_grid_height * TILE_HEIGHT # Actual pixel H of ST preview
            max_items_count = num_supertiles

            if item_render_w <= 0 or item_render_h <= 0: return -1 # Invalid ST dimensions

            target_layout_w = 256 # Target width for ST selector layout
            actual_canvas_w = canvas.winfo_width()
            if actual_canvas_w <= 1: return -1 # Canvas not ready

            effective_layout_w = min(target_layout_w, actual_canvas_w)
            
            current_items_across = 0
            for p_o_2_val in [32, 16, 8, 4, 2, 1]:
                if p_o_2_val == 0: continue
                required_w = (p_o_2_val * item_render_w) + ((p_o_2_val + 1) * padding)
                if required_w <= effective_layout_w:
                    current_items_across = p_o_2_val
                    break
            if current_items_across == 0:
                if item_render_w + 2 * padding <= effective_layout_w: current_items_across = 1
                elif item_render_w <= effective_layout_w: current_items_across = 1
                else: current_items_across = 1 
            items_across_calc = max(1, current_items_across)
        else:
            # print(f"Error: Invalid item_type '{item_type_str}' in _get_index_from_canvas_coords")
            return -1

        if item_render_w <= 0 or item_render_h <= 0 or items_across_calc <= 0:
            # print(f"Error: Invalid calculated layout params for {item_type_str}")
            return -1

        try:
            canvas_content_x = canvas.canvasx(x_event)
            canvas_content_y = canvas.canvasy(y_event)
        except tk.TclError:
            return -1 # Canvas might not be fully configured

        # Calculate total content dimensions based on dynamic layout for supertiles
        num_logical_rows_calc = math.ceil(max_items_count / items_across_calc) if items_across_calc > 0 else 0
        total_content_w = (items_across_calc * item_render_w) + ((items_across_calc + 1) * padding)
        total_content_h = (num_logical_rows_calc * item_render_h) + ((num_logical_rows_calc + 1) * padding)

        if not (-padding <= canvas_content_x < total_content_w and \
                -padding <= canvas_content_y < total_content_h):
            return -2 # Clicked outside grid content area (but within canvas bounds possibly)

        # Calculate column and row based on the item's render dimensions
        col_calc = int(canvas_content_x // (item_render_w + padding))
        row_calc = int(canvas_content_y // (item_render_h + padding))
        
        col_calc = max(0, col_calc) # Clamp
        row_calc = max(0, row_calc)

        index_calc = row_calc * items_across_calc + col_calc

        if 0 <= index_calc < max_items_count:
            return index_calc
        else:
            # Clicked within grid area but beyond the last *valid* item.
            # This can signify a drop target at the end of the list.
            # Return max_items_count (the count) to indicate this "end of list" target.
            return max_items_count

    def handle_viewer_drag_motion(self, event):
        if self.drag_start_index == -1 or self.drag_item_type is None or self.drag_canvas is None:
            return

        canvas_motion = event.widget 

        if not self.drag_active:
            dx = event.x - self.drag_press_x
            dy = event.y - self.drag_press_y
            distance_squared = dx*dx + dy*dy

            if distance_squared >= (DRAG_THRESHOLD_PIXELS * DRAG_THRESHOLD_PIXELS):
                self.drag_active = True
                
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if self.drag_item_type == "tile":
                        other_highlight_idx = -1
                        if self.drag_canvas == self.tileset_canvas:
                             other_highlight_idx = selected_tile_for_supertile
                        elif self.drag_canvas == self.st_tileset_canvas:
                             other_highlight_idx = current_tile_index
                        self.draw_tileset_viewer(self.drag_canvas, other_highlight_idx) # Pass original selection
                    elif self.drag_item_type == "supertile":
                        other_highlight_idx_st = -1
                        if self.drag_canvas == self.supertile_selector_canvas:
                            other_highlight_idx_st = selected_supertile_for_map
                        elif self.drag_canvas == self.map_supertile_selector_canvas:
                            other_highlight_idx_st = current_supertile_index
                        self.draw_supertile_selector(self.drag_canvas, other_highlight_idx_st) # Pass original selection
                try:
                    if canvas_motion.winfo_exists():
                        canvas_motion.config(cursor="hand2")
                except tk.TclError: pass
            else:
                return # Threshold not met
        
        if not self.drag_active: 
            return

        target_canvas_for_indicator = self.drag_canvas # Indicator drawn on original drag canvas
        if not target_canvas_for_indicator or not target_canvas_for_indicator.winfo_exists():
            self.drag_active = False; self.drag_item_type = None; self.drag_start_index = -1; self.drag_canvas = None
            if self.drag_indicator_id and canvas_motion.winfo_exists():
                try: canvas_motion.delete(self.drag_indicator_id)
                except tk.TclError: pass
            self.drag_indicator_id = None
            return

        target_idx_motion = self._get_index_from_canvas_coords(
            canvas_motion, event.x, event.y, self.drag_item_type
        )

        if self.drag_indicator_id:
            try: target_canvas_for_indicator.delete(self.drag_indicator_id)
            except tk.TclError: pass
            self.drag_indicator_id = None

        if target_idx_motion >= 0 and canvas_motion == target_canvas_for_indicator:
            padding_ind = 1
            item_w_ind, item_h_ind, items_across_ind, max_items_ind = 0,0,0,0

            if self.drag_item_type == "tile":
                item_w_ind = VIEWER_TILE_SIZE
                item_h_ind = VIEWER_TILE_SIZE
                items_across_ind = NUM_TILES_ACROSS
                max_items_ind = num_tiles_in_set
            elif self.drag_item_type == "supertile":
                item_w_ind = self.supertile_grid_width * TILE_WIDTH
                item_h_ind = self.supertile_grid_height * TILE_HEIGHT

                max_items_ind = num_supertiles
                
                target_layout_w_ind = 256
                actual_canvas_w_ind = target_canvas_for_indicator.winfo_width()
                effective_layout_w_ind = min(target_layout_w_ind, actual_canvas_w_ind)
                current_items_across_ind = 0
                for p_o_2_val_ind in [32, 16, 8, 4, 2, 1]:
                    if p_o_2_val_ind == 0: continue
                    req_w_ind = (p_o_2_val_ind * item_w_ind) + ((p_o_2_val_ind + 1) * padding_ind)
                    if req_w_ind <= effective_layout_w_ind:
                        current_items_across_ind = p_o_2_val_ind
                        break
                if current_items_across_ind == 0:
                    if item_w_ind + 2 * padding_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    elif item_w_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    else: current_items_across_ind = 1
                items_across_ind = max(1, current_items_across_ind)

            if item_w_ind > 0 and item_h_ind > 0 and items_across_ind > 0:
                indicator_pos_idx = min(target_idx_motion, max_items_ind) 
                
                row_ind, col_ind = divmod(indicator_pos_idx, items_across_ind)
                
                line_x_pos = (col_ind * (item_w_ind + padding_ind)) + (padding_ind / 2) 
                line_y1_pos = (row_ind * (item_h_ind + padding_ind)) + (padding_ind / 2)
                line_y2_pos = line_y1_pos + item_h_ind 

                self.drag_indicator_id = target_canvas_for_indicator.create_line(
                    line_x_pos, line_y1_pos, line_x_pos, line_y2_pos,
                    fill="yellow", width=3, tags="drop_indicator"
                )
        try:
            if canvas_motion.winfo_exists() and canvas_motion.cget("cursor") != "hand2":
                 canvas_motion.config(cursor="hand2")
        except tk.TclError: pass

    def handle_viewer_drag_release(self, event):
        """Handles mouse button release over viewer/selector canvases.
        Completes either a click selection or a drag-and-drop repositioning.
        """
        global current_tile_index, selected_tile_for_supertile  # Selections
        global current_supertile_index, selected_supertile_for_map  # Selections

        canvas = event.widget  # Canvas where release occurred
        was_dragging = self.drag_active  # Check drag state BEFORE resetting

        # --- Always clean up visual drag indicators first ---
        if self.drag_indicator_id:
            # Try deleting from original drag canvas first, then current canvas
            try:
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    self.drag_canvas.delete(self.drag_indicator_id)
                elif canvas.winfo_exists():  # Fallback to current canvas
                    canvas.delete(self.drag_indicator_id)
            except tk.TclError:
                pass  # Ignore if already gone
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists():
                canvas.config(cursor="")  # Reset cursor on the current canvas
        except tk.TclError:
            pass

        # --- Determine Item Type and Max Items based on Canvas ---
        # This is needed for both click and drag-release scenarios
        item_type = None
        max_items = 0
        source_canvas_type = None  # Track where drag started for potential validation

        if canvas == self.tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "tile_editor_main"
        elif canvas == self.st_tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "supertile_editor_tile"
        elif canvas == self.supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "supertile_editor_main"
        elif canvas == self.map_supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "map_editor_palette"
        else:
            # Should not happen if bindings are correct
            print(f"Warning: Drag release on unknown canvas: {canvas}")
            # Reset drag state fully and exit
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            return

        # --- Get Index Under Cursor ---
        index_at_release = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, item_type
        )

        # --- Handle Release ---
        if not was_dragging:
            # --- Scenario 1: It was just a CLICK (no drag initiated or minimal movement) ---
            if 0 <= index_at_release < max_items:  # Ensure click was on a valid item
                # Perform the original selection logic based on the canvas type
                if item_type == "tile":
                    if (
                        source_canvas_type == "tile_editor_main"
                    ):  # Main tile editor viewer
                        if current_tile_index != index_at_release:
                            current_tile_index = index_at_release
                            self.update_all_displays(
                                changed_level="tile"
                            )  # Redraw editor, viewers
                            self.scroll_viewers_to_tile(
                                current_tile_index
                            )  # Scroll to selection
                    elif (
                        source_canvas_type == "supertile_editor_tile"
                    ):  # Supertile's tile selector
                        if selected_tile_for_supertile != index_at_release:
                            selected_tile_for_supertile = index_at_release
                            # Only redraw this specific viewer and label
                            self.draw_tileset_viewer(
                                self.st_tileset_canvas, selected_tile_for_supertile
                            )
                            self.update_supertile_info_labels()
                            self.scroll_viewers_to_tile(
                                selected_tile_for_supertile
                            )  # Scroll this viewer
                elif item_type == "supertile":
                    if (
                        source_canvas_type == "supertile_editor_main"
                    ):  # Main supertile selector
                        if current_supertile_index != index_at_release:
                            current_supertile_index = index_at_release
                            self.update_all_displays(changed_level="supertile")
                            self.scroll_selectors_to_supertile(
                                current_supertile_index
                            )  # Scroll
                    elif (
                        source_canvas_type == "map_editor_palette"
                    ):  # Map's supertile selector
                        if selected_supertile_for_map != index_at_release:
                            selected_supertile_for_map = index_at_release
                            # Only redraw this specific selector and label
                            self.draw_supertile_selector(
                                self.map_supertile_selector_canvas,
                                selected_supertile_for_map,
                            )
                            self.update_map_info_labels()
                            self.scroll_selectors_to_supertile(
                                selected_supertile_for_map
                            )  # Scroll

        else:
            # --- Scenario 2: It was a DRAG RELEASE ---
            source_index = self.drag_start_index
            dragged_item_type = self.drag_item_type  # Get type from drag state

            # Basic validation: Drag type must match release canvas type
            if dragged_item_type != item_type:
                print(
                    f"Warning: Drag type mismatch. Started '{dragged_item_type}', dropped on '{item_type}'. Cancelling."
                )
                # Redraw the source canvas to remove drag highlight
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if dragged_item_type == "tile":
                        self.draw_tileset_viewer(
                            self.drag_canvas, -1
                        )  # Use dummy highlight index
                    elif dragged_item_type == "supertile":
                        self.draw_supertile_selector(self.drag_canvas, -1)
                # Reset state fully handled below
            else:
                # Determine the final target index for the repositioning logic
                # index_at_release == max_items means drop at the end
                # index_at_release == -2 means dropped outside valid grid area
                # index_at_release == -1 means error in calculation
                valid_drop_target = False
                final_target_index = -1

                if index_at_release == max_items:  # Drop at the very end
                    final_target_index = max_items  # Pass count to reposition logic
                    valid_drop_target = True
                elif 0 <= index_at_release < max_items:  # Drop onto a specific index
                    final_target_index = index_at_release
                    valid_drop_target = True

                if valid_drop_target and final_target_index != source_index:
                    # Proceed with repositioning
                    success = False
                    print(
                        f"Completing Drag: Moving {item_type} from {source_index} to target {final_target_index}"
                    )
                    if item_type == "tile":
                        success = self._reposition_tile(
                            source_index, final_target_index
                        )
                    elif item_type == "supertile":
                        success = self._reposition_supertile(
                            source_index, final_target_index
                        )

                    if success:
                        # Repositioning handles index updates and marking modified
                        # Need full redraw and cache clear due to potential cascading reference changes
                        self.clear_all_caches()
                        self.invalidate_minimap_background_cache()
                        self.update_all_displays(changed_level="all")
                        # Scroll viewers/selectors to the *new* location of the primary selection index
                        if item_type == "tile":
                            self.scroll_viewers_to_tile(current_tile_index)
                        elif item_type == "supertile":
                            self.scroll_selectors_to_supertile(current_supertile_index)
                    else:
                        # Repositioning failed (e.g., internal error, should be rare)
                        messagebox.showerror(
                            "Reposition Error",
                            f"Failed to move {item_type} from {source_index} to {final_target_index}.",
                        )
                        # Attempt redraw even on failure to show current state
                        self.update_all_displays(changed_level="all")

                else:
                    # Dropped outside (-2), on itself, or calculation error (-1)
                    # Just redraw the relevant displays to remove drag highlight
                    print(
                        f"Drag cancelled or no move needed (target_index: {index_at_release}, source: {source_index})."
                    )
                    if item_type == "tile":
                        self.update_all_displays(changed_level="tile")
                    elif item_type == "supertile":
                        self.update_all_displays(changed_level="supertile")

        # --- Final Reset of Drag State (regardless of click or drag) ---
        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_canvas = None
        # Indicator ID and cursor should already be cleaned up above


    def _set_pencil_cursor(self, event):
        """Sets the cursor to 'pencil' for the widget that received the event."""
        try:
            # Check if widget still exists before configuring
            if event.widget.winfo_exists():
                event.widget.config(cursor="pencil")
        except tk.TclError:
            pass  # Ignore if widget is destroyed during event handling

    def _reset_cursor(self, event):
        """Resets the cursor to default for the widget that received the event."""
        try:
            if event.widget.winfo_exists():
                # Don't reset map canvas blindly, let its own logic handle it on leave
                if event.widget != self.map_canvas:
                    event.widget.config(cursor="")
                # If it *is* the map canvas, its existing <Leave> handler will take care of it
        except tk.TclError:
            pass  # Ignore if widget is destroyed

    # --- New Handlers and Helpers for Map Selection ---

    def handle_shift_press(self, event):
        """Handles Shift key press."""
        if "Shift" in event.keysym:
            if not self.is_shift_pressed:
                self.is_shift_pressed = True
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_shift_release(self, event):
        """Handles Shift key release."""
        if "Shift" in event.keysym:
            if self.is_shift_pressed:
                self.is_shift_pressed = False
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def _get_supertile_coords_from_canvas(self, canvas_x_coord, canvas_y_coord): # Renamed params
        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims()

        if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0:
            return None # Cannot calculate if dimensions are invalid

        st_col_calc = int(canvas_x_coord // zoomed_st_pixel_w)
        st_row_calc = int(canvas_y_coord // zoomed_st_pixel_h)

        if 0 <= st_row_calc < map_height and 0 <= st_col_calc < map_width:
            return (st_col_calc, st_row_calc)
        else:
            return None

    def _get_normalized_selection_st(self):
        """Returns normalized selection bounds (min_c, min_r, max_c, max_r) or None."""
        if self.map_selection_start_st is None or self.map_selection_end_st is None:
            return None

        start_c, start_r = self.map_selection_start_st
        end_c, end_r = self.map_selection_end_st

        min_c = min(start_c, end_c)
        min_r = min(start_r, end_r)
        max_c = max(start_c, end_c)
        max_r = max(start_r, end_r)

        return (min_c, min_r, max_c, max_r)

    def _draw_selection_rectangle(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        if self.map_selection_rect_id:
            try:
                canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass # Item might already be gone
            self.map_selection_rect_id = None

        norm_coords_sel = self._get_normalized_selection_st()
        if norm_coords_sel is None:
            return

        min_c_sel, min_r_sel, max_c_sel, max_r_sel = norm_coords_sel

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_sel, zoomed_st_pixel_h_sel = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_sel <= 0 or zoomed_st_pixel_h_sel <= 0:
            return

        px1_sel = min_c_sel * zoomed_st_pixel_w_sel
        py1_sel = min_r_sel * zoomed_st_pixel_h_sel
        px2_sel = (max_c_sel + 1) * zoomed_st_pixel_w_sel # +1 because coords are inclusive
        py2_sel = (max_r_sel + 1) * zoomed_st_pixel_h_sel

        try:
            self.map_selection_rect_id = canvas.create_rectangle(
                px1_sel, py1_sel, px2_sel, py2_sel,
                outline="yellow",
                dash=(4, 4),
                width=2,
                tags=("selection_rect",)
            )
            # Ensure it's drawn below other interactive elements
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_selection_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                canvas.tag_lower(self.map_selection_rect_id, "supertile_grid")
        except tk.TclError:
            self.map_selection_rect_id = None # Failed to create

    def _clear_map_selection(self):
        """Clears ONLY the map selection visual and related state variables."""
        canvas = self.map_canvas
        # Clear the visual rectangle
        if self.map_selection_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass
            self.map_selection_rect_id = None

        # Check if state needs updating before resetting (for menu update trigger)
        needs_menu_update = self.map_selection_start_st is not None

        # Reset selection state variables
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_selection_active = False # Ensure selection drag state is reset

        # Update menu if selection was active
        if needs_menu_update:
            self._update_edit_menu_state()
        # Do not redraw map here, let the caller handle redraw if needed
        # Do not clear paste preview or clipboard here

    def handle_map_selection_start(self, event):
        """Handles Shift + Button-1 press to start map selection."""
        if self.is_ctrl_pressed or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        self._clear_map_selection()

        start_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if start_coords:
            self.map_selection_start_st = start_coords
            self.map_selection_end_st = start_coords
            self.map_selection_active = True
            self._draw_selection_rectangle()
            self._update_map_cursor()
        else:
            self.map_selection_start_st = None
            self.map_selection_end_st = None
            self.map_selection_active = False

        return "break"

    def handle_map_selection_motion(self, event):
        """Handles Shift + B1 motion to update selection rectangle."""
        if not self.map_selection_active:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        current_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if current_coords:
            if self.map_selection_end_st != current_coords:
                self.map_selection_end_st = current_coords
                self._draw_selection_rectangle()
        # else: # Keep last valid end_st when mouse is outside

        return "break"

    def handle_map_selection_release(self, event):
        """Handles Shift + Button-1 release to finalize map selection."""
        if not self.map_selection_active:
            self._clear_map_selection()
            return

        self.map_selection_active = False

        if (
            self.map_selection_start_st is not None
            and self.map_selection_end_st is not None
        ):
            # print(f"Selection finalized: {self.map_selection_start_st} to {self.map_selection_end_st}")
            # Final rectangle drawn by motion handler, redraw map to make it persistent
            self.draw_map_canvas()
            self._update_edit_menu_state()
        else:
            self._clear_map_selection()

        self._update_map_cursor()

        return "break"

    def handle_map_escape(self, event):
        """Handles Escape key press on map canvas to clear clipboard, paste preview, and selection."""
        # print("Escape pressed, clearing clipboard, paste preview, and selection.")

        # Check what was active before clearing
        cleared_clipboard = self.map_clipboard_data is not None
        cleared_preview = self.map_paste_preview_rect_id is not None
        cleared_selection = self.map_selection_start_st is not None

        # Always attempt to clear clipboard, preview, and selection state
        self.map_clipboard_data = None
        self._clear_paste_preview_rect()
        self._clear_map_selection() # This now only clears selection visuals/state

        # Update menu state if the clipboard was cleared
        if cleared_clipboard:
            self._update_edit_menu_state()

        # Redraw map if the selection rectangle was visible to ensure it's removed
        # Clearing the paste preview doesn't require a full map redraw
        if cleared_selection and self.map_canvas.winfo_exists():
             self.draw_map_canvas()

        return "break" # Prevent other Escape bindings

    def _update_map_cursor_and_coords(self, event):
        """Combined handler for Motion to update both cursor and coords, and manage paste preview."""
        # Update coordinate display first
        self._update_map_coords_display(event)

        # Update cursor based on current state (e.g., pan, select, paint)
        self._update_map_cursor()

        # --- Paste Preview Logic ---
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                 selected_tab_index = self.notebook.index(self.notebook.select())
                 if selected_tab_index == 3: # Map Editor tab index
                     is_map_tab_active = True
            except tk.TclError:
                pass # Ignore if notebook not ready

        # Conditions to show paste preview: Map tab active AND map clipboard has data
        if is_map_tab_active and self.map_clipboard_data:
            self._draw_paste_preview_rect(event=event)
        else:
            # Clear preview if conditions are not met (e.g., wrong tab, no clipboard data)
            # This handles cases where clipboard is cleared while mouse is over canvas
            self._clear_paste_preview_rect()

    # --- New Paste Preview Methods ---
    def _draw_paste_preview_rect(self, event=None, canvas_coords=None):
        canvas = self.map_canvas
        if not canvas.winfo_exists() or not self.map_clipboard_data or not self.notebook:
            self._clear_paste_preview_rect()
            return
        try:
            if self.notebook.index(self.notebook.select()) != 3: # Map Editor tab index
                 self._clear_paste_preview_rect()
                 return
        except tk.TclError:
            self._clear_paste_preview_rect()
            return

        current_canvas_x_paste, current_canvas_y_paste = -1, -1
        if canvas_coords:
            current_canvas_x_paste, current_canvas_y_paste = canvas_coords
        elif event:
            try:
                current_canvas_x_paste = canvas.canvasx(event.x)
                current_canvas_y_paste = canvas.canvasy(event.y)
            except tk.TclError:
                self._clear_paste_preview_rect()
                return
        else:
             self._clear_paste_preview_rect()
             return

        paste_st_coords_preview = self._get_supertile_coords_from_canvas(current_canvas_x_paste, current_canvas_y_paste)

        if paste_st_coords_preview is None:
            self._clear_paste_preview_rect()
            return

        paste_st_col_preview, paste_st_row_preview = paste_st_coords_preview
        clip_w_preview = self.map_clipboard_data.get('width', 0)
        clip_h_preview = self.map_clipboard_data.get('height', 0)

        if clip_w_preview <= 0 or clip_h_preview <= 0:
            self._clear_paste_preview_rect()
            return

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_preview, zoomed_st_pixel_h_preview = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_preview <= 0 or zoomed_st_pixel_h_preview <= 0:
             self._clear_paste_preview_rect()
             return

        px1_preview = paste_st_col_preview * zoomed_st_pixel_w_preview
        py1_preview = paste_st_row_preview * zoomed_st_pixel_h_preview
        px2_preview = px1_preview + (clip_w_preview * zoomed_st_pixel_w_preview)
        py2_preview = py1_preview + (clip_h_preview * zoomed_st_pixel_h_preview)

        fill_color_preview = "#0000FF"
        stipple_pattern_preview = "gray50"

        if self.map_paste_preview_rect_id:
            try:
                canvas.coords(self.map_paste_preview_rect_id, px1_preview, py1_preview, px2_preview, py2_preview)
                canvas.itemconfig(self.map_paste_preview_rect_id, state=tk.NORMAL, fill=fill_color_preview, stipple=stipple_pattern_preview)
            except tk.TclError:
                self.map_paste_preview_rect_id = None
        
        if not self.map_paste_preview_rect_id:
            try:
                self.map_paste_preview_rect_id = canvas.create_rectangle(
                    px1_preview, py1_preview, px2_preview, py2_preview,
                    fill=fill_color_preview,
                    stipple=stipple_pattern_preview,
                    outline="", 
                    width=0,
                    tags=("paste_preview_rect",)
                )
            except tk.TclError:
                 self.map_paste_preview_rect_id = None
                 return

        try:
            if self.map_selection_rect_id:
                 canvas.tag_lower(self.map_paste_preview_rect_id, self.map_selection_rect_id)
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_paste_preview_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                 canvas.tag_lower(self.map_paste_preview_rect_id, "supertile_grid")
        except tk.TclError:
            pass


    def _clear_paste_preview_rect(self):
        """Safely deletes the paste preview rectangle from the canvas."""
        canvas = self.map_canvas
        if self.map_paste_preview_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_paste_preview_rect_id)
            except tk.TclError:
                pass # Ignore error if item already deleted or canvas gone
            finally:
                 # Ensure ID is cleared even if deletion fails
                 self.map_paste_preview_rect_id = None

    def show_about_box(self):
        """Displays the About information box with the application icon."""
        # Create a Toplevel window
        about_win = tk.Toplevel(self.root)
        about_win.title("About MSX Tile Forge")
        about_win.resizable(False, False) 
        about_win.transient(self.root) 
        about_win.grab_set() 

        # Main frame for content
        main_frame = ttk.Frame(about_win, padding="15")
        main_frame.pack(expand=True, fill="both")

        icon_label = None
        # Try to get the icon reference stored during startup on the root window
        app_icon_photo = getattr(self.root, 'app_icon_ref', None) # This should now find it

        if app_icon_photo:
            icon_label = ttk.Label(main_frame, image=app_icon_photo)
            # Keep reference for the label within this Toplevel
            icon_label.image = app_icon_photo 
            icon_label.grid(row=0, column=0, padx=(0, 15), pady=(0, 10), sticky="nw")

        # Text information frame
        text_frame = ttk.Frame(main_frame)
        text_frame.grid(row=0, column=1, sticky="nsew")

        # Program Name (Bold)
        style = ttk.Style()
        style.configure("About.TLabel", font=("-size", 10, "bold")) # Adjusted font size slightly
        name_label = ttk.Label(text_frame, text="MSX Tile Forge", style="About.TLabel")
        name_label.pack(anchor="w", pady=(0, 5))

        # Version and Author
        info_text = "Version: 0.0.31\nAuthor: Damned Angel + Gemini AI"
        info_label = ttk.Label(text_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(anchor="w")

        # OK Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2 if icon_label else 1, pady=(15, 0))

        ok_button = ttk.Button(button_frame, text="OK", command=about_win.destroy, width=10)
        ok_button.pack()

        about_win.update_idletasks() 
        main_width = self.root.winfo_width()
        main_height = self.root.winfo_height()
        main_x = self.root.winfo_x()
        main_y = self.root.winfo_y()

        pop_width = about_win.winfo_width()
        pop_height = about_win.winfo_height()

        pop_x = main_x + (main_width // 2) - (pop_width // 2)
        pop_y = main_y + (main_height // 2) - (pop_height // 2)

        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        pop_x = max(0, min(pop_x, screen_width - pop_width))
        pop_y = max(0, min(pop_y, screen_height - pop_height))

        about_win.geometry(f"+{pop_x}+{pop_y}")
        ok_button.focus_set()
        about_win.wait_window()

    def _find_unused_tiles(self):
        """Identifies tiles not used in any supertile definition."""
        global tileset_patterns, supertiles_data, num_tiles_in_set, num_supertiles
        used_tile_indices = set()
        # Tile 0 is implicitly used/reserved, don't mark it as unused
        for st_idx in range(num_supertiles):
            for r in range(SUPERTILE_GRID_DIM):
                for c in range(SUPERTILE_GRID_DIM):
                    used_tile_indices.add(supertiles_data[st_idx][r][c])
        
        unused_tiles = set()
        for i in range(1, num_tiles_in_set): # Start from 1, tile 0 is never "unused"
            if i not in used_tile_indices:
                unused_tiles.add(i)
        return unused_tiles

    def _find_unused_supertiles(self):
        """Identifies supertiles not used in the map_data."""
        global map_data, map_width, map_height, num_supertiles
        used_st_indices = set()
        # Supertile 0 is implicitly used/reserved
        for r_idx in range(map_height): # Renamed r
            for c_idx in range(map_width): # Renamed c
                used_st_indices.add(map_data[r_idx][c_idx])
        # # print(f"DEBUG: Used Supertile Indices from map_data: {used_st_indices}") # DEBUG

        unused_supertiles = set()
        for i in range(1, num_supertiles): # Start from 1
            if i not in used_st_indices:
                unused_supertiles.add(i)
        # print(f"DEBUG: Found Unused Supertiles (indices): {unused_supertiles}") # DEBUG
        return unused_supertiles

    def _clear_marked_unused(self, trigger_redraw=True):
        """Clears all 'marked unused' states and optionally redraws relevant viewers."""
        tile_marks_cleared = bool(self.marked_unused_tiles)
        st_marks_cleared = bool(self.marked_unused_supertiles)

        self.marked_unused_tiles.clear()
        self.marked_unused_supertiles.clear()

        if trigger_redraw and (tile_marks_cleared or st_marks_cleared):
            # Redraw only if marks were actually cleared to avoid unnecessary redraws
            # Determine active tab to redraw correctly
            current_tab_index = -1
            try:
                if self.notebook and self.notebook.winfo_exists():
                    selected_tab_name = self.notebook.select()
                    if selected_tab_name:
                        current_tab_index = self.notebook.index(selected_tab_name)
            except tk.TclError:
                pass

            if current_tab_index == 1: # Tile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
            elif current_tab_index == 2: # Supertile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                if st_marks_cleared:
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
            elif current_tab_index == 3: # Map Editor
                if st_marks_cleared: # Map editor only shows supertiles
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        return tile_marks_cleared or st_marks_cleared


    def _adjust_marked_indices_after_delete(self, marked_set, deleted_index):
        """Adjusts indices in a 'marked_set' after an item at 'deleted_index' is removed."""
        if deleted_index in marked_set:
            marked_set.remove(deleted_index)
        
        new_marked_set = set()
        for idx in marked_set:
            if idx > deleted_index:
                new_marked_set.add(idx - 1)
            else:
                new_marked_set.add(idx)
        marked_set.clear()
        marked_set.update(new_marked_set)


    def handle_mark_unused_tiles(self):
        """Handles the 'Mark Unused' button click in the Tile Editor tab."""
        if self.marked_unused_tiles: # If already marked, clear them
            self._clear_marked_unused(trigger_redraw=False) 
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index) 
        else:
            # Clear any supertile marks from other tab before marking tiles
            # This ensures only tile marks are active if this button is pressed
            if self.marked_unused_supertiles:
                self.marked_unused_supertiles.clear()
                 # Redraw ST selectors if they were marked to remove blue borders
                if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

            self.marked_unused_tiles = self._find_unused_tiles()
            if not self.marked_unused_tiles:
                messagebox.showinfo("Mark Unused Tiles", "No unused tiles found.")
            else:
                print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)

    def handle_mark_unused_supertiles_and_tiles(self):
        """Handles the 'Mark Unused' button in the Supertile Editor tab."""
        # If either set has marks, clear both
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self._clear_marked_unused(trigger_redraw=False) 
            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        else: # Neither set has marks, so we are in "mark" mode
            self.marked_unused_tiles = self._find_unused_tiles()
            self.marked_unused_supertiles = self._find_unused_supertiles() 
            
            if not self.marked_unused_tiles and not self.marked_unused_supertiles:
                messagebox.showinfo("Mark Unused", "No unused tiles or supertiles found.")
            else:
                # Only print the sets if they contain items
                if self.marked_unused_tiles: 
                    print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list for consistency
                if self.marked_unused_supertiles: 
                    print(f"Marked unused supertiles: {sorted(list(self.marked_unused_supertiles))}") # Print sorted list

            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)

    # --- ROM Importer Methods (NEW SECTION) ---

    def open_rom_importer(self):
        """Handles the 'Import Tiles from ROM...' menu command."""
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        rom_filepath = filedialog.askopenfilename(
            title="Select ROM File",
            filetypes=[("All files", "*.*"), ("Binary files", "*.bin"), ("ROM files", "*.rom")]
        )
        if not rom_filepath:
            return # User cancelled

        try:
            with open(rom_filepath, "rb") as f:
                rom_data = f.read()
            if not rom_data:
                messagebox.showerror("ROM Import Error", "Selected file is empty.")
                return
        except Exception as e:
            messagebox.showerror("ROM Import Error", f"Could not read ROM file:\n{e}")
            return

        # If successful, create and show the dialog
        self._create_rom_importer_dialog(rom_filepath, rom_data)

    def _create_rom_importer_dialog(self, rom_filepath, rom_data):
        """Creates and displays the modal dialog for ROM tile importing."""
        self.rom_import_dialog = tk.Toplevel(self.root)
        self.rom_import_dialog.title(f"Import Tiles from: {os.path.basename(rom_filepath)}")
        self.rom_import_dialog.transient(self.root)
        self.rom_import_dialog.grab_set()
        self.rom_import_dialog.resizable(True, True)
        self.rom_import_dialog.minsize(400, 300)

        dialog = self.rom_import_dialog
        dialog.rom_data = rom_data
        dialog.rom_filepath = rom_filepath
        dialog.fine_offset_var = tk.IntVar(value=0)
        dialog.selected_start_rom_tile_idx = -1
        dialog.selected_end_rom_tile_idx = -1
        dialog.hover_info_text_var = tk.StringVar(value="Offset: N/A | Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")
        dialog.top_left_grid_byte_offset_text_var = tk.StringVar(value="Grid Top-Left Byte: N/A")
        dialog.redraw_timer_id = None # Initialize redraw_timer_id for debouncing Configure

        main_dialog_frame = ttk.Frame(dialog, padding=5)
        main_dialog_frame.pack(expand=True, fill="both")

        top_controls_frame = ttk.Frame(main_dialog_frame)
        top_controls_frame.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))

        ttk.Label(top_controls_frame, text="Fine Offset (0-7 bytes):").pack(side=tk.LEFT, padx=(0,5))
        offset_slider = ttk.Scale(
            top_controls_frame,
            from_=0,
            to=7,
            orient=tk.HORIZONTAL,
            variable=dialog.fine_offset_var,
            command=lambda val: self._on_rom_importer_setting_change()
        )
        offset_slider.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)

        middle_frame = ttk.Frame(main_dialog_frame)
        middle_frame.pack(expand=True, fill="both")

        canvas_frame = ttk.Frame(middle_frame)
        canvas_frame.pack(side=tk.LEFT, expand=True, fill="both")

        rom_v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        rom_h_scroll = ttk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL)

        dialog.canvas = tk.Canvas(
            canvas_frame,
            bg="darkgrey",
            yscrollcommand=rom_v_scroll.set,
            xscrollcommand=rom_h_scroll.set,
            highlightthickness=0
        )
        rom_v_scroll.config(command=dialog.canvas.yview)
        rom_h_scroll.config(command=dialog.canvas.xview)

        # Add scrollbar bindings to trigger redraw
        rom_v_scroll.bind("<B1-Motion>",
            lambda event: self.rom_import_dialog.after_idle(self._draw_rom_importer_canvas)
                          if self.rom_import_dialog and tk.Toplevel.winfo_exists(self.rom_import_dialog) and
                             hasattr(self.rom_import_dialog, 'canvas') and self.rom_import_dialog.canvas.winfo_exists()
                          else None)
        rom_v_scroll.bind("<ButtonRelease-1>",
            lambda event: self.rom_import_dialog.after_idle(self._draw_rom_importer_canvas)
                          if self.rom_import_dialog and tk.Toplevel.winfo_exists(self.rom_import_dialog) and
                             hasattr(self.rom_import_dialog, 'canvas') and self.rom_import_dialog.canvas.winfo_exists()
                          else None)
        rom_h_scroll.bind("<B1-Motion>",
            lambda event: self.rom_import_dialog.after_idle(self._draw_rom_importer_canvas)
                          if self.rom_import_dialog and tk.Toplevel.winfo_exists(self.rom_import_dialog) and
                             hasattr(self.rom_import_dialog, 'canvas') and self.rom_import_dialog.canvas.winfo_exists()
                          else None)
        rom_h_scroll.bind("<ButtonRelease-1>",
            lambda event: self.rom_import_dialog.after_idle(self._draw_rom_importer_canvas)
                          if self.rom_import_dialog and tk.Toplevel.winfo_exists(self.rom_import_dialog) and
                             hasattr(self.rom_import_dialog, 'canvas') and self.rom_import_dialog.canvas.winfo_exists()
                          else None)

        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        rom_v_scroll.grid(row=0, column=1, sticky="ns")
        rom_h_scroll.grid(row=1, column=0, sticky="ew")
        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)

        preview_outer_frame = ttk.Frame(middle_frame, padding=(5,0))
        preview_outer_frame.pack(side=tk.RIGHT, fill=tk.Y, anchor="ne")
        preview_label_frame = ttk.LabelFrame(preview_outer_frame, text="Live Preview")
        preview_label_frame.pack(pady=0, anchor="n")
        preview_canvas_size = TILE_WIDTH * EDITOR_PIXEL_SIZE
        dialog.preview_canvas = tk.Canvas(
            preview_label_frame,
            width=preview_canvas_size,
            height=preview_canvas_size,
            bg="grey",
            highlightthickness=0
        )
        dialog.preview_canvas.pack(padx=5, pady=5)

        bottom_frame = ttk.Frame(main_dialog_frame)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(5,0))

        info_bar_frame = ttk.Frame(bottom_frame, relief="sunken", padding=3)
        info_bar_frame.pack(fill=tk.X, expand=False, side=tk.TOP, pady=(0,5))
        dialog.status_bar_top_left_label = ttk.Label(info_bar_frame, textvariable=dialog.top_left_grid_byte_offset_text_var)
        dialog.status_bar_top_left_label.pack(side=tk.LEFT, padx=2)
        ttk.Label(info_bar_frame, text="|").pack(side=tk.LEFT, padx=2)
        hover_label = ttk.Label(info_bar_frame, textvariable=dialog.hover_info_text_var)
        hover_label.pack(side=tk.LEFT, padx=2)
        ttk.Label(info_bar_frame, text="|").pack(side=tk.LEFT, padx=2)
        selection_label = ttk.Label(info_bar_frame, textvariable=dialog.selection_info_text_var)
        selection_label.pack(side=tk.LEFT, padx=2)

        buttons_frame = ttk.Frame(bottom_frame)
        buttons_frame.pack(fill=tk.X, expand=False, side=tk.TOP)
        dialog.import_button = ttk.Button(
            buttons_frame, text="Import", command=self._execute_rom_tile_import, state=tk.DISABLED
        )
        cancel_button = ttk.Button(
            buttons_frame, text="Cancel", command=self._close_rom_importer_dialog
        )
        cancel_button.pack(side=tk.RIGHT, padx=(0,0))
        dialog.import_button.pack(side=tk.RIGHT, padx=(0,5))

        dialog.canvas.bind("<Configure>", lambda e: self._on_rom_importer_setting_change(configure_event=True))
        dialog.canvas.bind("<Motion>", self._on_rom_canvas_motion)
        dialog.canvas.bind("<Leave>", self._on_rom_canvas_leave)
        dialog.canvas.bind("<Button-1>", self._on_rom_canvas_left_click)
        dialog.canvas.bind("<Button-3>", self._on_rom_canvas_right_click)
        dialog.bind("<Escape>", lambda e: self._clear_rom_import_selection())
        dialog.canvas.bind("<FocusIn>", lambda e: None)
        dialog.canvas.bind("<Key>", self._on_rom_canvas_keypress)
        dialog.canvas.focus_set()
        dialog.protocol("WM_DELETE_WINDOW", self._close_rom_importer_dialog)
        dialog.after(20, lambda: self._on_rom_importer_setting_change(configure_event=True)) # Ensure initial draw after geometry

        dialog.update_idletasks()
        root_w = self.root.winfo_width()
        root_h = self.root.winfo_height()
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        x_pos = root_x + (root_w // 2) - (dialog_w // 2)
        y_pos = root_y + (root_h // 2) - (dialog_h // 2)
        dialog.geometry(f"{dialog_w}x{dialog_h}+{x_pos}+{y_pos}")

    def _close_rom_importer_dialog(self):
        """Closes and cleans up the ROM importer dialog."""
        if self.rom_import_dialog:
            self.rom_import_dialog.grab_release() # Release grab before destroying
            self.rom_import_dialog.destroy()
            self.rom_import_dialog = None # Clear reference

    def _on_rom_importer_setting_change(self, event=None, configure_event=False):
        """Called when fine_offset slider changes or canvas is configured/resized."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        if configure_event:
            # Ensure redraw_timer_id attribute exists on the dialog
            if not hasattr(dialog, 'redraw_timer_id'):
                dialog.redraw_timer_id = None # Initialize if it was missed

            if dialog.redraw_timer_id is not None:
                dialog.after_cancel(dialog.redraw_timer_id)
            # Schedule the debounced draw call
            dialog.redraw_timer_id = dialog.after(150, self._perform_debounced_rom_canvas_draw)
            return # Debouncing will handle the draw
        else:
            # For non-configure events (like slider change), draw more directly
            # The _draw_rom_importer_canvas itself has a check for tiny canvas
            # but calling the debounced version here too for consistency might be safer,
            # or call _draw_rom_importer_canvas if immediate feedback is desired for slider.
            # Let's call _draw_rom_importer_canvas for immediate slider feedback.
            self._draw_rom_importer_canvas()

    def _draw_rom_importer_canvas(self):
        """Draws the content of the ROM importer canvas (tile grid)."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        self.debug("\n[DEBUG] --- ROM Importer Canvas Redraw START ---")

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[DEBUG] ROM Importer canvas widget no longer exists. Aborting draw.")
            self.debug("[DEBUG] --- ROM Importer Canvas Redraw END (canvas gone) ---")
            return

        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        canvas.delete("all")
        dialog.tile_image_refs = []

        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()

        self.debug(f"[DEBUG] Canvas Dimensions (WxH): {canvas_width}x{canvas_height}")
        self.debug(f"[DEBUG] ROM Data Size: {len(rom_data)} bytes")
        self.debug(f"[DEBUG] Fine Offset: {fine_offset} bytes")

        if canvas_width <= 1 or canvas_height <= 1:
            self.debug("[DEBUG] Canvas not yet sized (or too small). Aborting draw.")
            self.debug("[DEBUG] --- ROM Importer Canvas Redraw END (aborted small canvas) ---")
            return

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        tiles_across = max(1, canvas_width // (tile_display_size + padding))
        
        if len(rom_data) <= fine_offset:
            total_potential_tiles = 0
        else:
            total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        
        self.debug(f"[DEBUG] Tile Display Size: {tile_display_size}, Padding: {padding}")
        self.debug(f"[DEBUG] Tiles Across (calculated): {tiles_across}")
        self.debug(f"[DEBUG] Total Potential Tiles (from ROM data): {total_potential_tiles}")
        
        if total_potential_tiles <= 0:
             try:
                 if canvas.winfo_exists():
                     canvas.config(scrollregion=(0,0,1,1))
             except tk.TclError:
                 self.debug("[DEBUG] TclError configuring scrollregion for no potential tiles (canvas likely destroying).")
             self._update_rom_importer_info_labels()
             self.debug("[DEBUG] No potential tiles. Scrollregion set to minimal. Aborting further draw.")
             self.debug("[DEBUG] --- ROM Importer Canvas Redraw END (no tiles) ---")
             return

        num_rows_in_rom_data = math.ceil(total_potential_tiles / tiles_across)
        
        scroll_region_width = tiles_across * (tile_display_size + padding) + padding
        scroll_region_height = num_rows_in_rom_data * (tile_display_size + padding) + padding
        scroll_region_width = max(1, scroll_region_width)
        scroll_region_height = max(1, scroll_region_height)

        self.debug(f"[DEBUG] Num Rows in ROM Data (calculated for grid): {num_rows_in_rom_data}")
        self.debug(f"[DEBUG] Scroll Region (WxH): {scroll_region_width}x{scroll_region_height}")
        
        try:
            if canvas.winfo_exists():
                canvas.config(scrollregion=(0, 0, scroll_region_width, scroll_region_height))
        except tk.TclError:
            self.debug("[DEBUG] TclError configuring scrollregion (canvas likely destroying).")
            self.debug("[DEBUG] --- ROM Importer Canvas Redraw END (TclError on scrollregion) ---")
            return

        view_y1 = canvas.canvasy(0)
        view_y2 = canvas.canvasy(canvas_height)

        start_row_idx = max(0, int(view_y1 // (tile_display_size + padding)))
        end_row_idx = min(num_rows_in_rom_data, int(math.ceil(view_y2 / (tile_display_size + padding))))
        if (view_y2 > view_y1) and (view_y2 % (tile_display_size + padding) == 0):
             end_row_idx = min(num_rows_in_rom_data, end_row_idx + 1)
        end_row_idx = max(start_row_idx, end_row_idx)

        self.debug(f"[DEBUG] Canvas Y-View (scroll_coord_start, scroll_coord_end): {view_y1}, {view_y2}")
        self.debug(f"[DEBUG] Visible Grid Rows (start_idx for loop, end_idx for loop): {start_row_idx}, {end_row_idx}")

        if not hasattr(dialog, 'top_left_grid_byte_offset'):
            dialog.top_left_grid_byte_offset = 0 

        first_visible_rom_tile_idx = start_row_idx * tiles_across
        dialog.top_left_grid_byte_offset = fine_offset + (first_visible_rom_tile_idx * TILE_WIDTH)
        if hasattr(dialog, 'top_left_grid_byte_offset_text_var'):
            try:
                dialog.top_left_grid_byte_offset_text_var.set(f"Grid Top-Left Byte: {dialog.top_left_grid_byte_offset} (0x{dialog.top_left_grid_byte_offset:X})")
            except tk.TclError:
                pass

        drawn_tile_count_this_pass = 0
        for r_grid in range(start_row_idx, end_row_idx):
            for c_grid in range(tiles_across):
                current_rom_tile_absolute_idx = r_grid * tiles_across + c_grid
                
                if current_rom_tile_absolute_idx >= total_potential_tiles:
                    continue

                rom_byte_start_pos = fine_offset + (current_rom_tile_absolute_idx * TILE_WIDTH)
                
                if rom_byte_start_pos + TILE_WIDTH > len(rom_data):
                    num_bytes_avail = len(rom_data) - rom_byte_start_pos
                    tile_bytes_data = rom_data[rom_byte_start_pos:] + bytes(TILE_WIDTH - num_bytes_avail)
                else:
                    tile_bytes_data = rom_data[rom_byte_start_pos : rom_byte_start_pos + TILE_WIDTH]

                img = tk.PhotoImage(width=tile_display_size, height=tile_display_size)
                dialog.tile_image_refs.append(img)

                for y_pixel_in_tile in range(TILE_HEIGHT):
                    row_byte = tile_bytes_data[y_pixel_in_tile]
                    line_data_hex = []
                    for x_pixel_in_tile in range(TILE_WIDTH):
                        pixel_is_set = (row_byte >> (7 - x_pixel_in_tile)) & 1
                        color_hex = self.active_msx_palette[WHITE_IDX] if pixel_is_set else self.active_msx_palette[BLACK_IDX]
                        line_data_hex.append(color_hex)
                    
                    y_img_start = y_pixel_in_tile * (tile_display_size // TILE_HEIGHT)
                    y_img_end = (y_pixel_in_tile + 1) * (tile_display_size // TILE_HEIGHT)

                    for y_img in range(y_img_start, y_img_end):
                        scaled_line_data_hex = []
                        for hex_val in line_data_hex:
                            scaled_line_data_hex.extend([hex_val] * (tile_display_size // TILE_WIDTH))
                        try:
                            # Removed: if img.winfo_exists():
                            img.put("{" + " ".join(scaled_line_data_hex) + "}", to=(0, y_img))
                        except tk.TclError:
                            try:
                                # Removed: if img.winfo_exists() and scaled_line_data_hex:
                                if scaled_line_data_hex: # Check if list is not empty
                                    img.put(scaled_line_data_hex[0], to=(0, y_img, tile_display_size, y_img + 1))
                            except tk.TclError:
                                pass


                canvas_x_pos = c_grid * (tile_display_size + padding) + padding
                canvas_y_pos = r_grid * (tile_display_size + padding) + padding
                try:
                    if canvas.winfo_exists():
                        canvas.create_image(canvas_x_pos, canvas_y_pos, image=img, anchor=tk.NW, tags=f"rom_tile_{current_rom_tile_absolute_idx}")
                    drawn_tile_count_this_pass +=1
                except tk.TclError:
                    self.debug(f"[DEBUG] TclError creating image for tile {current_rom_tile_absolute_idx} (canvas likely destroying).")
                    break 
            else: 
                continue
            break 
        
        self.debug(f"[DEBUG] Drawn {drawn_tile_count_this_pass} tiles in this pass.")
        self._draw_rom_import_selection_highlight()
        self._update_rom_importer_info_labels()
        self.debug("[DEBUG] --- ROM Importer Canvas Redraw END ---")

    def _draw_rom_import_selection_highlight(self):
        """Draws yellow border around selected tiles in ROM importer."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        dialog = self.rom_import_dialog
        canvas = dialog.canvas
        canvas.delete("rom_selection_border") # Clear previous borders

        start_idx = dialog.selected_start_rom_tile_idx
        end_idx = dialog.selected_end_rom_tile_idx

        if start_idx == -1 : # No selection, or only start is set but end is not yet confirmed
            return
        
        # Determine the actual range to highlight (start_idx could be > end_idx before swap)
        # If end_idx is -1, it means only start_idx is set (single tile selection so far)
        current_selection_min_idx = min(start_idx, end_idx) if end_idx != -1 else start_idx
        current_selection_max_idx = max(start_idx, end_idx) if end_idx != -1 else start_idx

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = canvas.winfo_width()
        if canvas_width_current <= 1 : return # Canvas not ready
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        # Iterate through all tiles in the defined selection range
        for idx_in_selection_range in range(current_selection_min_idx, current_selection_max_idx + 1):
            # Convert this absolute rom_tile_idx to its row/col in the conceptual full grid
            grid_r, grid_c = divmod(idx_in_selection_range, tiles_across)

            # Calculate pixel coordinates for this tile's border
            # These are relative to the scrollable region's 0,0
            border_x1 = grid_c * (tile_display_size + padding) + padding -1 # -1 for border outside
            border_y1 = grid_r * (tile_display_size + padding) + padding -1
            border_x2 = border_x1 + tile_display_size + 2 # +2 for border thickness
            border_y2 = border_y1 + tile_display_size + 2
            
            # Check if this tile is (at least partially) visible on the canvas
            # This simple check is okay as create_rectangle handles off-canvas coords gracefully.
            # More precise check would involve canvas.canvasx/y for visible region.
            view_x1 = canvas.canvasx(0)
            view_y1 = canvas.canvasy(0)
            view_x2 = canvas.canvasx(canvas.winfo_width())
            view_y2 = canvas.canvasy(canvas.winfo_height())

            # Only draw if the tile's bounding box overlaps the current view
            if border_x2 > view_x1 and border_x1 < view_x2 and \
               border_y2 > view_y1 and border_y1 < view_y2:
                canvas.create_rectangle(border_x1, border_y1, border_x2, border_y2,
                                        outline="yellow", width=2, tags="rom_selection_border")

    def _on_rom_canvas_motion(self, event):
        """Handles mouse motion over the ROM importer canvas for hover info and preview."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = dialog.canvas
        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = canvas.winfo_width()
        if canvas_width_current <= 1: return # Canvas not ready
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        # Get canvas coordinates relative to scrollable content
        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)

        # Determine which tile in the conceptual full grid is under cursor
        grid_col_under_cursor = int(cx // (tile_display_size + padding))
        grid_row_under_cursor = int(cy // (tile_display_size + padding))
        
        hovered_rom_tile_absolute_idx = grid_row_under_cursor * tiles_across + grid_col_under_cursor
        
        total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        if total_potential_tiles <= 0: hovered_rom_tile_absolute_idx = -1 # No valid tiles

        if 0 <= hovered_rom_tile_absolute_idx < total_potential_tiles:
            # Calculate the byte position in the ROM for this hovered tile
            hovered_byte_start_pos = fine_offset + (hovered_rom_tile_absolute_idx * TILE_WIDTH)
            
            dialog.hover_info_text_var.set(
                f"Offset: {hovered_byte_start_pos} (0x{hovered_byte_start_pos:X}) | Grid Index: {hovered_rom_tile_absolute_idx}"
            )
            self._draw_rom_tile_preview(hovered_byte_start_pos) # Update live preview
        else:
            dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
            dialog.preview_canvas.delete("all") # Clear preview if not over a valid tile

    def _on_rom_canvas_leave(self, event):
        """Clears hover info and preview when mouse leaves ROM importer canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        self.rom_import_dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
        if hasattr(self.rom_import_dialog, 'preview_canvas'): # Check if preview_canvas exists
             self.rom_import_dialog.preview_canvas.delete("all")

    def _on_rom_canvas_left_click(self, event):
        """Handles left-click on ROM importer canvas for selecting tiles."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        canvas = dialog.canvas
        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = canvas.winfo_width()
        if canvas_width_current <=1: return # Canvas not ready
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        
        clicked_grid_col = int(cx // (tile_display_size + padding))
        clicked_grid_row = int(cy // (tile_display_size + padding))
        clicked_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col

        total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        if not (0 <= clicked_rom_tile_absolute_idx < total_potential_tiles):
            # Click was outside the area of actual tile data
            return

        if dialog.selected_start_rom_tile_idx == -1:
            # This is the first click, setting the start of the selection
            dialog.selected_start_rom_tile_idx = clicked_rom_tile_absolute_idx
            dialog.selected_end_rom_tile_idx = clicked_rom_tile_absolute_idx # Also end for single select
            dialog.import_button.config(state=tk.NORMAL) # Enable import
        else:
            # This is the second click, setting or updating the end of the selection
            dialog.selected_end_rom_tile_idx = clicked_rom_tile_absolute_idx
            # Auto-swap if end is before start
            if dialog.selected_end_rom_tile_idx < dialog.selected_start_rom_tile_idx:
                dialog.selected_start_rom_tile_idx, dialog.selected_end_rom_tile_idx = \
                    dialog.selected_end_rom_tile_idx, dialog.selected_start_rom_tile_idx
            # Import button is already enabled from the first click
        
        self._draw_rom_import_selection_highlight()
        self._update_rom_importer_info_labels() # Update "Tiles Selected" count

    def _on_rom_canvas_right_click(self, event):
        """Handles right-click on ROM importer canvas to cancel selection."""
        self._clear_rom_import_selection()

    def _clear_rom_import_selection(self):
        """Clears the current tile selection in the ROM importer dialog."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        dialog = self.rom_import_dialog
        dialog.selected_start_rom_tile_idx = -1
        dialog.selected_end_rom_tile_idx = -1
        dialog.import_button.config(state=tk.DISABLED) # Disable import button
        self._draw_rom_import_selection_highlight() # Remove highlight
        self._update_rom_importer_info_labels() # Update "Tiles Selected" to 0

    def _update_rom_importer_info_labels(self):
        """Updates dynamic labels in the ROM importer (selected count, top-left byte)."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        start = dialog.selected_start_rom_tile_idx
        end = dialog.selected_end_rom_tile_idx
        count = 0
        if start != -1: # A selection exists
            min_idx = min(start, end) if end != -1 else start
            max_idx = max(start, end) if end != -1 else start
            count = (max_idx - min_idx) + 1
        dialog.selection_info_text_var.set(f"Tiles Selected: {count}")

        # The top_left_grid_byte_offset_text_var is updated in _draw_rom_importer_canvas
        # as it depends on the current scroll position and fine_offset.

    def _draw_rom_tile_preview(self, rom_byte_start_pos):
        """Draws a single tile from ROM data into the preview canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not hasattr(self.rom_import_dialog, 'preview_canvas'): # Check preview_canvas exists
            return

        preview_canvas = self.rom_import_dialog.preview_canvas
        rom_data = self.rom_import_dialog.rom_data
        preview_canvas.delete("all")

        if rom_byte_start_pos < 0 or rom_byte_start_pos >= len(rom_data):
            return # Invalid offset

        # Extract 8 bytes for the tile, padding if near end of ROM
        if rom_byte_start_pos + TILE_WIDTH > len(rom_data):
            num_bytes_avail = len(rom_data) - rom_byte_start_pos
            tile_bytes_data = rom_data[rom_byte_start_pos:] + bytes(TILE_WIDTH - num_bytes_avail)
        else:
            tile_bytes_data = rom_data[rom_byte_start_pos : rom_byte_start_pos + TILE_WIDTH]

        pixel_render_size = EDITOR_PIXEL_SIZE # Use main editor's pixel size for preview
        for r_tile_pixel in range(TILE_HEIGHT): # 0-7
            row_byte = tile_bytes_data[r_tile_pixel]
            for c_tile_pixel in range(TILE_WIDTH): # 0-7
                pixel_is_set = (row_byte >> (7 - c_tile_pixel)) & 1
                color_hex = self.active_msx_palette[WHITE_IDX] if pixel_is_set else self.active_msx_palette[BLACK_IDX]
                
                x1 = c_tile_pixel * pixel_render_size
                y1 = r_tile_pixel * pixel_render_size
                x2 = x1 + pixel_render_size
                y2 = y1 + pixel_render_size
                preview_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey") # Use grey outline

    def _on_rom_canvas_keypress(self, event):
        """Handles keyboard navigation for the ROM importer canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        # Safely get canvas from dialog, it might not exist if dialog is closing
        canvas = getattr(self.rom_import_dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return
        
        key_pressed = event.keysym
        # Print yview *before* the action for comparison
        try:
            current_yview_before_action = canvas.yview()
            self.debug(f"[DEBUG] Keypress: {key_pressed}, Current yview (before action): {current_yview_before_action}")
        except tk.TclError: # Canvas might be gone
            self.debug(f"[DEBUG] Keypress: {key_pressed}, Error getting yview (canvas likely gone).")
            return


        action_taken = False
        if key_pressed == "Up":
            canvas.yview_scroll(-1, "units")
            action_taken = True
        elif key_pressed == "Down":
            canvas.yview_scroll(1, "units")
            action_taken = True
        elif key_pressed == "Left":
            canvas.xview_scroll(-1, "units")
            action_taken = True # Redraw might be needed if x-scroll changes which tiles are 'first' in a row
        elif key_pressed == "Right":
            canvas.xview_scroll(1, "units")
            action_taken = True
        elif key_pressed == "Prior": # PageUp
            canvas.yview_scroll(-1, "pages")
            action_taken = True
        elif key_pressed == "Next": # PageDown
            canvas.yview_scroll(1, "pages")
            action_taken = True
        elif key_pressed == "Home":
            canvas.yview_moveto(0.0)
            action_taken = True
        elif key_pressed == "End":
            canvas.yview_moveto(1.0)
            action_taken = True
        else:
            return # Not a handled key

        if action_taken:
            # Define a local function to be called by 'after'
            # This captures the current 'key_pressed' for the debug message
            def check_and_redraw_after_scroll(key_for_debug=key_pressed):
                # Check dialog and canvas existence again, as 'after' calls are delayed
                if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
                    self.debug(f"[DEBUG] After '{key_for_debug}': ROM importer dialog no longer exists. Skipping check/redraw.")
                    return
                
                current_canvas_after = getattr(self.rom_import_dialog, 'canvas', None)
                if not current_canvas_after or not current_canvas_after.winfo_exists():
                    self.debug(f"[DEBUG] After '{key_for_debug}': ROM importer canvas no longer exists. Skipping check/redraw.")
                    return
                
                try:
                    yview_after = current_canvas_after.yview()
                    canvasy_0_after = current_canvas_after.canvasy(0)
                    canvasy_H_after = current_canvas_after.canvasy(current_canvas_after.winfo_height())
                    self.debug(f"[DEBUG] After '{key_for_debug}': yview()={yview_after}, canvasy(0)={canvasy_0_after}, canvasy(H)={canvasy_H_after}")
                except tk.TclError:
                    self.debug(f"[DEBUG] After '{key_for_debug}': TclError getting scroll state (canvas likely destroying).")
                    return # Don't proceed to redraw if canvas state is bad

                # Schedule the actual draw using after_idle
                # This ensures it runs after Tk's event loop is idle from other processing
                self.rom_import_dialog.after_idle(self._draw_rom_importer_canvas)

            # Schedule the check_and_redraw_after_scroll function
            canvas.after_idle(check_and_redraw_after_scroll) # Use after_idle for safety

        return "break" # Consume the event

    def _execute_rom_tile_import(self):
        """Reads selected tile data from ROM and appends to the main tileset."""
        global num_tiles_in_set, current_tile_index, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        start_rom_idx_in_grid = dialog.selected_start_rom_tile_idx
        end_rom_idx_in_grid = dialog.selected_end_rom_tile_idx
        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        if start_rom_idx_in_grid == -1: # No selection made
            messagebox.showwarning("Import Error", "No tiles selected from ROM.", parent=dialog)
            return

        # Determine the actual range of tiles to import from the grid selection
        # If end_rom_idx_in_grid is -1, it means only start_rom_idx_in_grid was selected (single tile)
        actual_start_idx = min(start_rom_idx_in_grid, end_rom_idx_in_grid) if end_rom_idx_in_grid != -1 else start_rom_idx_in_grid
        actual_end_idx = max(start_rom_idx_in_grid, end_rom_idx_in_grid) if end_rom_idx_in_grid != -1 else start_rom_idx_in_grid
        
        num_tiles_to_import_attempt = (actual_end_idx - actual_start_idx) + 1
        imported_tiles_count = 0
        
        # It's good practice to clear "marked unused" state if the tileset is about to change
        # This is less critical for append, but good if this function were ever used for "replace"
        # For now, let's assume appending doesn't invalidate existing marks unless an imported
        # tile happens to be identical to a previously marked one.
        # self._clear_marked_unused(trigger_redraw=False) # Optional, consider implications

        for i in range(num_tiles_to_import_attempt):
            if num_tiles_in_set >= MAX_TILES:
                messagebox.showinfo(
                    "Import Limit Reached",
                    f"Tileset limit of {MAX_TILES} reached.\nImported {imported_tiles_count} of {num_tiles_to_import_attempt} selected tiles.",
                    parent=dialog
                )
                break # Stop importing further tiles

            # current_rom_tile_absolute_idx is the index within the conceptual full grid from ROM
            current_rom_tile_absolute_idx = actual_start_idx + i
            
            # Calculate the starting byte position in the original ROM data for this tile
            rom_byte_start_pos = fine_offset + (current_rom_tile_absolute_idx * TILE_WIDTH)

            if rom_byte_start_pos >= len(rom_data): # Should not happen if selection was valid
                print(f"Warning: ROM Import attempting to read past end of data. ROM Tile Idx: {current_rom_tile_absolute_idx}, Byte Pos: {rom_byte_start_pos}")
                break 

            # Prepare pattern and color data for the new tile
            new_tile_pattern_data = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
            new_tile_color_data = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)] # Default B/W

            # Extract 8 bytes for the tile, padding if near end of ROM
            if rom_byte_start_pos + TILE_WIDTH > len(rom_data):
                num_bytes_avail = len(rom_data) - rom_byte_start_pos
                tile_bytes_from_rom = rom_data[rom_byte_start_pos:] + bytes(TILE_WIDTH - num_bytes_avail)
            else:
                tile_bytes_from_rom = rom_data[rom_byte_start_pos : rom_byte_start_pos + TILE_WIDTH]

            # Populate pattern from the bytes
            for r_pixel in range(TILE_HEIGHT):
                row_byte_value = tile_bytes_from_rom[r_pixel]
                for c_pixel in range(TILE_WIDTH):
                    new_tile_pattern_data[r_pixel][c_pixel] = (row_byte_value >> (7 - c_pixel)) & 1
            
            # Assign to the next available slot in the main application's tileset
            # (tileset_patterns and tileset_colors are pre-initialized to MAX_TILES length)
            if num_tiles_in_set < MAX_TILES: # Double check, though outer loop also checks
                tileset_patterns[num_tiles_in_set] = new_tile_pattern_data
                tileset_colors[num_tiles_in_set] = new_tile_color_data
                
                num_tiles_in_set += 1
                imported_tiles_count += 1
                self._mark_project_modified() # Mark project as modified
            else: # Should have been caught by outer loop's break
                print("Error: MAX_TILES reached unexpectedly inside import loop.")
                break


        if imported_tiles_count > 0:
            current_tile_index = num_tiles_in_set - 1 # Select the last imported tile
            
            self.clear_all_caches() # Imported tiles mean existing caches are invalid
            self.invalidate_minimap_background_cache() # If supertiles/map get auto-updated
            
            self.update_all_displays(changed_level="all") # Refresh all UI
            self.scroll_viewers_to_tile(current_tile_index) # Scroll to new tile
            self._update_editor_button_states() # Enable/disable add/insert/delete
            self._update_edit_menu_state() # Update copy/paste availability
            
            messagebox.showinfo("Import Successful", f"Successfully imported {imported_tiles_count} tile(s).", parent=dialog)

        self._close_rom_importer_dialog() # Close the importer dialog

    def _get_zoomed_supertile_pixel_dims(self):
        """
        Calculates the pixel width and height of one supertile on the map canvas
        at the current zoom level, based on the project's supertile dimensions.
        Returns a tuple (width_pixels, height_pixels).
        """
        zoomed_tile_size = self.get_zoomed_tile_size() # This is pixels per TILE_WIDTH/TILE_HEIGHT (8x8) unit

        if zoomed_tile_size <= 0: # Defensive check
            return 0, 0

        zoomed_supertile_pixel_width = self.supertile_grid_width * zoomed_tile_size
        zoomed_supertile_pixel_height = self.supertile_grid_height * zoomed_tile_size
        
        # Ensure minimum 1 pixel if dimensions are very small but > 0
        zoomed_supertile_pixel_width = max(1, zoomed_supertile_pixel_width)
        zoomed_supertile_pixel_height = max(1, zoomed_supertile_pixel_height)

        return zoomed_supertile_pixel_width, zoomed_supertile_pixel_height

    def _update_supertile_rotate_button_state(self):
        """
        Updates the state of the supertile rotate button based on whether
        the current supertile dimensions are square.
        """
        if hasattr(self, 'st_rotate_button') and self.st_rotate_button.winfo_exists():
            try:
                if self.supertile_grid_width == self.supertile_grid_height:
                    self.st_rotate_button.config(state=tk.NORMAL)
                else:
                    self.st_rotate_button.config(state=tk.DISABLED)
            except tk.TclError:
                # Widget might be in the process of being destroyed, or not fully ready
                pass
        # else: button doesn't exist yet, will be configured when created

    def _reconfigure_supertile_definition_canvas(self):
        """
        Reconfigures the size of the supertile definition canvas based on the
        current self.supertile_grid_width and self.supertile_grid_height.
        Then redraws its content.
        """
        if hasattr(self, 'supertile_def_canvas') and self.supertile_def_canvas.winfo_exists():
            try:
                # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32)
                new_canvas_w = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
                new_canvas_h = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
                
                # Ensure minimum practical size for the canvas
                new_canvas_w = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_w) # Min width of one mini-tile
                new_canvas_h = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_h) # Min height of one mini-tile

                self.supertile_def_canvas.config(width=new_canvas_w, height=new_canvas_h)
                
                # The scrollregion for this canvas might not be strictly necessary if it's always
                # sized to fit its content perfectly and doesn't scroll.
                # If it were to scroll (e.g., fixed size canvas viewing larger def),
                # then scrollregion would need update: self.supertile_def_canvas.config(scrollregion=(0,0,new_canvas_w, new_canvas_h))

                self.draw_supertile_definition_canvas() # Redraw content after resize
            except tk.TclError:
                # print("TclError during supertile definition canvas reconfiguration.")
                pass
            except Exception as e:
                # print(f"Error reconfiguring supertile definition canvas: {e}")
                pass
        # else: canvas not yet created or already destroyed.


    def create_map_render_of_supertile(self, supertile_index, target_render_width, target_render_height):
        # Ensure target dimensions are at least 1x1
        safe_target_render_width = max(1, int(target_render_width))
        safe_target_render_height = max(1, int(target_render_height))

        cache_key = (supertile_index, safe_target_render_width, safe_target_render_height, self.supertile_grid_width, self.supertile_grid_height)
        if cache_key in self.map_render_cache:
            return self.map_render_cache[cache_key]

        img = tk.PhotoImage(width=safe_target_render_width, height=safe_target_render_height)

        if not (0 <= supertile_index < num_supertiles):
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_render_width, safe_target_render_height))
            self.map_render_cache[cache_key] = img
            return img

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width  # Number of base tiles across in the supertile definition
        src_st_tile_grid_h = self.supertile_grid_height # Number of base tiles down in the supertile definition

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0: # Should ideally be caught by project settings validation
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_render_width, safe_target_render_height))
            self.map_render_cache[cache_key] = img
            return img
        
        # Check definition structure consistency against project settings
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            # This supertile's internal structure doesn't match current project dimensions.
            # This can happen if project ST dimensions change after STs were defined.
            # print(f"Warning: Supertile {supertile_index} internal dim mismatch for create_map_render. Expected {src_st_tile_grid_w}x{src_st_tile_grid_h}")
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_render_width, safe_target_render_height)) # Mark as invalid
            self.map_render_cache[cache_key] = img
            return img

        # Pixel dimensions of one original base tile (e.g., 8x8 TILE_WIDTH/HEIGHT)
        # when rendered within the target_render_width/height.
        # This is how many output pixels one base tile will occupy on average.
        output_pixels_per_base_tile_w = safe_target_render_width / src_st_tile_grid_w
        output_pixels_per_base_tile_h = safe_target_render_height / src_st_tile_grid_h

        # Heuristic check: if a base tile column or row would be rendered to less than 1 pixel,
        # it's likely too small to render meaningfully detail by detail.
        if safe_target_render_width < src_st_tile_grid_w or safe_target_render_height < src_st_tile_grid_h :
             # Render the supertile as a solid block of its "average" or most dominant color, or just an invalid color.
             # For simplicity, using invalid color. A more advanced version could average.
             # print(f"Warning: Supertile {supertile_index} render target ({safe_target_render_width}x{safe_target_render_height}) too small for its grid ({src_st_tile_grid_w}x{src_st_tile_grid_h}). Filling with placeholder.")
             img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_render_width, safe_target_render_height))
             self.map_render_cache[cache_key] = img
             return img

        # Ratio of source base tile pixels (e.g., TILE_WIDTH=8) to its display size within the scaled render.
        # This tells us how many source pixels are covered by one *output* pixel in that scaled base tile's area.
        src_pixels_per_output_pixel_w_ratio = TILE_WIDTH / output_pixels_per_base_tile_w if output_pixels_per_base_tile_w > 1e-9 else float('inf')
        src_pixels_per_output_pixel_h_ratio = TILE_HEIGHT / output_pixels_per_base_tile_h if output_pixels_per_base_tile_h > 1e-9 else float('inf')

        for y_out in range(safe_target_render_height): # Iterate over each pixel of the output PhotoImage
            row_colors_hex = []
            for x_out in range(safe_target_render_width):
                # Determine which source base tile (in the supertile grid) this output pixel (x_out, y_out) falls into.
                # Ensure result is int and clamped to valid range.
                src_base_tile_c_in_st_grid = min(src_st_tile_grid_w - 1, int(x_out / output_pixels_per_base_tile_w))
                src_base_tile_r_in_st_grid = min(src_st_tile_grid_h - 1, int(y_out / output_pixels_per_base_tile_h))
                
                # Determine the coordinate of (x_out, y_out) *within* the area of that specific scaled base tile.
                # E.g., if a base tile scales to 4x4 output pixels, this would be (0..3.999, 0..3.999)
                x_in_scaled_base_tile_area = (x_out / output_pixels_per_base_tile_w - src_base_tile_c_in_st_grid) * output_pixels_per_base_tile_w
                y_in_scaled_base_tile_area = (y_out / output_pixels_per_base_tile_h - src_base_tile_r_in_st_grid) * output_pixels_per_base_tile_h
                
                # Map this coordinate back to the original source base tile's pixel coordinates (e.g., 0-7 for an 8x8 tile).
                src_pixel_c_in_base_tile = min(TILE_WIDTH - 1, int(x_in_scaled_base_tile_area * src_pixels_per_output_pixel_w_ratio))
                src_pixel_r_in_base_tile = min(TILE_HEIGHT - 1, int(y_in_scaled_base_tile_area * src_pixels_per_output_pixel_h_ratio))

                pixel_color_hex_final = INVALID_TILE_COLOR # Default on error

                try:
                    # These indices into `definition` should be safe due to earlier clamping
                    tile_idx_from_st_def = definition[src_base_tile_r_in_st_grid][src_base_tile_c_in_st_grid]

                    if 0 <= tile_idx_from_st_def < num_tiles_in_set:
                        # Bounds check for pattern/color array access
                        if not (0 <= src_pixel_r_in_base_tile < TILE_HEIGHT and \
                                len(tileset_patterns[tile_idx_from_st_def]) > src_pixel_r_in_base_tile and \
                                0 <= src_pixel_c_in_base_tile < TILE_WIDTH and \
                                len(tileset_patterns[tile_idx_from_st_def][src_pixel_r_in_base_tile]) > src_pixel_c_in_base_tile and \
                                len(tileset_colors[tile_idx_from_st_def]) > src_pixel_r_in_base_tile):
                            pixel_color_hex_final = INVALID_TILE_COLOR # Malformed tile data
                        else:
                            pattern_pixel_val = tileset_patterns[tile_idx_from_st_def][src_pixel_r_in_base_tile][src_pixel_c_in_base_tile]
                            fg_idx_val, bg_idx_val = tileset_colors[tile_idx_from_st_def][src_pixel_r_in_base_tile]
                            
                            if not (0 <= fg_idx_val < len(self.active_msx_palette) and 0 <= bg_idx_val < len(self.active_msx_palette)):
                                fg_color = INVALID_TILE_COLOR; bg_color = INVALID_TILE_COLOR
                            else:
                                fg_color = self.active_msx_palette[fg_idx_val]
                                bg_color = self.active_msx_palette[bg_idx_val]
                            
                            pixel_color_hex_final = fg_color if pattern_pixel_val == 1 else bg_color
                    # else: tile_idx_from_st_def is out of bounds, pixel_color_hex_final remains INVALID_TILE_COLOR
                except IndexError:
                    pixel_color_hex_final = INVALID_TILE_COLOR # Fallback for any unexpected index issue
                
                row_colors_hex.append(pixel_color_hex_final)
            
            try:
                if safe_target_render_width > 0:
                    img.put("{" + " ".join(row_colors_hex) + "}", to=(0, y_out))
            except tk.TclError as e:
                if row_colors_hex and safe_target_render_width > 0:
                    img.put(row_colors_hex[0], to=(0, y_out, safe_target_render_width, y_out + 1))

        self.map_render_cache[cache_key] = img
        return img

    def _handle_map_scroll_event(self, event=None):
        # This method is called by scrollbar interactions.
        # It needs to redraw the main map canvas content and the minimap.
        # A small delay can sometimes help smooth out rapid scrollbar dragging,
        # but let's try direct calls first. If it's choppy, we can add debouncing.
        if self.map_canvas and self.map_canvas.winfo_exists():
            self.draw_map_canvas() # Redraw main map content
            self.draw_minimap()    # Update minimap

    def _perform_debounced_rom_canvas_draw(self):
        """Called by the after timer to actually redraw the ROM canvas after debouncing Configure."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        if hasattr(dialog, 'redraw_timer_id'): # Check if attribute exists
            dialog.redraw_timer_id = None

        # Ensure canvas exists and is of a minimum size before attempting to draw
        canvas = getattr(dialog, 'canvas', None) # Safely get canvas
        if not canvas or not canvas.winfo_exists():
            return
            
        if canvas.winfo_width() < VIEWER_TILE_SIZE or \
           canvas.winfo_height() < VIEWER_TILE_SIZE:
            # If still too small, reschedule. Clear previous timer if it somehow exists.
            if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
                 dialog.after_cancel(dialog.redraw_timer_id)
            dialog.redraw_timer_id = dialog.after(50, self._perform_debounced_rom_canvas_draw)
            return

        self._draw_rom_importer_canvas()

# --- Main Execution ---
if __name__ == "__main__":
    import argparse # Import the argparse module

    # --- Argument Parsing ---
    parser = argparse.ArgumentParser(description="MSX Tile Forge - Tile and Map Editor.")
    parser.add_argument(
        "--debug",
        action="store_true", # Sets args.debug to True if --debug is present
        help="Enable detailed debug console output."
    )
    args = parser.parse_args()
    # --- End Argument Parsing ---

    root = tk.Tk()
    root.withdraw()

    # --- Make debug state globally accessible or pass to app ---
    # Option 1: Store on root and have app access it (simple)
    root.app_debug_mode = args.debug
    if root.app_debug_mode:
        print("[INFO] Debug mode enabled via --debug flag.")

    # Option 2: Pass directly to TileEditorApp constructor (if you modify it)
    # For now, Option 1 is easier to integrate without changing constructor.

    # ... (rest of your icon setup, splash screen, etc.) ...

    # --- Splash Screen Setup ---
    splash_win = tk.Toplevel(root)
    splash_win.overrideredirect(True)
    splash_win.config(cursor="watch")

    try:
        image_data = base64.b64decode(SPLASH_IMAGE)
        splash_photo = tk.PhotoImage(data=image_data)
        splash_label = tk.Label(splash_win, image=splash_photo, borderwidth=0)
        splash_label.pack()
        img_width = splash_photo.width()
        img_height = splash_photo.height()
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        x_pos = (screen_width // 2) - (img_width // 2)
        y_pos = (screen_height // 2) - (img_height // 2)
        splash_win.geometry(f'{img_width}x{img_height}+{x_pos}+{y_pos}')

        def show_main_window():
            splash_win.destroy()
            root.deiconify()
            # If you choose Option 2 for debug_mode, pass it here:
            # app = TileEditorApp(root, debug_mode=args.debug)
            app = TileEditorApp(root) # Using Option 1 for now
            if hasattr(app, 'debug') and callable(app.debug): # Check if debug method exists
                 app.debug("[DEBUG] Main application initialized.")


        root.after(3000, show_main_window)
        splash_label.image = splash_photo

    except Exception as e:
        print(f"Error displaying splash screen: {e}")
        root.deiconify()
        # app = TileEditorApp(root, debug_mode=args.debug) # If passing
        app = TileEditorApp(root) # Using Option 1

    root.mainloop()
