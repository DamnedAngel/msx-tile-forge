#!/bin/env -S python3
# -*- coding: utf-8 -*-
import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser
from tkinter import filedialog
from tkinter import messagebox
from tkinter import simpledialog
from contextlib import suppress
import struct
import os
import math
import copy
import base64
import io
from PIL import Image, ImageTk

# --- Constants ---
APP_VERSION = "0.0.40"

TILE_WIDTH = 8
TILE_HEIGHT = 8
EDITOR_PIXEL_SIZE = 30
VIEWER_TILE_SIZE = TILE_WIDTH * 2  # 16
PALETTE_SQUARE_SIZE = 20
NUM_TILES_ACROSS = 16
MAX_TILES = 256
SUPERTILE_GRID_DIM = 4 # This might become dynamic or project-specific later
SUPERTILE_DEF_TILE_SIZE = TILE_WIDTH * 4  # 32
SUPERTILE_SELECTOR_PREVIEW_SIZE = TILE_WIDTH * 4 # Used for an old ST selector calculation, review if still needed for that
NUM_SUPERTILES_ACROSS = 8 # Used for an old ST selector calculation, review if still needed for that
MAX_SUPERTILES = 65535 # MODIFIED - Increased from 256
DEFAULT_MAP_WIDTH = 32  # In supertiles
DEFAULT_MAP_HEIGHT = 24  # In supertiles
DEFAULT_WIN_VIEW_WIDTH_TILES = 32  # Default screen size
DEFAULT_WIN_VIEW_HEIGHT_TILES = 24  # Default screen size
MAX_WIN_VIEW_HEIGHT_TILES = 27  # Allow up to 27 for half-tile logic

MINIMAP_INITIAL_WIDTH = 256  # Default desired width of minimap window in pixels
MINIMAP_INITIAL_HEIGHT = 212  # Default desired height of minimap window in pixels

DRAG_THRESHOLD_PIXELS = 3 # Minimum pixels mouse must move to initiate a drag

RESERVED_BYTES_COUNT = 4 # NEW constant for clarity

# --- Palette Editor Constants ---
MSX2_PICKER_COLS = 32
MSX2_PICKER_ROWS = 16
MSX2_PICKER_SQUARE_SIZE = 15
CURRENT_PALETTE_SLOT_SIZE = 30

# --- MSX2 Default Palette (Indices & Colors) ---
MSX2_RGB7_VALUES = [
    (0, 0, 0),
    (0, 0, 0),
    (1, 6, 1),
    (3, 7, 3),
    (1, 1, 7),
    (2, 3, 7),
    (5, 1, 1),
    (2, 6, 7),
    (7, 1, 1),
    (7, 3, 3),
    (6, 6, 1),
    (6, 6, 4),
    (1, 4, 1),
    (6, 2, 5),
    (5, 5, 5),
    (7, 7, 7),
]
BLACK_IDX = 1
MED_GREEN_IDX = 2
WHITE_IDX = 15

# --- Placeholder Colors ---
INVALID_TILE_COLOR = "#FF00FF"
INVALID_SUPERTILE_COLOR = "#00FFFF"

# --- Grid & Overlay Constants ---
GRID_COLOR_CYCLE = [
    "#FFFFFF",
    "#000000",
    "#FF00FF",
    "#00FFFF",
    "#FFFF00",
]  # White, Black, Magenta, Cyan, Yellow
GRID_DASH_PATTERN = (5, 3)  # 5 pixels on, 3 pixels off
WIN_VIEW_HANDLE_SIZE = 8  # Pixel size of resize handles
WIN_VIEW_HALF_ROW_COLOR = "#80808080"  # Semi-transparent grey for overscan area (adjust alpha if needed, format depends on tk version)

ICON_IMAGE = r"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"
SPLASH_IMAGE = r"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"

# ICON_IMAGE = r"iVBORw0"
# SPLASH_IMAGE = r"iVBORw0"

# --- MSX2 Color Generation ---
msx2_512_colors_hex = []
msx2_512_colors_rgb7 = []
for r in range(8):
    for g in range(8):
        for b in range(8):
            r_255 = min(255, r * 36)
            g_255 = min(255, g * 36)
            b_255 = min(255, b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            msx2_512_colors_hex.append(hex_color)
            msx2_512_colors_rgb7.append((r, g, b))

# --- Data Structures ---
tileset_patterns = [
    [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
tileset_colors = [
    [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
]
current_tile_index = 0
num_tiles_in_set = 1
selected_color_index = WHITE_IDX
last_drawn_pixel = None
supertiles_data = [
    [[0 for _ in range(SUPERTILE_GRID_DIM)] for _ in range(SUPERTILE_GRID_DIM)]
    for _ in range(MAX_SUPERTILES)
]
current_supertile_index = 0
num_supertiles = 1
selected_tile_for_supertile = 0
map_width = DEFAULT_MAP_WIDTH  # In supertiles
map_height = DEFAULT_MAP_HEIGHT  # In supertiles
map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
selected_supertile_for_map = 0
last_painted_map_cell = None
tile_clipboard_pattern = None
tile_clipboard_colors = None
supertile_clipboard_data = None

# --- Utility Functions ---
def get_contrast_color(hex_color):
    try:
        hex_color = hex_color.lstrip("#")
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
        return "#000000" if luminance > 0.5 else "#FFFFFF"
    except:
        return "#000000"

# --- Usage Window Classes -----------------------------------------------------------------------------------------------
# --- Usage Window Classes ---
class ColorUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Color Usage")
        self.transient(master_app.root)
        self.resizable(False, True) 

        self._image_references = [] 
        
        # --- Sorting State ---
        self.current_sort_column_id = "slot_index" # Default sort: by slot index
        self.current_sort_direction_is_asc = True   # Default: ascending

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(1, weight=1) 
        main_frame.grid_columnconfigure(0, weight=1)

        header_frame = ttk.Frame(main_frame)
        header_frame.grid(row=0, column=0, sticky="ew", columnspan=2) 
        
        col_width_swatch = 40 
        col_width_index = 50  
        col_width_counts = 80 

        header_frame.grid_columnconfigure(0, weight=0, minsize=col_width_swatch) 
        header_frame.grid_columnconfigure(1, weight=0, minsize=col_width_index)  
        header_frame.grid_columnconfigure(2, weight=0, minsize=col_width_counts)  
        header_frame.grid_columnconfigure(3, weight=0, minsize=col_width_counts)  
        header_frame.grid_columnconfigure(4, weight=0, minsize=col_width_counts) 

        # --- Clickable Static Labels for Sorting ---
        # Store labels to update their text with sort indicators later if desired
        self.header_labels = {}

        lbl_color = ttk.Label(header_frame, text="Color", anchor="center", cursor="hand2")
        lbl_color.grid(row=0, column=0, sticky="ew")
        # No sorting by color swatch itself usually

        lbl_index = ttk.Label(header_frame, text="Index ?", anchor="w", cursor="hand2") # Default sort indicator
        lbl_index.grid(row=0, column=1, sticky="ew", padx=(5,0))
        lbl_index.bind("<Button-1>", lambda e, col_id="slot_index": self._sort_by_column(col_id))
        self.header_labels["slot_index"] = lbl_index
        
        lbl_pixel_uses = ttk.Label(header_frame, text="Pixel Uses", anchor="e", cursor="hand2")
        lbl_pixel_uses.grid(row=0, column=2, sticky="ew")
        lbl_pixel_uses.bind("<Button-1>", lambda e, col_id="pixel_uses_count": self._sort_by_column(col_id))
        self.header_labels["pixel_uses_count"] = lbl_pixel_uses

        lbl_line_refs = ttk.Label(header_frame, text="Line Refs", anchor="e", cursor="hand2")
        lbl_line_refs.grid(row=0, column=3, sticky="ew")
        lbl_line_refs.bind("<Button-1>", lambda e, col_id="line_refs_count": self._sort_by_column(col_id))
        self.header_labels["line_refs_count"] = lbl_line_refs

        lbl_tile_refs = ttk.Label(header_frame, text="Tile Refs", anchor="e", cursor="hand2")
        lbl_tile_refs.grid(row=0, column=4, sticky="ew")
        lbl_tile_refs.bind("<Button-1>", lambda e, col_id="tile_refs_count": self._sort_by_column(col_id))
        self.header_labels["tile_refs_count"] = lbl_tile_refs
        # --- End Clickable Static Labels ---

        self.data_column_ids_for_values = ("slot_index_val", "pixel_uses_val", "line_refs_val", "tile_refs_val") 
        self.tree = ttk.Treeview(main_frame, columns=self.data_column_ids_for_values, show="tree", height=16) 
        
        self.tree.column("#0", width=col_width_swatch, minwidth=col_width_swatch, stretch=tk.NO, anchor="center") 
        self.tree.column("slot_index_val", width=col_width_index, minwidth=col_width_index, stretch=tk.NO, anchor="w")
        self.tree.column("pixel_uses_val", width=col_width_counts, minwidth=col_width_counts, stretch=tk.NO, anchor="e")
        self.tree.column("line_refs_val", width=col_width_counts, minwidth=col_width_counts, stretch=tk.NO, anchor="e")
        self.tree.column("tile_refs_val", width=col_width_counts, minwidth=col_width_counts, stretch=tk.NO, anchor="e")

        tree_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=tree_scrollbar.set)

        self.tree.grid(row=1, column=0, sticky="nsew") 
        tree_scrollbar.grid(row=1, column=1, sticky="ns")
        main_frame.grid_columnconfigure(1, weight=0)

        button_frame_container = ttk.Frame(main_frame) 
        button_frame_container.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(5,0))
        
        self.refresh_button = ttk.Button(button_frame_container, text="Refresh", command=self.refresh_data)
        self.refresh_button.pack(pady=5)

        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.after(10, self.refresh_data)

    def _sort_by_column(self, column_id_clicked):
        # Handles click on a header label to change sort order.
        self.app_ref.debug(f"[DEBUG] ColorUsageWindow: Sorting by column '{column_id_clicked}'")
        if self.current_sort_column_id == column_id_clicked:
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else:
            self.current_sort_column_id = column_id_clicked
            self.current_sort_direction_is_asc = True # Default to ascending on new column

        # Update header label texts to show sort indicators (optional visual polish)
        for col_id, label_widget in self.header_labels.items():
            text = label_widget.cget("text").replace(" ?", "").replace(" ?", "") # Remove old indicator
            if col_id == self.current_sort_column_id:
                text += " ?" if self.current_sort_direction_is_asc else " ?"
            try:
                if label_widget.winfo_exists():
                    label_widget.config(text=text)
            except tk.TclError: pass

        self.refresh_data() # Re-fetch, re-sort, and re-populate the tree

    # refresh_data and _on_close remain the same as Step 1P
    # The sorting logic will be added to refresh_data in the next step.
    # For now, refresh_data just needs to be aware that it *will* use these sorting state vars.

    def refresh_data(self): 
        self.app_ref.debug(f"[DEBUG] ColorUsageWindow: refresh_data() called. Sort by: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            self.app_ref.debug("[DEBUG] Treeview not ready for refresh_data.")
            return

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear()

        usage_data = [] 
        if hasattr(self.app_ref, '_calculate_color_usage_data'):
            try:
                usage_data = self.app_ref._calculate_color_usage_data() # This returns a list of dicts
            except Exception as e:
                self.app_ref.debug(f"[DEBUG] Error calling _calculate_color_usage_data: {e}")
                # Populate with dummy data for UI testing if calculation fails
                for i in range(16): 
                     usage_data.append({
                        'slot_index': i,
                        'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF",
                        'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0
                    })
        else: 
            self.app_ref.debug("[DEBUG] ColorUsageWindow: _calculate_color_usage_data not found for refresh.")
            for i in range(16): # Dummy data
                usage_data.append({
                    'slot_index': i,
                    'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF",
                    'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0
                })
        
        # --- Apply Sorting ---
        # The column_id_clicked corresponds to keys in our item_data dictionaries
        if self.current_sort_column_id in usage_data[0]: # Check if sort key is valid
            try:
                usage_data.sort(key=lambda item: item[self.current_sort_column_id], 
                                reverse=not self.current_sort_direction_is_asc)
            except TypeError as e_sort: # e.g. if trying to sort by a non-sortable key like the hex string directly without conversion
                self.app_ref.debug(f"[DEBUG] TypeError during sorting by '{self.current_sort_column_id}': {e_sort}. Defaulting to slot_index sort.")
                usage_data.sort(key=lambda item: item['slot_index'], reverse=False) # Fallback sort
            except KeyError as e_key: # Should not happen if column_id is from our dict keys
                self.app_ref.debug(f"[DEBUG] KeyError during sorting by '{self.current_sort_column_id}': {e_key}. Defaulting to slot_index sort.")
                usage_data.sort(key=lambda item: item['slot_index'], reverse=False) # Fallback sort

        else: # Fallback if sort column ID is somehow invalid
            self.app_ref.debug(f"[DEBUG] Invalid sort column '{self.current_sort_column_id}'. Defaulting to slot_index sort.")
            usage_data.sort(key=lambda item: item['slot_index'], reverse=False)
        # --- End Apply Sorting ---

        preview_image_size = 16
        for item_data in usage_data: # Iterate through the (now sorted) data
            slot_idx = item_data['slot_index']
            hex_color = item_data['current_color_hex']
            
            img_w = max(1, preview_image_size)
            img_h = max(1, preview_image_size)
            photo = None
            try:
                photo = tk.PhotoImage(width=img_w, height=img_h)
                hex_color_to_put = hex_color
                if not (isinstance(hex_color, str) and hex_color.startswith('#') and len(hex_color) == 7):
                    hex_color_to_put = "#FF00FF"
                photo.put(hex_color_to_put, to=(0, 0, img_w, img_h))
                self._image_references.append(photo) 
            except tk.TclError as e_photo:
                self.app_ref.debug(f"[DEBUG] TclError creating/putting color swatch for slot {slot_idx} color '{hex_color}': {e_photo}")

            self.tree.insert("", "end",
                             iid=f"slot_{slot_idx}", 
                             text="",  
                             image=photo if photo else '', 
                             values=( 
                                 str(slot_idx),                 
                                 item_data['pixel_uses_count'],
                                 item_data['line_refs_count'],
                                 item_data['tile_refs_count']
                             ))

    def _on_close(self): 
        self.app_ref.debug("[DEBUG] ColorUsageWindow closed.")
        if self.app_ref: 
            self.app_ref.color_usage_window = None 
        self.destroy()

# --- Application Class  -----------------------------------------------------------------------------------------------
class TileEditorApp:
    def __init__(self, root):
        self.debug_enabled = getattr(root, 'app_debug_mode', False)
        
        self.root = root
        self.root.protocol("WM_DELETE_WINDOW", self.confirm_quit)
        
        self.root.title("MSX Tile Forge - Untitled") 
        with suppress(tk.TclError):
            self.root.state("zoomed")

        self.root.bind("<Configure>", self._on_main_window_configure)
        self._main_window_configure_timer = None 
        self._map_canvas_configure_timer = None 
        self._palette_pane_resize_timer = None 


        self.current_project_base_path = None
        self.project_modified = False

        self.supertile_grid_width = SUPERTILE_GRID_DIM 
        self.supertile_grid_height = SUPERTILE_GRID_DIM 

        self.active_msx_palette = []
        for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
            self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
        self.selected_palette_slot = 0

        self.tile_image_cache = {}      
        self.supertile_image_cache = {} 
        self.map_render_cache = {}      

        self.pil_map_viewport_image = None 
        self.tk_map_photoimage = None      

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        self.drag_indicator_id = None

        self.map_zoom_level = 1.0
        self.show_supertile_grid = tk.BooleanVar(value=False)
        self.show_window_view = tk.BooleanVar(value=False)
        self.grid_color_index = 1 
        self.window_view_tile_x = 0
        self.window_view_tile_y = 0
        self.window_view_tile_w = tk.IntVar(value=DEFAULT_WIN_VIEW_WIDTH_TILES)
        self.window_view_tile_h = tk.IntVar(value=DEFAULT_WIN_VIEW_HEIGHT_TILES)
        self.window_view_resize_handle = None
        self.drag_start_x = 0
        self.drag_start_y = 0
        self.drag_start_win_tx = 0
        self.drag_start_win_ty = 0
        self.drag_start_win_tw = 0
        self.drag_start_win_th = 0

        self.minimap_window = None
        self.minimap_canvas = None
        self.MINIMAP_VIEWPORT_COLOR = "#FF0000"
        self.MINIMAP_WIN_VIEW_COLOR = "#0000FF"
        self.minimap_background_cache = None
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0
        self.minimap_resize_timer = None
        self._minimap_resizing_internally = False

        self.is_ctrl_pressed = False
        self.current_mouse_action = None
        self.pan_start_x = 0
        self.pan_start_y = 0
        self.last_placed_supertile_cell = None
        self.is_shift_pressed = False

        self.map_selection_active = False
        self.map_selection_rect_id = None
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_clipboard_data = None
        self.map_paste_preview_rect_id = None

        self.edit_menu = None
        self.copy_menu_item_index = -1
        self.paste_menu_item_index = -1

        self.marked_unused_tiles = set()
        self.marked_unused_supertiles = set()

        self.rom_import_dialog = None
        self.map_controls_min_width = 0 
        
        self.scroll_speed_units = 3 
        
        self.color_usage_window = None # Added reference for Color Usage window


        self.debug("[DEBUG] TileEditorApp __init__ started.")

        self.create_menu()
        self._setup_global_key_bindings()
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")

        self.tab_palette_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_tile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_supertile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_map_editor = ttk.Frame(self.notebook, padding="10")

        self.notebook.add(self.tab_palette_editor, text="Palette Editor")
        self.notebook.add(self.tab_tile_editor, text="Tile Editor")
        self.notebook.add(self.tab_supertile_editor, text="Supertile Editor")
        self.notebook.add(self.tab_map_editor, text="Map Editor")

        self.create_palette_editor_widgets(self.tab_palette_editor)
        self.create_tile_editor_widgets(self.tab_tile_editor)
        self.create_supertile_editor_widgets(self.tab_supertile_editor)
        self.create_map_editor_widgets(self.tab_map_editor) 
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)
        self._setup_map_canvas_bindings() 

        self._update_window_title() 
        self.update_all_displays(changed_level="all") 
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        self._update_map_cursor()
        
        self.debug("[DEBUG] TileEditorApp __init__ finished.")

    def debug(self, message):
        """Prints the message to the console only if debug mode is enabled."""
        if self.debug_enabled:
            print(str(message)) # Ensure message is a string

    # --- Palette Conversion Helpers ---
    def _hex_to_rgb7(self, hex_color):
        try:
            if not isinstance(hex_color, str):
                raise TypeError("Input must be a string.")
            if not hex_color.startswith("#") or len(hex_color) != 7:
                raise ValueError(f"Input '{hex_color}' is not a valid #RRGGBB format.")
            lookup_hex = hex_color.lower()
            idx512 = msx2_512_colors_hex.index(lookup_hex)
            return msx2_512_colors_rgb7[idx512]
        except ValueError:
            print(
                f"Warning: Could not find exact MSX2 RGB7 mapping for hex '{hex_color}'. Returning (0,0,0)."
            )
            return (0, 0, 0)
        except TypeError as e:
            print(f"Error in _hex_to_rgb7: Input type error for '{hex_color}'. {e}")
            return (0, 0, 0)
        except Exception as e:
            print(f"Unexpected error in _hex_to_rgb7 for '{hex_color}': {e}")
            return (0, 0, 0)

    def _rgb7_to_hex(self, r, g, b):
        try:
            safe_r = max(0, min(7, int(r)))
            safe_g = max(0, min(7, int(g)))
            safe_b = max(0, min(7, int(b)))
            r_255 = min(255, safe_r * 36)
            g_255 = min(255, safe_g * 36)
            b_255 = min(255, safe_b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            return hex_color
        except (ValueError, TypeError) as e:
            print(f"Error in _rgb7_to_hex converting input ({r},{g},{b}): {e}")
            return "#000000"
        except Exception as e:
            print(f"Unexpected error in _rgb7_to_hex for ({r},{g},{b}): {e}")
            return "#000000"

    # --- Cache Management ---
    def invalidate_tile_cache(self, tile_index):
        keys_to_remove = [k for k in self.tile_image_cache if k[0] == tile_index]
        for key in keys_to_remove:
            self.tile_image_cache.pop(key, None)
        for st_index in range(num_supertiles):
            definition = supertiles_data[st_index]
            used = False
            # Check if definition is valid for current dimensions before iterating
            if len(definition) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) :
                for r_st_def in range(self.supertile_grid_height):
                    # Ensure row exists (it should if height check passed)
                    if r_st_def < len(definition):
                        for c_st_def in range(self.supertile_grid_width):
                             # Ensure column exists within row
                            if c_st_def < len(definition[r_st_def]):
                                if definition[r_st_def][c_st_def] == tile_index:
                                    used = True
                                    break
                            else: # Should not happen if width check above is good
                                self.debug(f"[DEBUG]Warning: Invalidate tile cache, ST {st_index} row {r_st_def} too short for width {self.supertile_grid_width}")
                                break
                    else: # Should not happen if height check passed
                        self.debug(f"[DEBUG]Warning: Invalidate tile cache, ST {st_index} definition too short for height {self.supertile_grid_height}")
                        break
                    if used:
                        break
            else:
                # This case indicates an inconsistency between self.supertile_grid_width/height
                # and the actual structure of supertiles_data[st_index].
                # This might happen if dimensions change but data isn't properly migrated/reinitialized.
                # For now, we'll skip invalidating supertile cache if the structure is unexpected,
                # or one could choose to invalidate all supertile caches as a precaution.
                self.debug(f"[DEBUG]Warning: Supertile {st_index} definition dimensions mismatch project settings during tile cache invalidation. Skipping ST cache invalidation for this ST.")
                pass # Or: self.invalidate_supertile_cache(st_index) if aggressive


            if used:
                self.invalidate_supertile_cache(st_index)

    def invalidate_supertile_cache(self, supertile_index):
        keys_to_remove_st_img = [
            k for k in self.supertile_image_cache if k[0] == supertile_index
        ]
        for key_st_img in keys_to_remove_st_img:
            self.supertile_image_cache.pop(key_st_img, None)

        # Also invalidate corresponding entries in map_render_cache
        keys_to_remove_map_render = [
            k for k in self.map_render_cache if k[0] == supertile_index
        ]
        for key_map_render in keys_to_remove_map_render:
            self.map_render_cache.pop(key_map_render, None)

    def clear_all_caches(self):
        self.tile_image_cache.clear()
        self.supertile_image_cache.clear()
        self.map_render_cache.clear() # Added to clear the new map render cache

    # --- Image Generation ---
    def create_tile_image(self, tile_index, size):
        cache_key = (tile_index, size)
        if cache_key in self.tile_image_cache:
            return self.tile_image_cache[cache_key]
        render_size = max(1, int(size))
        img = tk.PhotoImage(width=render_size, height=render_size)
        if not (0 <= tile_index < num_tiles_in_set):
            img.put(INVALID_TILE_COLOR, to=(0, 0, render_size, render_size))
            self.tile_image_cache[cache_key] = img
            return img
        pattern = tileset_patterns[tile_index]
        colors = tileset_colors[tile_index]
        pixel_w_ratio = TILE_WIDTH / render_size
        pixel_h_ratio = TILE_HEIGHT / render_size
        for y in range(render_size):
            tile_r = min(TILE_HEIGHT - 1, int(y * pixel_h_ratio))
            try:
                fg_idx, bg_idx = colors[tile_r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            row_colors_hex = []
            for x in range(render_size):
                tile_c = min(TILE_WIDTH - 1, int(x * pixel_w_ratio))
                try:
                    pixel_val = pattern[tile_r][tile_c]
                except IndexError:
                    pixel_val = 0
                color_hex = fg_color if pixel_val == 1 else bg_color
                row_colors_hex.append(color_hex)
            try:
                img.put("{" + " ".join(row_colors_hex) + "}", to=(0, y))
            except tk.TclError as e:
                print(
                    f"Warning [create_tile_image]: TclError tile {tile_index} size {size} row {y}: {e}"
                )
                if row_colors_hex:
                    img.put(row_colors_hex[0], to=(0, y, render_size, y + 1))
        self.tile_image_cache[cache_key] = img
        return img

    def create_supertile_image(self, supertile_index, target_preview_width, target_preview_height): # Renamed parameters
        # Ensure target dimensions are at least 1x1
        safe_target_preview_width = max(1, int(target_preview_width))
        safe_target_preview_height = max(1, int(target_preview_height))

        # Cache key now includes actual target dimensions and source supertile grid dimensions
        cache_key = (supertile_index, safe_target_preview_width, safe_target_preview_height, self.supertile_grid_width, self.supertile_grid_height)
        if cache_key in self.supertile_image_cache: # Use supertile_image_cache
            return self.supertile_image_cache[cache_key]

        img = tk.PhotoImage(width=safe_target_preview_width, height=safe_target_preview_height)

        if not (0 <= supertile_index < num_supertiles):
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            self.debug(f"[DEBUG]Warning: Supertile {supertile_index} internal dim mismatch for create_supertile_image. Expected {src_st_tile_grid_w}x{src_st_tile_grid_h}")
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        # --- Letterboxing/Pillarboxing logic REMOVED ---
        # The image is created with exact target dimensions, and we render directly into it.

        # Pixels of one original base tile (e.g., 8x8) when rendered within the target_preview_width/height
        output_pixels_per_base_tile_w = safe_target_preview_width / src_st_tile_grid_w
        output_pixels_per_base_tile_h = safe_target_preview_height / src_st_tile_grid_h
        
        # Heuristic: if rendering a source tile column/row to less than 1 pixel on average.
        if safe_target_preview_width < src_st_tile_grid_w or safe_target_preview_height < src_st_tile_grid_h:
             img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
             self.supertile_image_cache[cache_key] = img
             return img

        # Ratio of source base tile pixels (e.g., TILE_WIDTH) to its display size in the preview.
        src_pixels_per_output_pixel_w_ratio = TILE_WIDTH / output_pixels_per_base_tile_w if output_pixels_per_base_tile_w > 1e-9 else float('inf')
        src_pixels_per_output_pixel_h_ratio = TILE_HEIGHT / output_pixels_per_base_tile_h if output_pixels_per_base_tile_h > 1e-9 else float('inf')

        for y_out_preview in range(safe_target_preview_height):
            row_colors_hex_preview = []
            for x_out_preview in range(safe_target_preview_width):
                src_base_tile_c_in_st_grid_preview = min(src_st_tile_grid_w - 1, int(x_out_preview / output_pixels_per_base_tile_w))
                src_base_tile_r_in_st_grid_preview = min(src_st_tile_grid_h - 1, int(y_out_preview / output_pixels_per_base_tile_h))

                x_in_scaled_base_tile_area_preview = (x_out_preview / output_pixels_per_base_tile_w - src_base_tile_c_in_st_grid_preview) * output_pixels_per_base_tile_w
                y_in_scaled_base_tile_area_preview = (y_out_preview / output_pixels_per_base_tile_h - src_base_tile_r_in_st_grid_preview) * output_pixels_per_base_tile_h
                
                src_pixel_c_in_base_tile_preview = min(TILE_WIDTH - 1, int(x_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_w_ratio))
                src_pixel_r_in_base_tile_preview = min(TILE_HEIGHT - 1, int(y_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_h_ratio))

                pixel_color_hex_final_preview = INVALID_TILE_COLOR

                try:
                    tile_idx_from_st_def_preview = definition[src_base_tile_r_in_st_grid_preview][src_base_tile_c_in_st_grid_preview]
                    if 0 <= tile_idx_from_st_def_preview < num_tiles_in_set:
                        if not (0 <= src_pixel_r_in_base_tile_preview < TILE_HEIGHT and \
                                len(tileset_patterns[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview and \
                                0 <= src_pixel_c_in_base_tile_preview < TILE_WIDTH and \
                                len(tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]) > src_pixel_c_in_base_tile_preview and \
                                len(tileset_colors[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview):
                            pixel_color_hex_final_preview = INVALID_TILE_COLOR
                        else:
                            pattern_pixel_val_preview = tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview][src_pixel_c_in_base_tile_preview]
                            fg_idx_val_preview, bg_idx_val_preview = tileset_colors[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]
                            
                            if not (0 <= fg_idx_val_preview < len(self.active_msx_palette) and 0 <= bg_idx_val_preview < len(self.active_msx_palette)):
                                fg_color_preview = INVALID_TILE_COLOR; bg_color_preview = INVALID_TILE_COLOR
                            else:
                                fg_color_preview = self.active_msx_palette[fg_idx_val_preview]
                                bg_color_preview = self.active_msx_palette[bg_idx_val_preview]
                            pixel_color_hex_final_preview = fg_color_preview if pattern_pixel_val_preview == 1 else bg_color_preview
                except IndexError:
                    pixel_color_hex_final_preview = INVALID_TILE_COLOR
                
                row_colors_hex_preview.append(pixel_color_hex_final_preview)
            
            try:
                if safe_target_preview_width > 0:
                    img.put("{" + " ".join(row_colors_hex_preview) + "}", to=(0, y_out_preview))
            except tk.TclError as e:
                if row_colors_hex_preview and safe_target_preview_width > 0:
                    img.put(row_colors_hex_preview[0], to=(0, y_out_preview, safe_target_preview_width, y_out_preview + 1))
        
        self.supertile_image_cache[cache_key] = img # Store in the original cache
        return img

    # --- Menu Creation ---
    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # --- File Menu ---
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(
            label="New Project (All)", command=self.new_project, accelerator="Ctrl+N"
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Project...", command=self.open_project, accelerator="Ctrl+O"
        )
        file_menu.add_command(
            label="Save Project", command=self.save_project, accelerator="Ctrl+S"
        )
        file_menu.add_command(
            label="Save Project As...",
            command=self.save_project_as,
            accelerator="Ctrl+Shift+S",
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Palette...", command=self.open_palette 
        )
        file_menu.add_command(
            label="Save Palette...", command=self.save_palette
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Tileset...", command=self.open_tileset
        )
        file_menu.add_command(
            label="Save Tileset...", command=self.save_tileset
        )
        file_menu.add_separator()
        file_menu.add_command(
            label="Open Supertiles...", command=self.open_supertiles
        )
        file_menu.add_command(
            label="Save Supertiles...", command=self.save_supertiles
        )
        file_menu.add_separator()
        file_menu.add_command(label="Open Map...", command=self.open_map)
        file_menu.add_command(label="Save Map...", command=self.save_map)
        file_menu.add_separator()
        file_menu.add_command(
            label="Exit", command=self.confirm_quit, accelerator="Ctrl+Q"
        )

        # --- Edit Menu ---
        self.edit_menu = tk.Menu(menubar, tearoff=0) 
        menubar.add_cascade(label="Edit", menu=self.edit_menu)

        self.edit_menu.add_command(
            label="Copy",
            command=self.handle_generic_copy,
            state=tk.DISABLED,
            accelerator="Ctrl+C",
        )
        self.copy_menu_item_index = 0 

        self.edit_menu.add_command(
            label="Paste",
            command=self.handle_generic_paste,
            state=tk.DISABLED,
            accelerator="Ctrl+V",
        )
        self.paste_menu_item_index = 1

        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Clear Current Tile", command=self.clear_current_tile
        )
        self.edit_menu.add_command(
            label="Clear Current Supertile", command=self.clear_current_supertile
        )
        self.edit_menu.add_command(label="Clear Map", command=self.clear_map)
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Set Map Dimensions...", command=self.set_map_dimensions
        ) 

        # --- View Menu ---
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(
            label="Show/Hide Minimap", command=self.toggle_minimap, accelerator="Ctrl+M"
        )
        view_menu.add_separator() # Added separator
        view_menu.add_command(label="Color Usage", command=self.toggle_color_usage_window) # Added this line
        # Future usage windows will go here:
        # view_menu.add_command(label="Tile Usage", command=self.toggle_tile_usage_window)
        # view_menu.add_command(label="Supertile Usage", command=self.toggle_supertile_usage_window)


        # --- Import Menu ---
        import_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Import", menu=import_menu)
        import_menu.add_command(
            label="Append Tileset from File...", 
            command=self.append_tileset_from_file
        )
        import_menu.add_command(
            label="Append Supertiles from File...", 
            command=self.append_supertiles_from_file
        )
        import_menu.add_separator()
        import_menu.add_command(
            label="Import Tiles from ROM...", 
            command=self.open_rom_importer
        )

        # --- Help Menu ---
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About...", command=self.show_about_box)

    # --- Widget Creation ---
    def create_palette_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame, padding=5)
        left_frame.grid(row=0, column=0, sticky="ns")
        right_frame = ttk.Frame(main_frame, padding=5)
        right_frame.grid(row=0, column=1, sticky="nsew")
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0)
        main_frame.grid_columnconfigure(1, weight=1)
        # Left Frame Contents
        current_palette_frame = ttk.LabelFrame(
            left_frame, text="Active Palette (16 colors)"
        )
        current_palette_frame.pack(pady=(0, 10), fill="x")
        cp_canvas_width = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        cp_canvas_height = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        self.current_palette_canvas = tk.Canvas(
            current_palette_frame,
            width=cp_canvas_width,
            height=cp_canvas_height,
            borderwidth=0,
            highlightthickness=0,
        )
        self.current_palette_canvas.pack()
        self.current_palette_canvas.bind(
            "<Button-1>", self.handle_current_palette_click
        )
        info_frame = ttk.LabelFrame(left_frame, text="Selected Slot Info")
        info_frame.pack(pady=(0, 10), fill="x")
        self.selected_slot_label = ttk.Label(info_frame, text="Slot: 0")
        self.selected_slot_label.grid(
            row=0, column=0, columnspan=3, sticky="w", padx=5, pady=2
        )
        self.selected_slot_color_label = tk.Label(
            info_frame, text="      ", bg="#000000", relief="sunken", width=6
        )
        self.selected_slot_color_label.grid(row=1, column=0, padx=5, pady=2)
        self.selected_slot_rgb_label = ttk.Label(info_frame, text="RGB: #000000")
        self.selected_slot_rgb_label.grid(
            row=1, column=1, columnspan=2, sticky="w", padx=5
        )
        rgb_frame = ttk.LabelFrame(left_frame, text="Set Color (RGB 0-7)")
        rgb_frame.pack(pady=(0, 10), fill="x")
        r_label = ttk.Label(rgb_frame, text="R:")
        r_label.grid(row=0, column=0, padx=(5, 0))
        self.rgb_r_var = tk.StringVar(value="0")
        self.rgb_r_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_r_var, width=2)
        self.rgb_r_entry.grid(row=0, column=1)
        g_label = ttk.Label(rgb_frame, text="G:")
        g_label.grid(row=0, column=2, padx=(5, 0))
        self.rgb_g_var = tk.StringVar(value="0")
        self.rgb_g_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_g_var, width=2)
        self.rgb_g_entry.grid(row=0, column=3)
        b_label = ttk.Label(rgb_frame, text="B:")
        b_label.grid(row=0, column=4, padx=(5, 0))
        self.rgb_b_var = tk.StringVar(value="0")
        self.rgb_b_entry = ttk.Entry(rgb_frame, textvariable=self.rgb_b_var, width=2)
        self.rgb_b_entry.grid(row=0, column=5)
        apply_rgb_button = ttk.Button(
            rgb_frame, text="Set", command=self.handle_rgb_apply
        )
        apply_rgb_button.grid(row=0, column=6, padx=5, pady=5)
        reset_palette_button = ttk.Button(
            left_frame,
            text="Reset to MSX2 Default",
            command=self.reset_palette_to_default,
        )
        reset_palette_button.pack(pady=(0, 5), fill="x")
        # Right Frame Contents
        picker_frame = ttk.LabelFrame(right_frame, text="MSX2 512 Color Picker")
        picker_frame.pack(expand=True, fill="both")
        picker_canvas_width = MSX2_PICKER_COLS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_canvas_height = MSX2_PICKER_ROWS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_hbar = ttk.Scrollbar(picker_frame, orient=tk.HORIZONTAL)
        picker_vbar = ttk.Scrollbar(picker_frame, orient=tk.VERTICAL)
        self.msx2_picker_canvas = tk.Canvas(
            picker_frame,
            bg="lightgrey",
            scrollregion=(0, 0, picker_canvas_width, picker_canvas_height),
            xscrollcommand=picker_hbar.set,
            yscrollcommand=picker_vbar.set,
        )
        picker_hbar.config(command=self.msx2_picker_canvas.xview)
        picker_vbar.config(command=self.msx2_picker_canvas.yview)
        self.msx2_picker_canvas.grid(row=0, column=0, sticky="nsew")
        picker_vbar.grid(row=0, column=1, sticky="ns")
        picker_hbar.grid(row=1, column=0, sticky="ew")
        picker_frame.grid_rowconfigure(0, weight=1)
        picker_frame.grid_columnconfigure(0, weight=1)
        self.msx2_picker_canvas.bind("<Button-1>", self.handle_512_picker_click)
        self.draw_512_picker()

    def create_tile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        # Left Frame (Editor, Attributes, Transform)
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10))

        editor_frame = ttk.LabelFrame(
            left_frame, text="Tile Editor (Left: FG, Right: BG)"
        )
        editor_frame.grid(row=0, column=0, pady=(0, 10), sticky="ew") 
        
        self.editor_canvas = tk.Canvas(
            editor_frame,
            width=TILE_WIDTH * EDITOR_PIXEL_SIZE,
            height=TILE_HEIGHT * EDITOR_PIXEL_SIZE,
            bg="grey",
        )
        self.editor_canvas.grid(row=0, column=0, sticky=tk.NSEW) 
        editor_frame.grid_rowconfigure(0, weight=1) 
        editor_frame.grid_columnconfigure(0, weight=0) 

        self.editor_canvas.bind("<Button-1>", self.handle_editor_click)
        self.editor_canvas.bind("<B1-Motion>", self.handle_editor_drag)
        self.editor_canvas.bind(
            "<Button-3>", self.handle_editor_click
        ) 
        self.editor_canvas.bind(
            "<B3-Motion>", self.handle_editor_drag
        ) 
        self.editor_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.editor_canvas.bind("<Leave>", self._reset_cursor)

        fg_bg_buttons_container = ttk.Frame(editor_frame)
        fg_bg_buttons_container.grid(row=0, column=1, sticky=(tk.N, tk.S), padx=(10, 0))
        editor_frame.grid_columnconfigure(1, weight=0) 
        
        self.attr_row_frames = [] 
        self.attr_fg_labels = []
        self.attr_bg_labels = []

        for r_idx in range(TILE_HEIGHT):
            row_control_frame = ttk.Frame(fg_bg_buttons_container)
            row_control_frame.grid(row=r_idx, column=0, sticky=tk.EW)
            fg_bg_buttons_container.grid_rowconfigure(r_idx, weight=1) 

            row_control_frame.grid_columnconfigure(0, weight=0)  
            row_control_frame.grid_columnconfigure(1, weight=1)  
            row_control_frame.grid_columnconfigure(2, weight=0)  

            row_num_label = ttk.Label(row_control_frame, text=f"{r_idx}:")
            row_num_label.grid(row=0, column=0, padx=(0, 5), sticky=tk.W)

            fg_label = tk.Label(
                row_control_frame, text=" FG ", width=3, relief="raised", borderwidth=2
            )
            fg_label.grid(row=0, column=1, padx=(0, 2), sticky=tk.E) 
            fg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "fg"))
            self.attr_fg_labels.append(fg_label)

            bg_label = tk.Label(
                row_control_frame, text=" BG ", width=3, relief="raised", borderwidth=2
            )
            bg_label.grid(row=0, column=2, padx=(2, 0), sticky=tk.W) 
            bg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "bg"))
            self.attr_bg_labels.append(bg_label)
            
            self.attr_row_frames.append(row_control_frame)

        transform_frame = ttk.LabelFrame(left_frame, text="Transform")
        transform_frame.grid(row=1, column=0, pady=(0, 5), sticky="ew") 
        
        flip_h_button = ttk.Button(
            transform_frame, text="Flip H", command=self.flip_tile_horizontal
        )
        flip_h_button.grid(row=0, column=0, padx=3, pady=3)
        flip_v_button = ttk.Button(
            transform_frame, text="Flip V", command=self.flip_tile_vertical
        )
        flip_v_button.grid(row=0, column=1, padx=3, pady=3)
        rotate_button = ttk.Button(
            transform_frame, text="Rotate", command=self.rotate_tile_90cw
        )
        rotate_button.grid(row=0, column=2, padx=3, pady=3)
        shift_up_button = ttk.Button(
            transform_frame, text="Shift Up", command=self.shift_tile_up
        )
        shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        shift_down_button = ttk.Button(
            transform_frame, text="Shift Down", command=self.shift_tile_down
        )
        shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        shift_left_button = ttk.Button(
            transform_frame, text="Shift Left", command=self.shift_tile_left
        )
        shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        shift_right_button = ttk.Button(
            transform_frame, text="Shift Right", command=self.shift_tile_right
        )
        shift_right_button.grid(row=1, column=3, padx=3, pady=3)
        
        self.mark_unused_tiles_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_tiles
        )
        self.mark_unused_tiles_button.grid(row=2, column=0, pady=(5, 10), sticky="ew") 

        # Right Frame (Palette, Tileset Viewer, Buttons)
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(
            row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E)
        ) 
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0) 
        main_frame.grid_columnconfigure(1, weight=1) 

        palette_frame = ttk.LabelFrame(
            right_frame, text="Color Selector (Click to draw)"
        )
        palette_frame.grid(row=0, column=0, pady=(0, 10), sticky=(tk.N, tk.W, tk.E))
        self.tile_editor_palette_canvas = tk.Canvas(
            palette_frame,
            width=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            height=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            borderwidth=0,
            highlightthickness=0,
        )
        self.tile_editor_palette_canvas.grid(row=0, column=0)
        self.tile_editor_palette_canvas.bind(
            "<Button-1>", self.handle_tile_editor_palette_click
        )

        viewer_frame = ttk.LabelFrame(right_frame, text="Tileset")
        viewer_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(0, weight=0) 
        right_frame.grid_rowconfigure(1, weight=1) 
        right_frame.grid_rowconfigure(2, weight=0) 
        right_frame.grid_rowconfigure(3, weight=0) 
        right_frame.grid_columnconfigure(0, weight=1) 

        viewer_canvas_width = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1
        num_rows_in_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS)
        viewer_canvas_height = num_rows_in_viewer * (VIEWER_TILE_SIZE + 1) + 1
        viewer_hbar = ttk.Scrollbar(viewer_frame, orient=tk.HORIZONTAL)
        viewer_vbar = ttk.Scrollbar(viewer_frame, orient=tk.VERTICAL)
        self.tileset_canvas = tk.Canvas(
            viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width, viewer_canvas_height),
            xscrollcommand=viewer_hbar.set,
            yscrollcommand=viewer_vbar.set,
        )
        viewer_hbar.config(command=self.tileset_canvas.xview)
        viewer_vbar.config(command=self.tileset_canvas.yview)
        self.tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        viewer_frame.grid_rowconfigure(0, weight=1)
        viewer_frame.grid_columnconfigure(0, weight=1)

        self.tileset_canvas.bind("<Button-1>", self.handle_tileset_click)
        self.tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.tileset_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+") # Added
        self.tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")   # Added
        self.tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")   # Added

        tile_button_frame = ttk.Frame(right_frame)
        tile_button_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(5, 0))

        self.add_tile_button = ttk.Button(
            tile_button_frame, text="Add New", command=self.handle_add_tile
        )
        self.add_tile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.add_many_tiles_button = ttk.Button(
            tile_button_frame, text="Add Many...", command=self.handle_add_many_tiles
        )
        self.add_many_tiles_button.pack(side=tk.LEFT, padx=3)

        self.insert_tile_button = ttk.Button(
            tile_button_frame, text="Insert", command=self.handle_insert_tile
        )
        self.insert_tile_button.pack(side=tk.LEFT, padx=3)

        self.delete_tile_button = ttk.Button(
            tile_button_frame, text="Delete", command=self.handle_delete_tile
        )
        self.delete_tile_button.pack(side=tk.LEFT, padx=3)

        self.tile_info_label = ttk.Label(right_frame, text="Tile: 0/0") # Initial text
        self.tile_info_label.grid(row=3, column=0, sticky=tk.W, pady=(2, 0))

    def create_supertile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10)) # left_frame itself is sticky N (top)

        def_frame = ttk.LabelFrame(
            left_frame, text="Supertile Definition (Click to place selected tile)"
        )
        def_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew") # def_frame is sticky EW (expand horizontally)
        
        def_canvas_width_actual = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
        def_canvas_height_actual = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
        def_canvas_width_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_width_actual)
        def_canvas_height_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_height_actual)

        self.supertile_def_canvas = tk.Canvas(
            def_frame, width=def_canvas_width_actual, height=def_canvas_height_actual, bg="darkgrey"
        )
        self.supertile_def_canvas.grid(row=0, column=0, sticky="nw") 
        def_frame.grid_rowconfigure(0, weight=0) 
        def_frame.grid_columnconfigure(0, weight=0)

        self.supertile_def_canvas.bind("<Button-1>", self.handle_supertile_def_click)
        self.supertile_def_canvas.bind("<B1-Motion>", self.handle_supertile_def_drag)
        self.supertile_def_canvas.bind(
            "<ButtonRelease-1>", self.handle_supertile_def_release
        )
        self.supertile_def_canvas.bind(
            "<Button-3>", self.handle_supertile_def_right_click
        )
        self.supertile_def_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.supertile_def_canvas.bind("<Leave>", self._reset_cursor)

        info_labels_frame = ttk.Frame(left_frame)
        info_labels_frame.grid(
            row=1, column=0, pady=(0, 5), sticky="ew"
        )
        self.supertile_def_info_label = ttk.Label(
            info_labels_frame, text=f"Editing Supertile: {current_supertile_index}" 
        )
        self.supertile_def_info_label.pack(anchor=tk.W)
        self.supertile_tile_select_label = ttk.Label(
            info_labels_frame,
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}", 
        )
        self.supertile_tile_select_label.pack(anchor=tk.W)

        st_transform_frame = ttk.LabelFrame(left_frame, text="Transform Supertile")
        st_transform_frame.grid(
            row=2, column=0, pady=(0, 5), sticky="ew"
        )

        st_flip_h_button = ttk.Button(
            st_transform_frame, text="Flip H", command=self.flip_supertile_horizontal
        )
        st_flip_h_button.grid(row=0, column=0, padx=3, pady=(5, 3))
        st_flip_v_button = ttk.Button(
            st_transform_frame, text="Flip V", command=self.flip_supertile_vertical
        )
        st_flip_v_button.grid(row=0, column=1, padx=3, pady=(5, 3))
        
        self.st_rotate_button = ttk.Button(
            st_transform_frame, text="Rotate", command=self.rotate_supertile_90cw
        )
        self.st_rotate_button.grid(row=0, column=2, padx=3, pady=(5, 3))

        st_shift_up_button = ttk.Button(
            st_transform_frame, text="Shift Up", command=self.shift_supertile_up
        )
        st_shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        st_shift_down_button = ttk.Button(
            st_transform_frame, text="Shift Down", command=self.shift_supertile_down
        )
        st_shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        st_shift_left_button = ttk.Button(
            st_transform_frame, text="Shift Left", command=self.shift_supertile_left
        )
        st_shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        st_shift_right_button = ttk.Button(
            st_transform_frame, text="Shift Right", command=self.shift_supertile_right
        )
        st_shift_right_button.grid(row=1, column=3, padx=3, pady=3)

        self.mark_unused_st_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_supertiles_and_tiles
        )
        self.mark_unused_st_button.grid(row=3, column=0, pady=(5, 10), sticky="ew")

        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E))
        main_frame.grid_columnconfigure(1, weight=1)
        main_frame.grid_rowconfigure(0, weight=1)

        tileset_viewer_frame = ttk.LabelFrame(
            right_frame, text="Tileset (Click to select tile for definition)"
        )
        tileset_viewer_frame.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0, 10)
        )
        right_frame.grid_rowconfigure(0, weight=1) 

        viewer_canvas_width_tiles = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + 1) + 1
        num_rows_in_tile_viewer = math.ceil(MAX_TILES / NUM_TILES_ACROSS) 
        viewer_canvas_height_tiles = num_rows_in_tile_viewer * (VIEWER_TILE_SIZE + 1) + 1

        st_viewer_hbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.HORIZONTAL)
        st_viewer_vbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.VERTICAL)
        self.st_tileset_canvas = tk.Canvas(
            tileset_viewer_frame,
            bg="lightgrey",
            scrollregion=(0, 0, viewer_canvas_width_tiles, viewer_canvas_height_tiles),
            xscrollcommand=st_viewer_hbar.set,
            yscrollcommand=st_viewer_vbar.set,
        )

        st_viewer_hbar.config(command=self.st_tileset_canvas.xview)
        st_viewer_vbar.config(command=self.st_tileset_canvas.yview)
        self.st_tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        st_viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        tileset_viewer_frame.grid_rowconfigure(0, weight=1)
        tileset_viewer_frame.grid_columnconfigure(0, weight=1)

        self.st_tileset_canvas.bind("<Button-1>", self.handle_st_tileset_click)
        self.st_tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.st_tileset_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )
        self.st_tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        st_selector_frame = ttk.LabelFrame(
            right_frame, text="Supertile Selector (Click to edit)"
        )
        st_selector_frame.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        right_frame.grid_rowconfigure(1, weight=1) 

        target_selector_width = 256 
        self.supertile_selector_canvas = tk.Canvas(
            st_selector_frame,
            bg="lightgrey",
            scrollregion=(0, 0, 1, 1), 
            width=target_selector_width 
        )
        st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        self.supertile_selector_canvas.config(
            xscrollcommand=st_sel_hbar.set,
            yscrollcommand=st_sel_vbar.set
        )
        st_sel_hbar.config(command=self.supertile_selector_canvas.xview)
        st_sel_vbar.config(command=self.supertile_selector_canvas.yview)

        self.supertile_selector_canvas.grid(
            row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E)
        )
        st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)

        self.supertile_selector_canvas.bind(
            "<Button-1>", self.handle_supertile_selector_click
        )
        self.supertile_selector_canvas.bind(
            "<B1-Motion>", self.handle_viewer_drag_motion
        )
        self.supertile_selector_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )
        self.supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        bottom_controls_frame = ttk.Frame(right_frame)
        bottom_controls_frame.grid(
            row=2, column=0, sticky="ew", pady=(5, 0)
        )
        right_frame.grid_rowconfigure(2, weight=0)

        self.add_supertile_button = ttk.Button(
            bottom_controls_frame, text="Add New", command=self.handle_add_supertile
        )
        self.add_supertile_button.pack(side=tk.LEFT, padx=(0, 3))

        self.add_many_supertiles_button = ttk.Button(
            bottom_controls_frame, text="Add Many...", command=self.handle_add_many_supertiles
        )
        self.add_many_supertiles_button.pack(side=tk.LEFT, padx=3)

        self.insert_supertile_button = ttk.Button(
            bottom_controls_frame, text="Insert", command=self.handle_insert_supertile
        )
        self.insert_supertile_button.pack(side=tk.LEFT, padx=3)

        self.delete_supertile_button = ttk.Button(
            bottom_controls_frame, text="Delete", command=self.handle_delete_supertile
        )
        self.delete_supertile_button.pack(side=tk.LEFT, padx=3)

        self.supertile_sel_info_label = ttk.Label(
            bottom_controls_frame, text=f"Supertiles: {num_supertiles}" 
        )
        self.supertile_sel_info_label.pack(side=tk.LEFT, anchor=tk.W, padx=(10, 0))

    def create_map_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        self.map_paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.map_paned_window.pack(expand=True, fill="both", padx=5, pady=5)

        map_area_frame = ttk.Frame(self.map_paned_window, padding=(0,0,5,0)) 
        self.map_paned_window.add(map_area_frame, weight=3) 
        self.map_editor_map_pane_container = map_area_frame 

        palette_area_frame = ttk.Frame(self.map_paned_window, padding=(5,0,0,0)) 
        self.map_paned_window.add(palette_area_frame, weight=1) 
        self.map_editor_palette_pane_container = palette_area_frame

        map_area_frame.grid_columnconfigure(0, weight=1)
        map_area_frame.grid_rowconfigure(3, weight=1) 
        
        controls_frame = ttk.Frame(map_area_frame)
        controls_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        size_label = ttk.Label(controls_frame, text="Map Size:")
        size_label.grid(row=0, column=0, padx=(0, 5), pady=2)
        self.map_size_label = ttk.Label(controls_frame, text=f"{map_width} x {map_height}")
        self.map_size_label.grid(row=0, column=1, padx=(0, 10), pady=2)
        zoom_frame = ttk.Frame(controls_frame)
        zoom_frame.grid(row=0, column=2, padx=(10, 0), pady=2)
        zoom_out_button = ttk.Button(zoom_frame,text="-",width=2,command=lambda: self.change_map_zoom_mult(1 / 1.25))
        zoom_out_button.pack(side=tk.LEFT)
        self.map_zoom_label = ttk.Label(zoom_frame, text="100%", width=5, anchor=tk.CENTER)
        self.map_zoom_label.pack(side=tk.LEFT, padx=2)
        zoom_in_button = ttk.Button(zoom_frame,text="+",width=2,command=lambda: self.change_map_zoom_mult(1.25))
        zoom_in_button.pack(side=tk.LEFT)
        zoom_reset_button = ttk.Button(zoom_frame, text="Reset", width=5, command=lambda: self.set_map_zoom(1.0))
        zoom_reset_button.pack(side=tk.LEFT, padx=(5, 0))
        self.map_coords_label = ttk.Label(controls_frame, text="ST Coords: -, -", width=15)
        self.map_coords_label.grid(row=0, column=3, padx=(10, 5), sticky="w")

        win_controls_frame = ttk.Frame(map_area_frame)
        win_controls_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        win_view_check = ttk.Checkbutton(win_controls_frame,text="Show Window View",variable=self.show_window_view,command=self.toggle_window_view)
        win_view_check.grid(row=0, column=0, padx=5, sticky="w")
        win_w_label = ttk.Label(win_controls_frame, text="Width:")
        win_w_label.grid(row=0, column=1, padx=(10, 0))
        self.win_view_w_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_w, width=4)
        self.win_view_w_entry.grid(row=0, column=2)
        win_h_label = ttk.Label(win_controls_frame, text="Height:")
        win_h_label.grid(row=0, column=3, padx=(5, 0))
        self.win_view_h_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_h, width=4)
        self.win_view_h_entry.grid(row=0, column=4)
        win_apply_button = ttk.Button(win_controls_frame,text="Apply Size",command=self.apply_window_size_from_entries)
        win_apply_button.grid(row=0, column=5, padx=5)
        self.win_view_w_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())
        self.win_view_h_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())

        grid_controls_frame = ttk.Frame(map_area_frame)
        grid_controls_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        st_grid_check = ttk.Checkbutton(grid_controls_frame,text="Show Supertile Grid (Press 'G' to Cycle Colors)",variable=self.show_supertile_grid,command=self.toggle_supertile_grid)
        st_grid_check.grid(row=0, column=0, padx=5, sticky="w")
        
        map_area_frame.update_idletasks() 
        controls_frame_width = controls_frame.winfo_reqwidth()
        win_controls_frame_width = win_controls_frame.winfo_reqwidth()
        grid_controls_frame_width = grid_controls_frame.winfo_reqwidth()
        self.map_controls_min_width = max(controls_frame_width, win_controls_frame_width, grid_controls_frame_width) + 10 
        self.debug(f"[DEBUG] create_map_editor_widgets: Calculated map_controls_min_width = {self.map_controls_min_width}")

        map_canvas_frame = ttk.LabelFrame(map_area_frame, text="Map")
        map_canvas_frame.grid(row=3, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_canvas_frame.grid_rowconfigure(0, weight=1)
        map_canvas_frame.grid_columnconfigure(0, weight=1)
        self.map_hbar = ttk.Scrollbar(map_canvas_frame, orient=tk.HORIZONTAL)
        self.map_vbar = ttk.Scrollbar(map_canvas_frame, orient=tk.VERTICAL)
        self.map_canvas = tk.Canvas(map_canvas_frame,bg="black", xscrollcommand=self.map_hbar.set,yscrollcommand=self.map_vbar.set)
        self.map_hbar.config(command=self.map_canvas.xview)
        self.map_vbar.config(command=self.map_canvas.yview)
        self.map_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.map_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.map_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        self.map_canvas.bind("<Configure>", self._on_map_canvas_configure)

        palette_area_frame.grid_rowconfigure(0, weight=1)
        palette_area_frame.grid_columnconfigure(0, weight=1)
        st_selector_frame = ttk.LabelFrame(palette_area_frame, text="Supertile Palette (Click to select for map)")
        st_selector_frame.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0,5))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)
        padding = 1 
        min_one_supertile_preview_width = (self.supertile_grid_width * TILE_WIDTH) + (2 * padding)
        min_one_supertile_preview_width = max(32, min_one_supertile_preview_width) 
        self.map_supertile_selector_canvas = tk.Canvas(st_selector_frame,bg="lightgrey", scrollregion=(0, 0, 1, 1), width=min_one_supertile_preview_width)
        map_st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        map_st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        self.map_supertile_selector_canvas.config(xscrollcommand=map_st_sel_hbar.set, yscrollcommand=map_st_sel_vbar.set)
        map_st_sel_hbar.config(command=self.map_supertile_selector_canvas.xview)
        map_st_sel_vbar.config(command=self.map_supertile_selector_canvas.yview)
        self.map_supertile_selector_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        map_st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        self.map_supertile_select_label = ttk.Label(palette_area_frame, text=f"Selected Supertile for Painting: {selected_supertile_for_map}")
        self.map_supertile_select_label.grid(row=1, column=0, sticky=tk.W, pady=(0, 0))
        self.map_supertile_selector_canvas.bind("<Button-1>", self.handle_map_supertile_selector_click)
        self.map_supertile_selector_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.map_supertile_selector_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.map_supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")
        
        self.map_editor_palette_pane_container.bind("<Configure>", self._on_palette_pane_configure_for_redraw_only)
        self.map_paned_window.bind("<ButtonRelease-1>", self._enforce_palette_min_width_on_release)

    # --- Use this as the SINGLE definition for setting up bindings ---
    def _setup_map_canvas_bindings(self):
        """Sets up ALL event bindings for the map canvas and related root bindings.
        Includes initial unbind step for robustness.
        """
        canvas = self.map_canvas

        # --- Unbind ALL PREVIOUSLY POTENTIAL MAP CANVAS BINDINGS ---
        canvas.unbind("<Button-1>")
        canvas.unbind("<B1-Motion>")
        canvas.unbind("<ButtonRelease-1>")
        canvas.unbind("<Button-3>")
        canvas.unbind("<Control-ButtonPress-1>")
        canvas.unbind("<Control-B1-Motion>")
        canvas.unbind("<Shift-ButtonPress-1>") 
        canvas.unbind("<Shift-B1-Motion>") 
        canvas.unbind("<Shift-ButtonRelease-1>") 
        canvas.unbind("<Control-MouseWheel>")
        canvas.unbind("<Control-Button-4>")
        canvas.unbind("<Control-Button-5>")
        canvas.unbind("<FocusIn>")
        canvas.unbind("<FocusOut>")
        canvas.unbind("<KeyPress-w>")
        canvas.unbind("<KeyPress-a>")
        canvas.unbind("<KeyPress-s>")
        canvas.unbind("<KeyPress-d>")
        canvas.unbind("<KeyPress-W>")
        canvas.unbind("<KeyPress-A>")
        canvas.unbind("<KeyPress-S>")
        canvas.unbind("<KeyPress-D>")
        canvas.unbind("<KeyPress-Escape>") 
        canvas.unbind("<Enter>")
        canvas.unbind("<Leave>")
        canvas.unbind("<Motion>")
        canvas.unbind("<MouseWheel>")
        canvas.unbind("<Button-4>")
        canvas.unbind("<Button-5>")
        # --- End Unbind ---

        # --- Mouse Button 1 (Primary) - Checks Shift/Ctrl internally ---
        canvas.bind("<Button-1>", self.handle_map_click_or_drag_start)
        canvas.bind("<B1-Motion>", self.handle_map_drag)
        canvas.bind("<ButtonRelease-1>", self.handle_map_drag_release)

        # --- Mouse Button 3 (Right-Click for Selection) ---
        canvas.bind("<Button-3>", self.handle_map_canvas_right_click)

        # --- Panning (Ctrl + Mouse Button 1) - Checks Shift internally ---
        canvas.bind("<Control-ButtonPress-1>", self.handle_pan_start)
        canvas.bind("<Control-B1-Motion>", self.handle_pan_motion) 

        # --- Selection (Shift + Mouse Button 1) ---
        canvas.bind("<Shift-ButtonPress-1>", self.handle_map_selection_start)
        canvas.bind("<Shift-B1-Motion>", self.handle_map_selection_motion)
        canvas.bind("<Shift-ButtonRelease-1>", self.handle_map_selection_release)

        # --- Zooming (Ctrl + Mouse Wheel) ---
        canvas.bind("<Control-MouseWheel>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-4>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-5>", self.handle_map_zoom_scroll)
        
        # --- Standard Scrolling (No Modifiers + Mouse Wheel) ---
        canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        canvas.bind("<Button-4>", self._on_mousewheel_scroll)  
        canvas.bind("<Button-5>", self._on_mousewheel_scroll)  

        # --- Keyboard ---
        canvas.bind("<FocusIn>", lambda e: self.map_canvas.focus_set())
        canvas.bind("<FocusOut>", lambda e: self._update_map_cursor())
        canvas.bind("<KeyPress-w>", self.handle_map_keypress)
        canvas.bind("<KeyPress-a>", self.handle_map_keypress)
        canvas.bind("<KeyPress-s>", self.handle_map_keypress)
        canvas.bind("<KeyPress-d>", self.handle_map_keypress)
        canvas.bind("<KeyPress-W>", self.handle_map_keypress)
        canvas.bind("<KeyPress-A>", self.handle_map_keypress)
        canvas.bind("<KeyPress-S>", self.handle_map_keypress)
        canvas.bind("<KeyPress-D>", self.handle_map_keypress)
        canvas.bind("<KeyPress-Escape>", self.handle_map_escape)

        # --- Modifier Key State Tracking (Bound to root window) ---
        self.root.bind("<KeyPress-Control_L>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyPress-Control_R>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyRelease-Control_L>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyRelease-Control_R>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyPress-Shift_L>", self.handle_shift_press, add="+")
        self.root.bind("<KeyPress-Shift_R>", self.handle_shift_press, add="+")
        self.root.bind("<KeyRelease-Shift_L>", self.handle_shift_release, add="+")
        self.root.bind("<KeyRelease-Shift_R>", self.handle_shift_release, add="+")

        # --- Mouse Enter/Leave/Motion Canvas (for cursor updates) ---
        canvas.bind("<Enter>", self.handle_canvas_enter)
        canvas.bind("<Leave>", self.handle_canvas_leave)
        canvas.bind("<Motion>", self._update_map_cursor_and_coords)

        # --- Scrollbar Interaction (Update map canvas AND minimap) ---
        if hasattr(self, "map_hbar") and self.map_hbar:
            self.map_hbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_hbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event) 
        if hasattr(self, "map_vbar") and self.map_vbar:
            self.map_vbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_vbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event)

    # --- Drawing Functions ---
    def update_all_displays(self, changed_level="all"):
        """Updates UI elements ONLY for the currently VISIBLE tab,
        based on the level of change indicated by changed_level.
        Also handles global updates like palette if necessary.
        """
        # Get current visible tab index (safer way)
        current_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab = self.notebook.select()
                if selected_tab:
                    current_tab_index = self.notebook.index(selected_tab)
        except tk.TclError:
            print("Warning: Could not get current tab index in update_all_displays.")
            return  # Avoid errors if notebook state is weird

        # --- Always handle Palette changes first, as they affect look of all tabs ---
        palette_changed = changed_level in ["all", "palette"]
        if palette_changed:
            # Update the palette editor widgets regardless of visibility
            # (They are cheap to update and data source for others)
            self.draw_current_palette()
            self.update_palette_info_labels()
            # Cache invalidation for palette changes is handled by the caller
            # (e.g., handle_rgb_apply, reset_palette...)

        # --- Update widgets ONLY for the VISIBLE tab ---

        # Palette Editor Tab (Index 0)
        if current_tab_index == 0:
            # Widgets already updated above if palette_changed is True.
            # No other data changes directly affect only this tab's display.
            self.debug("[DEBUG]Updating Palette Tab (Visible)")

        # Tile Editor Tab (Index 1)
        elif current_tab_index == 1:
            # Update if tile data changed OR palette changed (affects colors)
            if changed_level in ["all", "tile"] or palette_changed:
                self.debug(f"[DEBUG]Updating Tile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_editor_canvas()
                self.draw_attribute_editor()
                self.draw_palette()  # Uses active_msx_palette
                self.draw_tileset_viewer(
                    self.tileset_canvas, current_tile_index
                )  # Main viewer
                self.update_tile_info_label()
                # We intentionally DO NOT update self.st_tileset_canvas here.
                # It will be updated when the Supertile tab becomes visible.

        # Supertile Editor Tab (Index 2)
        elif current_tab_index == 2:
            # Update if supertile data changed, underlying tile data changed, OR palette changed
            if changed_level in ["all", "supertile", "tile"] or palette_changed:
                self.debug(f"[DEBUG]Updating Supertile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_supertile_definition_canvas()  # Uses tiles & palette
                self.draw_tileset_viewer(
                    self.st_tileset_canvas, selected_tile_for_supertile
                )  # Uses tiles & palette
                self.draw_supertile_selector(
                    self.supertile_selector_canvas, current_supertile_index
                )  # Uses tiles & palette
                self.update_supertile_info_labels()
                # We intentionally DO NOT update self.map_supertile_selector_canvas here.

        # Map Editor Tab (Index 3)
        elif current_tab_index == 3:
            # Update if map data changed, underlying supertile/tile data changed, OR palette changed
            if changed_level in ["all", "map", "supertile", "tile"] or palette_changed:
                self.debug(f"[DEBUG]Updating Map Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                # Map canvas redraw is complex, redraw if map changed OR dependencies changed
                self.draw_map_canvas()  # Handles overlays, uses ST/Tiles/Palette
                self.draw_supertile_selector(
                    self.map_supertile_selector_canvas, selected_supertile_for_map
                )  # Uses ST/Tiles/Palette
                self.update_map_info_labels()  # Update size/zoom/window entries
                self.draw_minimap()  # Uses Map/ST/Tiles/Palette

    # ... (draw_editor_canvas, draw_attribute_editor, draw_palette unchanged) ...
    def draw_editor_canvas(self):
        self.editor_canvas.delete("all")
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        pattern = tileset_patterns[current_tile_index]
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            for c in range(TILE_WIDTH):
                try:
                    pixel_val = pattern[r][c]
                except IndexError:
                    pixel_val = 0
                color = fg_color if pixel_val == 1 else bg_color
                x1 = c * EDITOR_PIXEL_SIZE
                y1 = r * EDITOR_PIXEL_SIZE
                x2 = x1 + EDITOR_PIXEL_SIZE
                y2 = y1 + EDITOR_PIXEL_SIZE
                self.editor_canvas.create_rectangle(
                    x1, y1, x2, y2, fill=color, outline="darkgrey", width=1
                )

    def draw_attribute_editor(self):
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color_hex = self.active_msx_palette[fg_idx]
                bg_color_hex = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color_hex, bg_color_hex = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            self.attr_fg_labels[r].config(
                bg=fg_color_hex, fg=get_contrast_color(fg_color_hex)
            )
            self.attr_bg_labels[r].config(
                bg=bg_color_hex, fg=get_contrast_color(bg_color_hex)
            )

    def draw_palette(self):  # Renamed draw_palette to this for clarity
        """Draws the 16-color selector palette in the Tile Editor tab."""
        canvas = self.tile_editor_palette_canvas
        canvas.delete("all")
        size = PALETTE_SQUARE_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]  # Use active palette
            outline_color = "red" if i == selected_color_index else "grey"
            outline_width = 2 if i == selected_color_index else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_sel_{i}",
            )

    # --- vvv Palette Editor Drawing vvv ---
    def draw_current_palette(self):
        canvas = self.current_palette_canvas
        canvas.delete("all")
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]
            outline_color = "red" if i == self.selected_palette_slot else "grey"
            outline_width = 3 if i == self.selected_palette_slot else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_slot_{i}",
            )

    def draw_512_picker(self):
        canvas = self.msx2_picker_canvas
        canvas.delete("all")
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        for i in range(512):
            row, col = divmod(i, cols)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            hex_color = msx2_512_colors_hex[i]
            r, g, b = msx2_512_colors_rgb7[i]
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=hex_color,
                outline="grey",
                width=1,
                tags=(f"msx2_picker_{i}", f"msx2_rgb_{r}_{g}_{b}"),
            )

    def update_palette_info_labels(self):
        slot = self.selected_palette_slot
        if 0 <= slot < 16:
            color_hex = self.active_msx_palette[slot]
            rgb7 = (-1, -1, -1)
            try:
                idx512 = msx2_512_colors_hex.index(color_hex)
                rgb7 = msx2_512_colors_rgb7[idx512]
            except ValueError:
                pass
            self.selected_slot_label.config(text=f"Slot: {slot}")
            self.selected_slot_color_label.config(bg=color_hex)
            self.selected_slot_rgb_label.config(
                text=f"RGB: {color_hex} ({rgb7[0]},{rgb7[1]},{rgb7[2]})"
            )
            self.rgb_r_var.set(str(rgb7[0]) if rgb7[0] != -1 else "?")
            self.rgb_g_var.set(str(rgb7[1]) if rgb7[1] != -1 else "?")
            self.rgb_b_var.set(str(rgb7[2]) if rgb7[2] != -1 else "?")
        else:
            self.selected_slot_label.config(text="Slot: -")
            self.selected_slot_color_label.config(bg="grey")
            self.selected_slot_rgb_label.config(text="RGB: -")
            self.rgb_r_var.set("")
            self.rgb_g_var.set("")
            self.rgb_b_var.set("")

    def draw_tileset_viewer(self, canvas, highlighted_tile_index):
        """Draws tileset viewer, highlighting selected, dragged, or unused tile."""
        # Check if drag is active and involves a tile from *any* tileset viewer
        is_dragging_tile = self.drag_active and self.drag_item_type == "tile"
        dragged_tile_index = self.drag_start_index if is_dragging_tile else -1

        try:
            canvas.delete("all")
            padding = 1
            size = VIEWER_TILE_SIZE
            max_rows = math.ceil(num_tiles_in_set / NUM_TILES_ACROSS)
            canvas_height = max(1, max_rows * (size + padding) + padding)  
            canvas_width = max(
                1, NUM_TILES_ACROSS * (size + padding) + padding
            )  
            str_scroll = f"0 0 {float(canvas_width)} {float(canvas_height)}"

            # Safely get current scroll region
            current_scroll = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                if isinstance(current_scroll_val, tuple):
                    current_scroll = " ".join(map(str, current_scroll_val))
                else:
                    current_scroll = str(current_scroll_val)
            except tk.TclError:
                # Canvas might not be fully ready
                pass

            # Update scrollregion if needed
            if current_scroll != str_scroll:
                canvas.config(scrollregion=(0, 0, canvas_width, canvas_height))

            # Draw each tile
            for i in range(num_tiles_in_set):
                tile_r, tile_c = divmod(i, NUM_TILES_ACROSS)
                base_x = tile_c * (size + padding) + padding
                base_y = tile_r * (size + padding) + padding

                # Get cached image
                img = self.create_tile_image(i, size)
                canvas.create_image(
                    base_x,
                    base_y,
                    image=img,
                    anchor=tk.NW,
                    tags=(f"tile_img_{i}", "tile_image"),
                )

                # Determine outline style
                outline_color = "grey" 
                outline_width = 1
                if i == dragged_tile_index: # Highest priority: item being dragged
                    outline_color = "yellow" 
                    outline_width = 3
                elif i == highlighted_tile_index: # Next priority: current selection
                    outline_color = "red"
                    outline_width = 2
                elif i in self.marked_unused_tiles: # Then, check for unused highlight
                    outline_color = "blue" # Blue for unused
                    outline_width = 3 # Bold blue (width 3)

                # Draw the border rectangle
                bx1 = max(0, base_x - padding / 2)
                by1 = max(0, base_y - padding / 2)
                bx2 = base_x + size + padding / 2
                by2 = base_y + size + padding / 2
                canvas.create_rectangle(
                    bx1,
                    by1,
                    bx2,
                    by2,
                    outline=outline_color,
                    width=outline_width,
                    tags=f"tile_border_{i}",
                )

        except tk.TclError as e:
            # Catch errors if the canvas is destroyed during redraw
            print(f"TclError during draw_tileset_viewer: {e}")
        except Exception as e:
            print(f"Unexpected error during draw_tileset_viewer: {e}")

    def update_tile_info_label(self):
        self.tile_info_label.config(
            text=f"Tile: {current_tile_index}/{max(0, num_tiles_in_set-1)}"
        )

    def draw_supertile_definition_canvas(self):
        canvas = self.supertile_def_canvas
        canvas.delete("all")
        if not (0 <= current_supertile_index < num_supertiles):
            return

        definition = supertiles_data[current_supertile_index]
        
        # Ensure definition has expected structure based on current project dimensions
        # This is a safeguard. Data should ideally be consistent.
        if not definition or len(definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(definition[0]) != self.supertile_grid_width)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} definition dimensions mismatch in draw_supertile_definition_canvas.")
            # Optionally draw an error indicator on the canvas
            canvas_w = canvas.winfo_width()
            canvas_h = canvas.winfo_height()
            canvas.create_text(canvas_w/2, canvas_h/2, text="Dim Mismatch!", fill="red", anchor="center")
            return

        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32x32 pixels)
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 

        for r_def in range(self.supertile_grid_height):
            for c_def in range(self.supertile_grid_width):
                try:
                    tile_idx = definition[r_def][c_def]
                except IndexError: # Should be caught by the check above, but for safety
                    self.debug(f"[DEBUG]Error drawing ST def: index out of bounds for ST {current_supertile_index} at {r_def},{c_def}")
                    tile_idx = 0 # Default to tile 0 on error

                base_x = c_def * mini_tile_display_size
                base_y = r_def * mini_tile_display_size
                
                img = self.create_tile_image(tile_idx, mini_tile_display_size)
                canvas.create_image(
                    base_x, base_y, image=img, anchor=tk.NW, tags=f"def_tile_{r_def}_{c_def}"
                )
                canvas.create_rectangle(
                    base_x, base_y, base_x + mini_tile_display_size, base_y + mini_tile_display_size, outline="grey"
                )
    
    def draw_supertile_selector(self, canvas, highlighted_supertile_index):
        is_dragging_supertile = self.drag_active and self.drag_item_type == "supertile"
        dragged_supertile_index = self.drag_start_index if is_dragging_supertile else -1

        try:
            if not canvas.winfo_exists():
                return
            canvas.delete("all") # Clear previous items
            
            item_pixel_w = self.supertile_grid_width * TILE_WIDTH
            item_pixel_h = self.supertile_grid_height * TILE_HEIGHT
            padding = 1 

            if item_pixel_w <= 0 or item_pixel_h <= 0:
                self.debug(f"[DEBUG] draw_supertile_selector: Invalid item_pixel_w/h ({item_pixel_w}x{item_pixel_h}). Aborting.")
                return

            actual_canvas_width = canvas.winfo_width()
            if actual_canvas_width <= 1: 
                 # Canvas not yet sized, reschedule.
                 # Ensure we don't get into an infinite after loop if it never gets size.
                 # Add a counter or a flag if this becomes an issue.
                 canvas.after(100, lambda: self.draw_supertile_selector(canvas, highlighted_supertile_index))
                 return
            
            self.debug(f"[DEBUG] draw_supertile_selector: Actual Canvas Width: {actual_canvas_width}, Item Pixel W: {item_pixel_w}")

            # Calculate how many items can fit, ensuring at least one if possible.
            if item_pixel_w + 2 * padding > actual_canvas_width : # Not even one fits with padding on both sides
                items_across = 0 # Or 1 if you want to force one and let it clip/be tiny
                if item_pixel_w <= actual_canvas_width : # Fits without padding
                    items_across = 1
                # else: it's wider than canvas, items_across remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                items_across = (actual_canvas_width - padding) // (item_pixel_w + padding)
            
            items_across = max(1, items_across) # Ensure at least 1 item is planned if possible, even if it overflows slightly
                                                # or if the canvas is very narrow. If item_pixel_w itself is > canvas_width,
                                                # it will still draw 1 item that will be clipped by the canvas viewport.

            self.debug(f"[DEBUG] draw_supertile_selector: Calculated items_across: {items_across}")

            num_logical_rows = math.ceil(num_supertiles / items_across) if items_across > 0 else num_supertiles
            # Scrollregion width should be based on the calculated items_across to fit them snugly
            scroll_content_width = (items_across * item_pixel_w) + ((items_across + 1) * padding)
            scroll_content_height = (num_logical_rows * item_pixel_h) + ((num_logical_rows + 1) * padding)
            scroll_content_width = max(1.0, float(scroll_content_width))
            scroll_content_height = max(1.0, float(scroll_content_height))

            str_scroll = f"0 0 {scroll_content_width} {scroll_content_height}"
            current_scroll_val_str = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                current_scroll_val_str = " ".join(map(str, current_scroll_val)) if isinstance(current_scroll_val, tuple) else str(current_scroll_val)
            except tk.TclError: pass

            if current_scroll_val_str != str_scroll :
                try:
                    canvas.config(scrollregion=(0, 0, scroll_content_width, scroll_content_height))
                    self.debug(f"[DEBUG] draw_supertile_selector: Scrollregion set to: {scroll_content_width}x{scroll_content_height}")
                except tk.TclError: self.debug("[DEBUG] draw_supertile_selector: TclError setting scrollregion."); return

            # Optimized drawing for visible rows (same as before)
            view_y1 = canvas.canvasy(0)
            view_y2 = canvas.canvasy(canvas.winfo_height())
            # For a vertically scrolling list, start_draw_col is always 0, end_draw_col is items_across
            start_draw_row = max(0, int(view_y1 // (item_pixel_h + padding)))
            end_draw_row = min(num_logical_rows, int(math.ceil(view_y2 / (item_pixel_h + padding))))
            # Ensure at least one row is attempted if there's content, and end_draw_row covers partials
            if num_logical_rows > 0 and end_draw_row == start_draw_row and view_y2 > view_y1:
                 end_draw_row = max(end_draw_row, start_draw_row +1) # Ensure at least one iteration if content exists and view is valid
            end_draw_row = min(num_logical_rows, end_draw_row) # Clamp to actual rows

            self.debug(f"[DEBUG] draw_supertile_selector: Drawing rows {start_draw_row} to {end_draw_row-1}")


            for r_grid in range(start_draw_row, end_draw_row):
                for c_grid in range(items_across):
                    st_idx = r_grid * items_across + c_grid
                    if st_idx >= num_supertiles: break

                    base_x = (c_grid * (item_pixel_w + padding)) + padding
                    base_y = (r_grid * (item_pixel_h + padding)) + padding

                    img = self.create_supertile_image(st_idx, item_pixel_w, item_pixel_h) 
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_image(
                        base_x, base_y, image=img, anchor=tk.NW, tags=(f"st_img_{st_idx}", "st_image")
                    )

                    outline_color = "grey"; outline_width = 1
                    if st_idx == dragged_supertile_index: outline_color = "yellow"; outline_width = 3
                    elif st_idx == highlighted_supertile_index: outline_color = "red"; outline_width = 2
                    elif st_idx in self.marked_unused_supertiles: outline_color = "blue"; outline_width = 3
                    
                    bx1 = base_x - (padding / 2 if padding > 0 else 0.5) 
                    by1 = base_y - (padding / 2 if padding > 0 else 0.5)
                    bx2 = base_x + item_pixel_w + (padding / 2 if padding > 0 else 0.5)
                    by2 = base_y + item_pixel_h + (padding / 2 if padding > 0 else 0.5)
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_rectangle(
                        bx1, by1, bx2, by2, outline=outline_color, width=outline_width, tags=f"st_border_{st_idx}"
                    )
                if st_idx >= num_supertiles -1 : break # Break outer loop if all STs processed
        except tk.TclError as e: self.debug(f"[DEBUG] TclError in draw_supertile_selector: {e}")
        except Exception as e: self.debug(f"[DEBUG] Unexpected error in draw_supertile_selector: {e}")

    def update_supertile_info_labels(self):
        self.supertile_def_info_label.config(
            text=f"Editing Supertile: {current_supertile_index}/{max(0, num_supertiles-1)}"
        )
        self.supertile_tile_select_label.config(
            text=f"Selected Tile for Placing: {selected_tile_for_supertile}"
        )
        self.supertile_sel_info_label.config(text=f"Supertiles: {num_supertiles}")

    def draw_map_canvas(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return
        
        # Delete old canvas items first (specifically map content, not overlays yet)
        # The main image will be tagged "map_render_image", selection and grids are separate.
        canvas.delete("map_render_image") # Delete only the main rendered image for now

        self.debug(f"[DEBUG] draw_map_canvas: Start. Zoom: {self.map_zoom_level:.2f}")

        # --- 1. Calculate Sizes ---
        zoomed_tile_size = self.get_zoomed_tile_size() 
        if zoomed_tile_size <= 0: 
            self.debug("[DEBUG] draw_map_canvas: zoomed_tile_size <= 0. Aborting.")
            return

        zoomed_supertile_pixel_width, zoomed_supertile_pixel_height = self._get_zoomed_supertile_pixel_dims()
        if zoomed_supertile_pixel_width <= 0 or zoomed_supertile_pixel_height <= 0:
            self.debug("[DEBUG] draw_map_canvas: zoomed_supertile_pixel_width/height <= 0. Aborting.")
            return
        
        self.debug(f"[DEBUG] draw_map_canvas: Zoomed ST dims (WxH): {zoomed_supertile_pixel_width}x{zoomed_supertile_pixel_height}")


        # --- 2. Update Scroll Region (based on total map content size at current zoom) ---
        map_content_pixel_width_total = map_width * zoomed_supertile_pixel_width
        map_content_pixel_height_total = map_height * zoomed_supertile_pixel_height
        
        safe_scroll_width = max(1.0, float(map_content_pixel_width_total))
        safe_scroll_height = max(1.0, float(map_content_pixel_height_total))
        
        # Only update scrollregion if it actually changed to avoid unnecessary internal Tk processing
        current_scroll_region_str = ""
        try:
            sr = canvas.cget("scrollregion")
            if sr and isinstance(sr, str) and len(sr.split()) == 4: # Basic check for valid format
                current_scroll_region_str = sr
        except tk.TclError: pass # Canvas might not be fully ready on first call

        new_scroll_region_str = f"0 0 {safe_scroll_width} {safe_scroll_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                canvas.config(scrollregion=(0, 0, safe_scroll_width, safe_scroll_height))
                self.debug(f"[DEBUG] draw_map_canvas: Scrollregion set to {new_scroll_region_str}")
            except tk.TclError: 
                self.debug("[DEBUG] draw_map_canvas: TclError setting scrollregion.")
                return # Cannot proceed if scrollregion fails
        
        # --- 3. Get Viewport Info ---
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 0 or canvas_viewport_height <= 0:
            self.debug("[DEBUG] draw_map_canvas: Viewport width/height <= 0. Aborting.")
            return

        view_content_x1 = canvas.canvasx(0) # Top-left X of visible part of content
        view_content_y1 = canvas.canvasy(0) # Top-left Y of visible part of content
        self.debug(f"[DEBUG] draw_map_canvas: Viewport WxH: {canvas_viewport_width}x{canvas_viewport_height}, Content scroll: ({view_content_x1:.1f}, {view_content_y1:.1f})")


        # --- 4. Create/Resize Pillow Viewport Image Buffer ---
        # self.pil_map_viewport_image stores the Pillow Image
        # self.tk_map_photoimage stores the Tk PhotoImage for display (and keeps a reference)
        if self.pil_map_viewport_image is None or \
           self.pil_map_viewport_image.width != canvas_viewport_width or \
           self.pil_map_viewport_image.height != canvas_viewport_height:
            try:
                self.pil_map_viewport_image = Image.new('RGB', 
                                                        (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), 
                                                        canvas.cget("bg")) # Fill with canvas BG
                self.debug(f"[DEBUG] draw_map_canvas: Created/Resized self.pil_map_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except ValueError as e_pil_new:
                self.debug(f"[DEBUG] draw_map_canvas: Error creating pil_map_viewport_image: {e_pil_new}")
                return
        else:
            # Fill existing image with background color
            try:
                self.pil_map_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill: # Catch potential errors if canvas.cget("bg") is not a valid color for paste
                self.debug(f"[DEBUG] draw_map_canvas: Error filling pil_map_viewport_image: {e_fill}. Filling with black.")
                self.pil_map_viewport_image.paste("black", (0,0,canvas_viewport_width,canvas_viewport_height) )


        # --- 5. Determine Visible Supertile Range & Composite onto Pillow Viewport Image ---
        start_st_col = max(0, int(view_content_x1 // zoomed_supertile_pixel_width))
        start_st_row = max(0, int(view_content_y1 // zoomed_supertile_pixel_height))
        
        # End column/row (exclusive) needed to cover the viewport
        end_st_col = min(map_width, int(math.ceil((view_content_x1 + canvas_viewport_width) / zoomed_supertile_pixel_width)))
        end_st_row = min(map_height, int(math.ceil((view_content_y1 + canvas_viewport_height) / zoomed_supertile_pixel_height)))
        
        self.debug(f"[DEBUG] draw_map_canvas: Visible STs - Cols: {start_st_col}-{end_st_col-1}, Rows: {start_st_row}-{end_st_row-1}")

        rendered_st_count = 0
        for r_map in range(start_st_row, end_st_row):
            for c_map in range(start_st_col, end_st_col):
                if not (0 <= r_map < map_height and 0 <= c_map < map_width): # Should be redundant due to loop bounds
                    continue
                
                try:
                    supertile_idx = map_data[r_map][c_map]
                    
                    # Get the scaled Pillow Image for this supertile
                    pil_supertile_render = self.create_map_render_of_supertile(
                        supertile_idx, 
                        round(zoomed_supertile_pixel_width), # Pass rounded int sizes
                        round(zoomed_supertile_pixel_height)
                    )

                    if pil_supertile_render:
                        # Calculate paste position on the pil_map_viewport_image
                        # Target X,Y on the viewport image is the ST's content position MINUS the scroll offset
                        content_st_x = c_map * zoomed_supertile_pixel_width
                        content_st_y = r_map * zoomed_supertile_pixel_height
                        
                        paste_x_on_viewport_img = round(content_st_x - view_content_x1)
                        paste_y_on_viewport_img = round(content_st_y - view_content_y1)
                        
                        # Paste (Pillow handles clipping if ST partially outside viewport bounds for paste)
                        self.pil_map_viewport_image.paste(pil_supertile_render, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                        rendered_st_count +=1
                except IndexError:
                    self.debug(f"[DEBUG] draw_map_canvas: IndexError for map_data[{r_map}][{c_map}]")
                except Exception as e_render_st:
                    self.debug(f"[DEBUG] draw_map_canvas: Error rendering/pasting ST ({r_map},{c_map}): {e_render_st}")
        
        self.debug(f"[DEBUG] draw_map_canvas: Rendered {rendered_st_count} supertiles onto Pillow viewport image.")

        # --- 6. Convert Pillow Viewport Image to Tk PhotoImage and Display ---
        try:
            self.tk_map_photoimage = ImageTk.PhotoImage(self.pil_map_viewport_image)
        except Exception as e_photoimg:
            self.debug(f"[DEBUG] draw_map_canvas: Error converting PIL to Tk PhotoImage: {e_photoimg}")
            return

        # Place the single viewport image onto the canvas at the current scroll position
        # This ensures it aligns with other canvas items drawn using content coordinates.
        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1, 
                                    image=self.tk_map_photoimage, 
                                    anchor=tk.NW, 
                                    tags=("map_render_image", "all_map_content")) # New specific tag
        except tk.TclError as e_create_img:
            self.debug(f"[DEBUG] draw_map_canvas: TclError creating canvas image: {e_create_img}")


        # --- 7. Re-draw Overlays (Grid, Selection, Window View, Paste Preview) ---
        # These are drawn directly on the canvas, on top of the "map_render_image".
        # They need to be deleted and redrawn if their appearance depends on zoom or position.
        
        canvas.delete("supertile_grid") # Delete old grid lines
        if self.show_supertile_grid.get():
            grid_color = GRID_COLOR_CYCLE[self.grid_color_index]
            # Draw vertical lines
            for c_grid in range(map_width + 1):
                x_line = c_grid * zoomed_supertile_pixel_width
                if x_line >= view_content_x1 and x_line <= view_content_x1 + canvas_viewport_width + zoomed_supertile_pixel_width : # Optimization for visibility
                     canvas.create_line(x_line, 0, x_line, map_content_pixel_height_total, 
                                        fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            # Draw horizontal lines
            for r_grid in range(map_height + 1):
                y_line = r_grid * zoomed_supertile_pixel_height
                if y_line >= view_content_y1 and y_line <= view_content_y1 + canvas_viewport_height + zoomed_supertile_pixel_height: # Optimization
                    canvas.create_line(0, y_line, map_content_pixel_width_total, y_line,
                                       fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            if canvas.find_withtag("map_render_image"): # Ensure grid is above map image if both exist
                canvas.tag_raise("supertile_grid", "map_render_image")


        self._draw_selection_rectangle() # This deletes old and draws new selection_rect_id

        canvas.delete("window_view_item") # Delete all old window view components
        if self.show_window_view.get():
            # ... (Window View drawing logic - largely same, ensure coordinates are content coords) ...
            # (Make sure it uses zoomed_tile_size, window_view_tile_x/y/w/h for its calculations)
            # Example for main rectangle:
            win_px_start = self.window_view_tile_x * zoomed_tile_size
            win_py_start = self.window_view_tile_y * zoomed_tile_size
            win_pixel_width_total = self.window_view_tile_w.get() * zoomed_tile_size
            win_pixel_height_total = self.window_view_tile_h.get() * zoomed_tile_size
            win_color = GRID_COLOR_CYCLE[self.grid_color_index] # Or a dedicated window view color

            canvas.create_rectangle(win_px_start, win_py_start, 
                                    win_px_start + win_pixel_width_total, 
                                    win_py_start + win_pixel_height_total, 
                                    outline=win_color, width=2, tags=("window_view_rect", "window_view_item"))
            # ... (half-row shading and handles drawing, using content coordinates)
            if self.window_view_tile_h.get() == MAX_WIN_VIEW_HEIGHT_TILES: 
                half_tile_h_px_zoomed = zoomed_tile_size / 2
                dark_y1 = win_py_start + win_pixel_height_total - half_tile_h_px_zoomed
                dark_y2 = win_py_start + win_pixel_height_total
                canvas.create_rectangle(win_px_start, dark_y1, 
                                        win_px_start + win_pixel_width_total, dark_y2, 
                                        fill="gray50", stipple="gray50", outline="", tags=("window_view_overscan", "window_view_item"))
            
            handle_size = WIN_VIEW_HANDLE_SIZE; hs2 = handle_size // 2
            handle_fill = win_color
            handle_outline = "black" if win_color != "#000000" else "white"
            handles_coords = { 
                "nw": (win_px_start, win_py_start), 
                "n": (win_px_start + win_pixel_width_total / 2, win_py_start), 
                # ... all 8 handles ...
                "ne": (win_px_start + win_pixel_width_total, win_py_start),
                "w": (win_px_start, win_py_start + win_pixel_height_total / 2),
                "e": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total / 2),
                "sw": (win_px_start, win_py_start + win_pixel_height_total), 
                "s": (win_px_start + win_pixel_width_total / 2, win_py_start + win_pixel_height_total), 
                "se": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total),
            }
            for tag_handle, (cx_handle, cy_handle) in handles_coords.items():
                x1h, y1h, x2h, y2h = cx_handle - hs2, cy_handle - hs2, cx_handle + hs2, cy_handle + hs2
                canvas.create_rectangle(x1h, y1h, x2h, y2h, fill=handle_fill, outline=handle_outline, width=1, tags=("window_view_handle", f"handle_{tag_handle}", "window_view_item"))

            if canvas.find_withtag("map_render_image"): # Ensure window view is on top
                canvas.tag_raise("window_view_item", "map_render_image")
            if canvas.find_withtag("selection_rect"):
                canvas.tag_raise("window_view_item", "selection_rect") # Window view on top of selection
            if canvas.find_withtag("supertile_grid"):
                 canvas.tag_raise("window_view_item", "supertile_grid")


        # Paste preview should be drawn last if active
        # It deletes and redraws itself based on mouse position, handled by _update_map_cursor_and_coords
        # but we might need to trigger its redraw if it was previously cleared by canvas.delete("all")
        # This part is tricky - better to let its own handler manage it.
        # For now, ensure it's on top if it exists.
        if self.map_paste_preview_rect_id:
            canvas.tag_raise(self.map_paste_preview_rect_id)


        # --- 8. Update Zoom Label ---
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
        
        # canvas.update_idletasks() # Already called by the invoking function if needed (e.g. scroll/keypress handlers)
        self.debug("[DEBUG] draw_map_canvas: End.")

    def update_map_info_labels(self):
        self.map_size_label.config(text=f"{map_width} x {map_height}")
        self.map_supertile_select_label.config(
            text=f"Selected Supertile for Painting: {selected_supertile_for_map}"
        )
        # Update window size entries from state variables
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Ensure IntVar reflects internal state if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())
        # Zoom label updated in draw_map_canvas

    def on_tab_change(self, event):
        self._clear_marked_unused(trigger_redraw=False) # Clear marks on any tab change

        current_tab_index = -1 # Used for debugging or specific tab logic if needed later
        new_tab_index = -1
        selected_tab_widget = None # Store the actual widget of the selected tab

        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    new_tab_index = self.notebook.index(selected_tab_path)
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
        except tk.TclError:
            self.debug("[DEBUG] on_tab_change: TclError getting current tab info.")
            pass # Proceed with generic updates if tab info fails

        if self.map_paste_preview_rect_id: # Clear map paste preview if switching away or to map
            self._clear_paste_preview_rect()

        # Always update all displays based on the newly selected tab's needs
        self.update_all_displays(changed_level="all") # This will draw the content of the new tab

        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()

        # Manage global key bindings or focus specific to the new tab
        try:
            self.root.unbind("<KeyPress-g>") # Unbind from any previous tab that might have used it
            self.root.unbind("<KeyPress-G>")
        except tk.TclError:
            pass # In case bindings weren't set

        if selected_tab_widget == self.tab_map_editor: # Check using the stored tab frame widget
            self.debug("[DEBUG] on_tab_change: Map Editor tab selected.")
            # Bind 'g' for grid color cycling only when map tab is active
            self.root.bind("<KeyPress-g>", self.handle_map_tab_keypress, add="+")
            self.root.bind("<KeyPress-G>", self.handle_map_tab_keypress, add="+")
            
            # Ensure canvas gets focus for keyboard events (pan, zoom hints, etc.)
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                # Use after_idle to ensure tab is fully visible and canvas can take focus
                self.root.after_idle(self.map_canvas.focus_set)

            # --- ADDED: Schedule enforcement of pane minimums ---
            def enforce_map_pane_minimums_after_tab_change():
                self.debug("[DEBUG] on_tab_change: Map tab visible, performing delayed pane minimum check.")
                # Check if map_paned_window actually exists and is visible now
                if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                    self._do_check_and_enforce_palette_min_width()
                else:
                    self.debug("[DEBUG] on_tab_change: Map paned window not ready for min width enforcement yet.")
            
            # Use after_idle to ensure PanedWindow and its panes have their geometry updated
            self.root.after_idle(enforce_map_pane_minimums_after_tab_change)
            # --- END ADDED ---

            # Draw paste preview if applicable (already handled by _update_map_cursor_and_coords on Motion/Enter)
            # but an explicit call here after tab switch might be desired if mouse is already over canvas.
            # For now, let motion/enter handle it.

        # Update cursor for the map canvas if it's the active tab, or reset otherwise
        # This is a general cursor update based on context.
        self.root.after_idle(self._update_map_cursor) # update_map_cursor checks for map_canvas focus

    # --- Palette Editor Handlers ---
    def handle_current_palette_click(self, event):
        canvas = self.current_palette_canvas
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_slot = row * 4 + col
        if 0 <= clicked_slot < 16:
            if self.selected_palette_slot != clicked_slot:
                self.selected_palette_slot = clicked_slot
                self.draw_current_palette()  # Redraw highlight
                self.update_palette_info_labels()  # Update info display

    def handle_512_picker_click(self, event):
        if not (0 <= self.selected_palette_slot < 16):
            return
        canvas = self.msx2_picker_canvas
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        col = int(canvas_x // (size + padding))
        row = int(canvas_y // (size + padding))
        clicked_index = row * cols + col
        
        if 0 <= clicked_index < 512:
            new_color_hex = msx2_512_colors_hex[clicked_index]
            target_slot = self.selected_palette_slot
            if self.active_msx_palette[target_slot] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot] = new_color_hex
                print(f"Set Palette Slot {target_slot} to {new_color_hex}")
                self.clear_all_caches()
                self.update_all_displays(changed_level="all")
        else:
            print("Clicked outside valid color range in picker.")

    def handle_rgb_apply(self):
        if not (0 <= self.selected_palette_slot < 16):
            return
        try:
            r_val = int(self.rgb_r_var.get()) # Renamed r
            g_val = int(self.rgb_g_var.get()) # Renamed g
            b_val = int(self.rgb_b_var.get()) # Renamed b
            if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                raise ValueError("RGB values must be 0-7.")
            
            new_color_hex = self._rgb7_to_hex(r_val, g_val, b_val)
            target_slot = self.selected_palette_slot
            
            if self.active_msx_palette[target_slot] != new_color_hex:
                if self._clear_marked_unused(trigger_redraw=False): # Clear before palette change
                    pass # Full redraw will happen anyway
                
                self._mark_project_modified()
                self.active_msx_palette[target_slot] = new_color_hex
                print(f"Set Palette Slot {target_slot} to {new_color_hex} via RGB")
                self.clear_all_caches()
                self.update_all_displays(changed_level="all") # "all" because palette affects everything
        except ValueError as e:
            messagebox.showerror("Invalid RGB", f"Invalid RGB input: {e}")

    def reset_palette_to_default(self):
        confirm = messagebox.askokcancel(
            "Reset Palette",
            "Reset the active palette to the MSX2 default colors?\nThis will affect the appearance of all tiles and supertiles.",
        )
        if confirm:
            new_default_palette = []
            for r_val, g_val, b_val in MSX2_RGB7_VALUES: # Renamed r,g,b
                new_default_palette.append(self._rgb7_to_hex(r_val, g_val, b_val))
            
            if self.active_msx_palette != new_default_palette:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                self._mark_project_modified()
                self.active_msx_palette = new_default_palette
                self.selected_palette_slot = 0
                global selected_color_index
                selected_color_index = 0 # Or WHITE_IDX depending on desired default
                self.clear_all_caches()
                self.update_all_displays(changed_level="all")
                print("Palette reset to MSX2 defaults.")
            else:
                print("Palette is already set to MSX2 defaults.")

    # --- Tile Editor Handlers ---
    def handle_editor_click(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        # --- Clear marked unused if an actual drawing action occurs ---
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE
        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            pixel_value_to_set = 1 if event.num == 1 else 0 # Determine based on left/right click
            if tileset_patterns[current_tile_index][r][c] != pixel_value_to_set:
                # Call _clear_marked_unused only if a change is about to be made
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                
                self._mark_project_modified()
                tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                self.invalidate_tile_cache(current_tile_index)
                # update_all_displays will be called again if marks were cleared,
                # otherwise, a more targeted update is fine.
                if not (self.marked_unused_tiles or self.marked_unused_supertiles): # if no marks were cleared
                    self.update_all_displays(changed_level="tile")
            last_drawn_pixel = (r, c)

    def handle_editor_drag(self, event):
        global last_drawn_pixel, current_tile_index, tileset_patterns
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE
        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if (r, c) != last_drawn_pixel:
                pixel_value_to_set = (
                    1 if event.state & 0x100 else (0 if event.state & 0x400 else -1)
                ) # Determine based on button state during drag
                if (
                    pixel_value_to_set != -1
                    and tileset_patterns[current_tile_index][r][c] != pixel_value_to_set
                ):
                    # Call _clear_marked_unused only if a change is about to be made
                    if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                        self.update_all_displays(changed_level="all") # Redraw if marks were cleared

                    self._mark_project_modified()
                    tileset_patterns[current_tile_index][r][c] = pixel_value_to_set
                    self.invalidate_tile_cache(current_tile_index)
                    if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                        self.update_all_displays(changed_level="tile")
                last_drawn_pixel = (r, c)

    def handle_tile_editor_palette_click(self, event):
        global selected_color_index
        canvas = self.tile_editor_palette_canvas
        size = PALETTE_SQUARE_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_index = row * 4 + col
        if 0 <= clicked_index < 16:
            if selected_color_index != clicked_index:
                selected_color_index = clicked_index
                self.draw_palette()  # Redraw this palette only

    def set_row_color(self, row, fg_or_bg):
        global tileset_colors, current_tile_index, selected_color_index
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        if not (0 <= selected_color_index < 16):
            return
        if 0 <= row < TILE_HEIGHT:
            current_fg_idx, current_bg_idx = tileset_colors[current_tile_index][row]
            changed = False
            if fg_or_bg == "fg" and current_fg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                tileset_colors[current_tile_index][row] = (
                    selected_color_index,
                    current_bg_idx,
                )
                changed = True
            elif fg_or_bg == "bg" and current_bg_idx != selected_color_index:
                if self._clear_marked_unused(trigger_redraw=False): # Clear state first
                    self.update_all_displays(changed_level="all") # Redraw if marks were cleared
                tileset_colors[current_tile_index][row] = (
                    current_fg_idx,
                    selected_color_index,
                )
                changed = True
            
            if changed:
                self._mark_project_modified()
                self.invalidate_tile_cache(current_tile_index)
                if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                    self.update_all_displays(changed_level="tile")

    def handle_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False 
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0 
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id) # Use current canvas
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x 
            self.drag_press_y = event.y 
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def flip_tile_horizontal(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        # Clear marks if any, and redraw if marks were present
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all") 

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            new_pattern[r] = current_pattern[r][::-1]
        tileset_patterns[current_tile_index] = new_pattern
        
        self.invalidate_tile_cache(current_tile_index)
        # If marks were not cleared above, do a targeted update
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} flipped horizontally.")

    def flip_tile_vertical(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        tileset_patterns[current_tile_index].reverse()
        tileset_colors[current_tile_index].reverse()
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} flipped vertically.")

    def rotate_tile_90cw(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0 for _ in range(TILE_WIDTH)] for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            for c in range(TILE_WIDTH):
                new_pattern[c][(TILE_HEIGHT - 1) - r] = current_pattern[r][c]
        tileset_patterns[current_tile_index] = new_pattern
        tileset_colors[current_tile_index] = [
            (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
        ]  
        
        self._mark_project_modified()
        messagebox.showinfo(
            "Rotation Complete", "Tile rotated.\nRow colors have been reset to default."
        )
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} rotated 90 CW (colors reset).")

    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        first_pattern_row = current_pattern[0]
        first_color_row = current_colors[0]
        for i in range(TILE_HEIGHT - 1):
            current_pattern[i] = current_pattern[i + 1]
            current_colors[i] = current_colors[i + 1]
        current_pattern[TILE_HEIGHT - 1] = first_pattern_row
        current_colors[TILE_HEIGHT - 1] = first_color_row
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted up.")

    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        last_pattern_row = current_pattern[TILE_HEIGHT - 1]
        last_color_row = current_colors[TILE_HEIGHT - 1]
        for i in range(TILE_HEIGHT - 1, 0, -1):
            current_pattern[i] = current_pattern[i - 1]
            current_colors[i] = current_colors[i - 1]
        current_pattern[0] = last_pattern_row
        current_colors[0] = last_color_row
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted down.")

    def shift_tile_left(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        for r_idx in range(TILE_HEIGHT): # Renamed r to r_idx to avoid conflict
            row_data = current_pattern[r_idx]
            first_pixel = 0 # Default if TILE_WIDTH is 0
            if TILE_WIDTH > 0:
                first_pixel = row_data[0]
            for c in range(TILE_WIDTH - 1):
                row_data[c] = row_data[c + 1]
            if TILE_WIDTH > 0: # Ensure assignment only if width > 0
                row_data[TILE_WIDTH - 1] = first_pixel
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted left.")

    def shift_tile_right(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_pattern = tileset_patterns[current_tile_index]
        for r_idx in range(TILE_HEIGHT): # Renamed r to r_idx
            row_data = current_pattern[r_idx]
            last_pixel = 0 # Default if TILE_WIDTH is 0
            if TILE_WIDTH > 0:
                last_pixel = row_data[TILE_WIDTH - 1]
            for c in range(TILE_WIDTH - 1, 0, -1):
                row_data[c] = row_data[c - 1]
            if TILE_WIDTH > 0: # Ensure assignment only if width > 0
                row_data[0] = last_pixel
        
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        self._mark_project_modified()
        print(f"Tile {current_tile_index} shifted right.")

    # --- Supertile Editor Handlers ---
    def handle_st_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_tiles_in_set:
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def handle_supertile_def_click(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            messagebox.showwarning("Place Tile", "Please select a valid tile first.")
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile in the editor
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_display_size <= 0 or not canvas.winfo_exists():
            return

        # Calculate col and row in the definition grid based on pixel size of mini-tiles
        col = event.x // mini_tile_display_size
        row = event.y // mini_tile_display_size

        # Reset drag state
        self.last_placed_supertile_cell = None

        # _place_tile_in_supertile will use self.supertile_grid_width/height for its internal bounds check
        placed = self._place_tile_in_supertile(row, col)

        if placed:
            self.last_placed_supertile_cell = (row, col)

    def handle_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    # --- Map Editor Handlers ---
    def handle_map_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < num_supertiles:
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def _paint_map_cell(self, canvas_x, canvas_y):
        global map_data, last_painted_map_cell, selected_supertile_for_map

        # Get zoomed supertile pixel dimensions
        zoomed_st_w, zoomed_st_h = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_w <= 0 or zoomed_st_h <= 0:
            return

        # Calculate supertile column and row on the map
        c_map = int(canvas_x // zoomed_st_w)
        r_map = int(canvas_y // zoomed_st_h)

        if not (0 <= r_map < map_height and 0 <= c_map < map_width):
            return

        current_cell_id = (r_map, c_map)
        try:
            current_data_val = map_data[r_map][c_map]
        except IndexError:
            self.debug(f"  ERROR: IndexError accessing map_data[{r_map}][{c_map}]. Map size: {map_width}x{map_height}")
            return

        if current_cell_id != last_painted_map_cell: # Prevent re-painting same cell on static drag
            if current_data_val != selected_supertile_for_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                self._mark_project_modified()
                map_data[r_map][c_map] = selected_supertile_for_map # Update the data model
                
                self.draw_map_canvas() # This will re-render the viewport
                self.draw_minimap()    # Update minimap as well

            last_painted_map_cell = current_cell_id

    # --- Map Grid/Window Event Handlers ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()
        self.root.update_idletasks()
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES  # Use constant
            if not (min_w <= new_w <= max_w and min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Size",
                    f"Window width must be {min_w}-{max_w}, height {min_h}-{max_h}.",
                )
                # Reset entries to current state if invalid
                return

            # If size changed, redraw the map
            # (IntVar should already hold the value, no need to set self.window_view_tile_w/h directly)
            self.draw_map_canvas()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size() # Base tile (8x8 MSX) zoomed size
        if zoomed_tile_size <= 0:
            return

        delta_x = current_canvas_x - self.drag_start_x
        delta_y = current_canvas_y - self.drag_start_y

        delta_tile_x = round(delta_x / zoomed_tile_size)
        delta_tile_y = round(delta_y / zoomed_tile_size)

        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y
        
        # Max window position is based on total map tiles, not supertile grid directly here
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_tile_x_win = total_map_tiles_w - self.window_view_tile_w.get()
        max_tile_y_win = total_map_tiles_h - self.window_view_tile_h.get()
        
        # Ensure max is not negative if window is larger than map (should be prevented by other logic)
        max_tile_x_win = max(0, max_tile_x_win)
        max_tile_y_win = max(0, max_tile_y_win)

        clamped_tx = max(0, min(new_tx, max_tile_x_win))
        clamped_ty = max(0, min(new_ty, max_tile_y_win))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap during window drag

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th

        current_tile_x = round(current_canvas_x / zoomed_tile_size)
        current_tile_y = round(current_canvas_y / zoomed_tile_size)

        new_tx = start_tx
        new_ty = start_ty
        new_tw = start_tw
        new_th = start_th
        handle = self.window_view_resize_handle

        if "w" in handle:
            new_tx = min(current_tile_x, start_tx + start_tw - 1)
            new_tw = start_tw + (start_tx - new_tx)
        elif "e" in handle:
            new_tw = max(1, current_tile_x - start_tx + 1)

        if "n" in handle:
            new_ty = min(current_tile_y, start_ty + start_th - 1)
            new_th = start_th + (start_ty - new_ty)
        elif "s" in handle:
            new_th = max(1, current_tile_y - start_ty + 1)

        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        if "w" in handle and clamped_tw != new_tw:
            new_tx = start_tx + start_tw - clamped_tw
        if "n" in handle and clamped_th != new_th:
            new_ty = start_ty + start_th - clamped_th
        
        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_map_tile_x_for_win = total_map_tiles_w
        max_map_tile_y_for_win = total_map_tiles_h
        
        clamped_tx = max(0, min(new_tx, max_map_tile_x_for_win - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y_for_win - clamped_th))
        
        # Final check if clamping position changed dimensions again
        final_tw = min(clamped_tw, max_map_tile_x_for_win - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y_for_win - clamped_ty)
        final_tw = max(1, final_tw) # Ensure min width of 1
        final_th = max(1, final_th) # Ensure min height of 1


        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw # Use final_tw/th
            or self.window_view_tile_h.get() != final_th
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)
            self.window_view_tile_h.set(final_th)
            self.draw_map_canvas()
            self.draw_minimap() # Added to update minimap

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        if not self.show_window_view.get():
            return

        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height
        
        # Max top-left position for the window view
        max_win_pos_x = total_map_tiles_w - current_w
        max_win_pos_y = total_map_tiles_h - current_h
        
        # Ensure max is not negative if window is larger than map
        max_win_pos_x = max(0, max_win_pos_x)
        max_win_pos_y = max(0, max_win_pos_y)

        clamped_tx = max(0, min(new_tx, max_win_pos_x))
        clamped_ty = max(0, min(new_ty, max_win_pos_y))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus (WASD, G)."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "g":  # MODIFIED CHECK
            self.cycle_grid_color()
            return "break"  # Prevent other 'g' bindings
        elif self.show_window_view.get():  # Only move window if visible
            moved = False
            if key == "w":
                self.move_window_view_keyboard(0, -1)
                moved = True
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)
                moved = True
            elif key == "s":
                self.move_window_view_keyboard(0, 1)
                moved = True
            elif key == "d":
                self.move_window_view_keyboard(1, 0)
                moved = True

            if moved:
                return "break"

    # --- Map Zoom Handlers ---
    def handle_map_zoom_scroll(self, event):
        # Handles Ctrl+MouseWheel zooming, centered on cursor, with dynamic factor.
        canvas = self.map_canvas
        current_zoom = self.map_zoom_level # Get current zoom level

        # Determine dynamic zoom factor based on current_zoom
        factor = 0.0
        zoom_direction_in = (event.num == 4 or event.delta > 0) # True if zooming in

        if current_zoom < 0.25: # Zoomed out
            factor = 1.75 if zoom_direction_in else 1 / 1.75
        elif current_zoom < 0.75: # Zoomed out
            factor = 1.5 if zoom_direction_in else 1 / 1.5
        elif current_zoom < 1.5:  # Near 100%
            factor = 1.25 if zoom_direction_in else 1 / 1.25
        elif current_zoom < 3.0:  # Zoomed in
            factor = 1.15 if zoom_direction_in else 1 / 1.15
        else: # Very zoomed in
            factor = 1.1 if zoom_direction_in else 1 / 1.1
        
        if factor == 0.0: # Should not happen with the logic above, but as a safe guard
             self.debug("[DEBUG] handle_map_zoom_scroll: Factor is 0, aborting zoom.")
             return

        self.debug(f"[DEBUG] handle_map_zoom_scroll: Current zoom={current_zoom:.3f}, DirectionIn={zoom_direction_in}, Calculated factor={factor:.3f}")

        # Get mouse position relative to canvas content (scrolled coords)
        # These are the content coordinates of the point to keep fixed.
        zoom_x_canvas_content = canvas.canvasx(event.x)
        zoom_y_canvas_content = canvas.canvasy(event.y)

        # Perform zoom centered on the cursor using the determined factor
        # The zoom_map_at_point function already contains the logic to check
        # if the new zoom level will result in a visual change.
        self.zoom_map_at_point(factor, zoom_x_canvas_content, zoom_y_canvas_content)

    def change_map_zoom_mult(self, factor):
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        # Get current canvas view center
        cx = canvas.canvasx(canvas.winfo_width() / 2)
        cy = canvas.canvasy(canvas.winfo_height() / 2)
        # Zoom towards the center
        self.zoom_map_at_point(factor, cx, cy)

    def set_map_zoom(self, new_zoom_level):
        # Sets absolute zoom level, centered on current canvas center.
        min_zoom, max_zoom = 0.2, 6.0  # Definitive min_zoom
        
        try:
            requested_zoom_float = float(new_zoom_level)
        except ValueError:
            self.debug(f"[DEBUG] set_map_zoom: Invalid new_zoom_level '{new_zoom_level}'. Cannot convert to float.")
            return

        # Clamp the requested zoom to min/max bounds immediately
        safe_target_zoom = max(min_zoom, min(max_zoom, requested_zoom_float))
        
        current_actual_zoom = self.map_zoom_level

        self.debug(f"[DEBUG] set_map_zoom: Requested={requested_zoom_float:.4f}, SafeClampedTarget={safe_target_zoom:.4f}, CurrentActual={current_actual_zoom:.4f}")

        # Check if a significant change is even requested after clamping
        if abs(current_actual_zoom - safe_target_zoom) > 1e-9: 
            # Calculate the factor needed to get from current_actual_zoom to safe_target_zoom
            factor = 1.0
            if abs(current_actual_zoom) > 1e-9: # Avoid division by zero
                factor = safe_target_zoom / current_actual_zoom
            elif abs(safe_target_zoom) > 1e-9: # If current is ~0, but target isn't, it's a large change
                 # Factor doesn't make sense here, zoom_map_at_point will handle it by directly setting to potential_new_zoom_float
                 # We can pass a factor that will result in safe_target_zoom,
                 # or let zoom_map_at_point handle it if current_actual_zoom is too small for factor.
                 # The call to zoom_map_at_point will use its internal current_zoom_float.
                 # The factor is relative to *that*.
                 pass # zoom_map_at_point will effectively set it to safe_target_zoom via its own logic

            self.debug(f"[DEBUG] set_map_zoom: Factor to apply (approx): {factor:.4f}")
            
            canvas = self.map_canvas
            if not canvas or not canvas.winfo_exists(): return

            center_x_content = canvas.canvasx(canvas.winfo_width() / 2)
            center_y_content = canvas.canvasy(canvas.winfo_height() / 2)
            self.debug(f"[DEBUG] set_map_zoom: Centering on content coords: ({center_x_content:.2f}, {center_y_content:.2f})")
            
            # Call zoom_map_at_point. It will calculate its own potential_new_zoom_float
            # based on its current_zoom_float and the passed factor.
            # This potential_new_zoom_float should end up being very close to our safe_target_zoom.
            self.zoom_map_at_point(factor, center_x_content, center_y_content)
        else:
            # Zoom level is already very close to target, ensure UI label is accurate based on the actual state
            self.debug(f"[DEBUG] set_map_zoom: No significant change needed or already at target. Current zoom: {self.map_zoom_level*100:.1f}%")
            if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
                try:
                    self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
                except tk.TclError: pass

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size (base 8x8) based on zoom."""
        # Base size for 100% zoom is 8 pixels per tile edge
        zoomed_size = 8 * self.map_zoom_level
        # Ensure minimum size of 1 pixel
        return max(1, int(zoomed_size))

    def zoom_map_at_point(self, factor, zoom_x_canvas, zoom_y_canvas):
        # Zooms the map by 'factor', keeping the content point (zoom_x_canvas, zoom_y_canvas)
        # stationary relative to the viewport's top-left edge.
        # zoom_x_canvas and zoom_y_canvas are expected to be canvas *content* coordinates.

        canvas = self.map_canvas
        if not canvas or not canvas.winfo_exists(): # Check canvas existence early
            self.debug("[DEBUG] zoom_map_at_point: Canvas does not exist. Aborting.")
            return

        current_zoom_float = self.map_zoom_level 
        
        min_zoom, max_zoom = 0.2, 6.0 # Definitive min_zoom
        
        # Calculate potential new zoom after applying factor
        calculated_val_after_factor = current_zoom_float * factor
        # Apply clamping
        potential_new_zoom_float = max(min_zoom, min(max_zoom, calculated_val_after_factor))
        
        self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation Start ---")
        self.debug(f"[DEBUG] zoom_map_at_point: current_zoom_float={current_zoom_float:.4f}, factor={factor:.4f}")
        self.debug(f"[DEBUG] zoom_map_at_point: val_after_factor={calculated_val_after_factor:.4f}")
        self.debug(f"[DEBUG] zoom_map_at_point: potential_new_zoom_float (after all clamps min={min_zoom}, max={max_zoom})={potential_new_zoom_float:.4f}")

        base_display_size = TILE_WIDTH # Assuming TILE_WIDTH is the unscaled pixel size (e.g., 8)
        current_int_display_tile_size = max(1, int(base_display_size * current_zoom_float))
        potential_new_int_display_tile_size = max(1, int(base_display_size * potential_new_zoom_float))

        # Update the UI label with the (potentially clamped) new zoom level immediately
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            try:
                self.map_zoom_label.config(text=f"{int(potential_new_zoom_float * 100)}%")
            except tk.TclError: pass # Ignore if label is being destroyed

        # Determine if a full redraw is warranted
        force_redraw_due_to_int_size_change = (current_int_display_tile_size != potential_new_int_display_tile_size)
        
        relative_zoom_change_threshold = 0.03 # e.g., 3% change
        significant_relative_float_change = False
        if current_zoom_float > 1e-9: # Avoid division by zero for relative change
            if abs(potential_new_zoom_float - current_zoom_float) / current_zoom_float > relative_zoom_change_threshold:
                significant_relative_float_change = True
        elif abs(potential_new_zoom_float - current_zoom_float) > (relative_zoom_change_threshold * min_zoom): # Use absolute for very small current_zoom
             significant_relative_float_change = True


        # Check if the change is just floating point noise / too small to matter visually if int size doesn't change
        is_just_noise_or_too_small_without_int_change = abs(potential_new_zoom_float - current_zoom_float) < 1e-7

        if not force_redraw_due_to_int_size_change and \
           not significant_relative_float_change and \
           is_just_noise_or_too_small_without_int_change:
            # Only update internal float zoom if it's not just noise, to keep label consistent
            if not is_just_noise_or_too_small_without_int_change and abs(potential_new_zoom_float - current_zoom_float) > 1e-9 :
                 self.map_zoom_level = potential_new_zoom_float
            self.debug(f"[DEBUG] zoom_map_at_point: No significant visual change expected. Zoom for label: {potential_new_zoom_float*100:.1f}%. Actual self.map_zoom_level: {self.map_zoom_level*100:.1f}%. Skipping full redraw.")
            self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation End (Skipped Redraw) ---")
            return
        
        self.debug(f"[DEBUG] zoom_map_at_point: Proceeding with redraw. Old actual zoom: {current_zoom_float*100:.1f}%, New target zoom: {potential_new_zoom_float*100:.1f}%")
        self.debug(f"[DEBUG] zoom_map_at_point: Old int size: {current_int_display_tile_size}, New int size: {potential_new_int_display_tile_size}")
        self.debug(f"[DEBUG] zoom_map_at_point: SignificantRelFloatChange: {significant_relative_float_change}, ForceIntSizeChange: {force_redraw_due_to_int_size_change}")

        # Update the actual application zoom level state
        old_zoom_for_scale_calc = current_zoom_float # Use the float value before it's updated by self.map_zoom_level
        self.map_zoom_level = potential_new_zoom_float # This is the new definitive zoom level
        
        scale_change = 1.0 # Default if old zoom was zero or too small
        if abs(old_zoom_for_scale_calc) > 1e-9 : # Avoid division by zero or huge scale_change from tiny old_zoom
            scale_change = self.map_zoom_level / old_zoom_for_scale_calc
        elif abs(self.map_zoom_level) > 1e-9 : # If old zoom was ~0 but new one isn't, it's essentially a fresh scale
            pass # scale_change remains 1.0 which means no relative scaling for scroll adjustment, absolute positioning will take over

        self.debug(f"[DEBUG] zoom_map_at_point: self.map_zoom_level NOW = {self.map_zoom_level:.4f}, scale_change = {scale_change:.4f}")

        # --- Scroll adjustment logic to keep zoom_x_canvas, zoom_y_canvas fixed ---
        # (zoom_x_canvas, zoom_y_canvas) are the content coordinates of the point under the cursor (or center)
        
        current_view_x1 = canvas.canvasx(0) # Content X at left edge of viewport BEFORE scroll
        current_view_y1 = canvas.canvasy(0) # Content Y at top edge of viewport BEFORE scroll

        # The point (zoom_x_canvas, zoom_y_canvas) is currently at screen offset:
        # screen_offset_x = zoom_x_canvas - current_view_x1
        # screen_offset_y = zoom_y_canvas - current_view_y1
        # After zoom, we want this same screen_offset to correspond to the new scaled content point.
        # new_content_point_x = zoom_x_canvas * scale_change (This is conceptual, coordinates don't just multiply)
        # The new scroll position (target_new_view_x1) should be such that:
        # target_new_view_x1 + screen_offset_x = (new position of zoom_x_canvas after scaling effect)
        # A common formula: target_scroll = fixed_point_content_coord - (screen_offset_of_fixed_point / new_zoom_level_relative_to_screen_pixels)
        # Simplified: keep the relative position of zoom_x_canvas within the viewport the same.
        # screen_offset_x / viewport_width_old_zoom = (zoom_x_canvas * scale_change - target_new_view_x1) / viewport_width_new_zoom
        # This is still more complex than needed if we use the formula:
        target_new_view_x1 = zoom_x_canvas - ((zoom_x_canvas - current_view_x1) / scale_change) if abs(scale_change) > 1e-9 else current_view_x1
        target_new_view_y1 = zoom_y_canvas - ((zoom_y_canvas - current_view_y1) / scale_change) if abs(scale_change) > 1e-9 else current_view_y1
        
        # --- Recalculate total map dimensions AT THE NEW self.map_zoom_level ---
        new_zoomed_st_w, new_zoomed_st_h = self._get_zoomed_supertile_pixel_dims() # Uses current self.map_zoom_level
        map_total_pixel_width_new_zoom = map_width * new_zoomed_st_w
        map_total_pixel_height_new_zoom = map_height * new_zoomed_st_h
        
        safe_map_total_w = max(1.0, float(map_total_pixel_width_new_zoom))
        safe_map_total_h = max(1.0, float(map_total_pixel_height_new_zoom))

        target_frac_x = target_new_view_x1 / safe_map_total_w if safe_map_total_w > 0 else 0.0
        target_frac_y = target_new_view_y1 / safe_map_total_h if safe_map_total_h > 0 else 0.0

        canvas_widget_width = canvas.winfo_width()
        canvas_widget_height = canvas.winfo_height()

        # Calculate max fraction to prevent scrolling beyond content edges
        max_frac_x = 0.0
        if safe_map_total_w > canvas_widget_width:
            max_frac_x = (safe_map_total_w - canvas_widget_width) / safe_map_total_w
        
        max_frac_y = 0.0
        if safe_map_total_h > canvas_widget_height:
            max_frac_y = (safe_map_total_h - canvas_widget_height) / safe_map_total_h
        
        final_frac_x = max(0.0, min(target_frac_x, max_frac_x))
        final_frac_y = max(0.0, min(target_frac_y, max_frac_y))
        
        self.debug(f"[DEBUG] zoom_map_at_point: Scroll Adjust: target_new_view=({target_new_view_x1:.2f},{target_new_view_y1:.2f}), "
                   f"target_frac=({target_frac_x:.4f},{target_frac_y:.4f}), max_frac=({max_frac_x:.4f},{max_frac_y:.4f}), final_frac=({final_frac_x:.4f},{final_frac_y:.4f})")

        # Apply the scroll before drawing
        # Only call xview_moveto/yview_moveto if the canvas scrollable area is larger than the viewport
        if safe_map_total_w > 0: # and safe_map_total_w > canvas_widget_width: # Optional: only if scrollable
            canvas.xview_moveto(final_frac_x)
        if safe_map_total_h > 0: # and safe_map_total_h > canvas_widget_height: # Optional
            canvas.yview_moveto(final_frac_y)
        
        self.draw_map_canvas() 
        self.draw_minimap()
        self.debug(f"[DEBUG] zoom_map_at_point: --- Zoom Calculation End (Redraw Performed) ---")

    # --- File Menu Commands ---
    # ... (new_project, save/load tileset/supertile/map remain mostly unchanged,
    #      ensure new_project resets new state like grid toggles, window view) ...
    def new_project(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        global supertiles_data, current_supertile_index, num_supertiles, selected_tile_for_supertile
        global map_data, map_width, map_height, selected_supertile_for_map, last_painted_map_cell
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data

        confirm_new = True
        if self.project_modified:
            confirm_new = messagebox.askokcancel(
                "New Project", "Discard all current unsaved changes and start new?"
            )

        if confirm_new:
            # --- Get New Supertile Dimensions ---
            temp_st_width = self.supertile_grid_width # Store current to revert if dialog cancelled
            temp_st_height = self.supertile_grid_height

            new_dim_w_str = simpledialog.askstring(
                "New Supertile Width",
                "Enter supertile grid width (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_width)
            )
            if new_dim_w_str is None: return # User cancelled

            try:
                new_dim_w = int(new_dim_w_str)
                if not (1 <= new_dim_w <= 32):
                    messagebox.showerror("Invalid Width", "Width must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Width must be a whole number.", parent=self.root)
                return

            new_dim_h_str = simpledialog.askstring(
                "New Supertile Height",
                "Enter supertile grid height (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_height)
            )
            if new_dim_h_str is None: return # User cancelled
            
            try:
                new_dim_h = int(new_dim_h_str)
                if not (1 <= new_dim_h <= 32):
                    messagebox.showerror("Invalid Height", "Height must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Height must be a whole number.", parent=self.root)
                return

            self.supertile_grid_width = new_dim_w
            self.supertile_grid_height = new_dim_h
            print(f"New project: Supertile dimensions set to {self.supertile_grid_width}W x {self.supertile_grid_height}H.")
            # --- End Get New Supertile Dimensions ---

            self._clear_marked_unused(trigger_redraw=False)

            tileset_patterns = [
                [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)] for _ in range(MAX_TILES)
            ]
            tileset_colors = [
                [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
                for _ in range(MAX_TILES)
            ]
            current_tile_index = 0
            num_tiles_in_set = 1
            selected_tile_for_supertile = 0

            # Initialize supertiles_data with new dimensions
            supertiles_data = [
                [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                for _st in range(MAX_SUPERTILES)
            ]
            current_supertile_index = 0
            num_supertiles = 1
            selected_supertile_for_map = 0

            map_width = DEFAULT_MAP_WIDTH
            map_height = DEFAULT_MAP_HEIGHT
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
            last_painted_map_cell = None

            tile_clipboard_pattern = None
            tile_clipboard_colors = None
            supertile_clipboard_data = None # This needs to be aware of ST dimensions if copied
            self.map_clipboard_data = None

            self.active_msx_palette = []
            for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
                 self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
            self.selected_palette_slot = 0
            global selected_color_index
            selected_color_index = WHITE_IDX

            self.map_zoom_level = 1.0
            self.show_supertile_grid.set(False)
            self.show_window_view.set(False)
            self.grid_color_index = 1
            self.window_view_tile_x = 0
            self.window_view_tile_y = 0
            self.window_view_tile_w.set(DEFAULT_WIN_VIEW_WIDTH_TILES)
            self.window_view_tile_h.set(DEFAULT_WIN_VIEW_HEIGHT_TILES)
            self.current_mouse_action = None
            self.window_view_resize_handle = None

            self._clear_map_selection()
            self._clear_paste_preview_rect()
            self.is_shift_pressed = False
            self.is_ctrl_pressed = False

            self.current_project_base_path = None
            self.project_modified = False # Reset modified flag AFTER asking and getting dimensions
            self._update_window_title()

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            
            # Reconfigure supertile definition canvas size if it exists
            self._reconfigure_supertile_definition_canvas()
            
            self._trigger_minimap_reconfigure() # In case map proportions change due to ST dim change
            self.update_all_displays(changed_level="all")

            self._update_editor_button_states()
            self._update_edit_menu_state()
            self._update_supertile_rotate_button_state() # Update based on new dimensions

    def save_palette(self, filepath=None):
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Pal", # UPDATED Extension
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("All Files", "*.*")], # UPDATED Description and Extension
                title="Save SC4 Palette As...", # UPDATED Title
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                if len(self.active_msx_palette) != 16:
                    self.debug("ERROR: Active palette length is not 16 during save!")
                    if filepath is None:
                        messagebox.showerror(
                            "Palette Error",
                            "Internal Error: Active palette does not contain 16 colors.",
                        )
                    return False

                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)

                for i in range(16):
                    hex_color = self.active_msx_palette[i]
                    r, g, b = self._hex_to_rgb7(hex_color)
                    packed_bytes = struct.pack("BBB", r, g, b)
                    f.write(packed_bytes)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Palette saved successfully to {os.path.basename(save_path)}",
                )
            return True

        except Exception as e:
            messagebox.showerror(
                "Save Palette Error",
                f"Failed to save palette file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_palette(self, filepath=None):
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("Old MSX Palette File", "*.msxpal"), ("All Files", "*.*")], # UPDATED
                title="Open SC4 Palette", # UPDATED
            )
        if not load_path:
            return False

        try:
            expected_color_data_size = 16 * 3  # 48 bytes for colors
            new_palette_hex = []
            
            # Determine file size to infer format (old .msxpal vs new .SC4Pal with reserved bytes)
            try:
                file_size = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            is_new_format_with_reserved_bytes = False
            expected_size_new = RESERVED_BYTES_COUNT + expected_color_data_size # 4 + 48 = 52
            expected_size_old = expected_color_data_size # 48

            if file_size == expected_size_new:
                is_new_format_with_reserved_bytes = True
                self.debug(f"Info: Detected new format SC4Pal file (size {file_size} with reserved bytes).")
            elif file_size == expected_size_old:
                is_new_format_with_reserved_bytes = False # Old format, no reserved bytes
                self.debug(f"Info: Detected old format msxpal/SC4Pal file (size {file_size} without reserved bytes).")
            else:
                raise ValueError(
                    f"Invalid file size for palette. Expected {expected_size_old} (old) or {expected_size_new} (new) bytes, got {file_size}."
                )

            with open(load_path, "rb") as f:
                if is_new_format_with_reserved_bytes:
                    # --- ADDED: Read and discard reserved bytes from the BEGINNING ---
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("EOF while reading reserved bytes from new format palette file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from palette file.")
                    # --- END ADDED ---
                
                # Read the 48 bytes of color data
                palette_data_bytes = f.read(expected_color_data_size)
                if len(palette_data_bytes) < expected_color_data_size:
                    raise EOFError(
                        f"Not enough data for palette colors. Expected {expected_color_data_size}, got {len(palette_data_bytes)}."
                    )

                for i in range(16):
                    offset = i * 3
                    if offset + 3 > len(palette_data_bytes): 
                        raise struct.error("Not enough bytes in color data block for unpacking.")
                    r_val, g_val, b_val = struct.unpack_from("BBB", palette_data_bytes, offset)

                    if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                        self.debug(
                            f"Warning: Invalid RGB ({r_val},{g_val},{b_val}) at slot {i} in '{os.path.basename(load_path)}'. Clamping."
                        )
                        r_val = max(0, min(7, r_val))
                        g_val = max(0, min(7, g_val))
                        b_val = max(0, min(7, b_val))
                    hex_color = self._rgb7_to_hex(r_val, g_val, b_val)
                    new_palette_hex.append(hex_color)
                
                # Check for any further unexpected data
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Palette file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm = True
            if filepath is None:
                confirm = messagebox.askokcancel(
                    "Load Palette",
                    "Replace the current active palette with data from this file?",
                )

            if confirm:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self.active_msx_palette = new_palette_hex
                self.selected_palette_slot = 0
                global selected_color_index 
                selected_color_index = WHITE_IDX
                
                self.clear_all_caches()
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all")
                
                if filepath is None:
                    try: 
                        if self.notebook and self.notebook.winfo_exists() and self.tab_palette_editor.winfo_exists():
                             self.notebook.select(self.tab_palette_editor)
                    except tk.TclError:
                        self.debug("[DEBUG] open_palette: TclError selecting palette editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded palette from {os.path.basename(load_path)}",
                    )
                if filepath is None:
                    self._mark_project_modified()
                return True
            else:
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (struct.error, ValueError, EOFError) as e:
            messagebox.showerror(
                "Open Palette Error",
                f"Invalid data, size, or format in palette file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Palette Error",
                f"Failed to open or parse palette file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_tileset(self, filepath=None):
        global num_tiles_in_set, tileset_patterns, tileset_colors # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Tiles",
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Save Tileset As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                tiles_to_write_count = num_tiles_in_set

                header_byte_value = 0 if tiles_to_write_count == 256 else tiles_to_write_count
                if not (0 <= header_byte_value <= 255):
                    self.debug(f"[DEBUG] save_tileset: Invalid header_byte_value {header_byte_value} for num_tiles_in_set {tiles_to_write_count}")
                    raise ValueError(f"Calculated header byte value {header_byte_value} is out of 0-255 range.")
                
                num_byte_header = struct.pack("B", header_byte_value)
                f.write(num_byte_header)

                # --- ADDED: Write reserved bytes after the header ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---

                # --- Write ALL pattern data first ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_patterns): 
                        self.debug(f"[DEBUG] save_tileset: Warning - num_tiles_in_set ({tiles_to_write_count}) > len(tileset_patterns). Stopping pattern write at tile {i}.")
                        # Pad remaining patterns for this block if this happens, to keep file structure valid
                        # This assumes we must write pattern data for all 'tiles_to_write_count'
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                f.write(struct.pack("B", 0)) # Write blank pattern row
                        break 
                    pattern = tileset_patterns[i]
                    for r in range(TILE_HEIGHT):
                        byte_val = 0
                        if r < len(pattern):
                            row_pattern = pattern[r]
                            for c in range(TILE_WIDTH):
                                if c < len(row_pattern) and row_pattern[c] == 1:
                                    byte_val = byte_val | (1 << (7 - c))
                        pattern_byte = struct.pack("B", byte_val)
                        f.write(pattern_byte)
                
                # --- Then, write ALL color data ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_colors):
                        self.debug(f"[DEBUG] save_tileset: Warning - num_tiles_in_set ({tiles_to_write_count}) > len(tileset_colors). Stopping color write at tile {i}.")
                        # Pad remaining colors for this block
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                default_color_byte = ((WHITE_IDX & 0x0F) << 4) | (BLACK_IDX & 0x0F)
                                f.write(struct.pack("B", default_color_byte))
                        break
                    colors = tileset_colors[i]
                    for r in range(TILE_HEIGHT):
                        fg_idx, bg_idx = (WHITE_IDX, BLACK_IDX) 
                        if r < len(colors):
                           fg_idx, bg_idx = colors[r]
                        
                        safe_fg_idx = max(0, min(15, fg_idx))
                        safe_bg_idx = max(0, min(15, bg_idx))

                        color_byte_val = ((safe_fg_idx & 0x0F) << 4) | (safe_bg_idx & 0x0F)
                        color_byte = struct.pack("B", color_byte_val)
                        f.write(color_byte)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Tileset saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Tileset Error",
                f"Failed to save tileset file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_tileset(self, filepath=None):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set, selected_tile_for_supertile # Using globals
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Open Tileset",
            )
        if not load_path:
            return False

        try:
            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                num_tiles_header_byte_val = f.read(1)
                if not num_tiles_header_byte_val:
                    raise ValueError("File empty or missing tile count header byte.")
                
                header_value = struct.unpack("B", num_tiles_header_byte_val)[0]
                loaded_num_tiles = 256 if header_value == 0 else header_value

                if not (1 <= loaded_num_tiles <= MAX_TILES):
                    raise ValueError(
                        f"Invalid tile count derived from file: {loaded_num_tiles} (must be 1-{MAX_TILES})"
                    )

                # Calculate expected sizes for old and new formats
                # Pattern data: loaded_num_tiles * TILE_HEIGHT bytes
                # Color data: loaded_num_tiles * TILE_HEIGHT bytes
                expected_data_block_size = (loaded_num_tiles * TILE_HEIGHT) + (loaded_num_tiles * TILE_HEIGHT)
                expected_total_size_new_format = 1 + RESERVED_BYTES_COUNT + expected_data_block_size
                expected_total_size_old_format = 1 + expected_data_block_size

                has_reserved_bytes_to_read = False
                if file_size_check == expected_total_size_new_format:
                    has_reserved_bytes_to_read = True
                    self.debug(f"Info: Tileset file '{os.path.basename(load_path)}' matches new format size (with reserved bytes).")
                elif file_size_check == expected_total_size_old_format:
                    has_reserved_bytes_to_read = False
                    self.debug(f"Info: Tileset file '{os.path.basename(load_path)}' matches old format size (no reserved bytes).")
                else:
                    raise ValueError(
                        f"Tileset file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for {loaded_num_tiles} tiles. Expected {expected_total_size_old_format} (old format) "
                        f"or {expected_total_size_new_format} (new format)."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format tileset file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from tileset file.")
                # If not has_reserved_bytes_to_read, file pointer is correct for old format.

                new_patterns = [
                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]
                new_colors = [
                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    for _i in range(MAX_TILES)
                ]

                bytes_per_tile_pattern = TILE_HEIGHT
                total_pattern_bytes_to_read = loaded_num_tiles * bytes_per_tile_pattern
                
                all_pattern_data_bytes = f.read(total_pattern_bytes_to_read)
                if len(all_pattern_data_bytes) < total_pattern_bytes_to_read:
                    raise EOFError(f"EOF while reading pattern data block. Expected {total_pattern_bytes_to_read}, got {len(all_pattern_data_bytes)}.")

                current_byte_offset_pattern = 0
                for i in range(loaded_num_tiles):
                    tile_pattern_bytes = all_pattern_data_bytes[current_byte_offset_pattern : current_byte_offset_pattern + bytes_per_tile_pattern]
                    if len(tile_pattern_bytes) < bytes_per_tile_pattern: # Should not happen if total read was enough
                        tile_pattern_bytes += bytes(bytes_per_tile_pattern - len(tile_pattern_bytes))
                        
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_pattern_bytes[r_idx]
                        for c in range(TILE_WIDTH):
                            pixel_bit = (byte_val >> (7 - c)) & 1
                            new_patterns[i][r_idx][c] = pixel_bit
                    current_byte_offset_pattern += bytes_per_tile_pattern
                
                bytes_per_tile_colors = TILE_HEIGHT
                total_color_bytes_to_read = loaded_num_tiles * bytes_per_tile_colors

                all_color_data_bytes = f.read(total_color_bytes_to_read)
                if len(all_color_data_bytes) < total_color_bytes_to_read:
                    raise EOFError(f"EOF while reading color data block. Expected {total_color_bytes_to_read}, got {len(all_color_data_bytes)}.")

                current_byte_offset_colors = 0
                for i in range(loaded_num_tiles):
                    tile_color_bytes = all_color_data_bytes[current_byte_offset_colors : current_byte_offset_colors + bytes_per_tile_colors]
                    if len(tile_color_bytes) < bytes_per_tile_colors: # Should not happen
                         tile_color_bytes += bytes(bytes_per_tile_colors - len(tile_color_bytes))

                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        if not (0 <= fg_idx < 16 and 0 <= bg_idx < 16):
                            new_colors[i][r_idx] = (WHITE_IDX, BLACK_IDX)
                        else:
                            new_colors[i][r_idx] = (fg_idx, bg_idx)
                    current_byte_offset_colors += bytes_per_tile_colors
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Tileset file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm = True
            if filepath is None:
                confirm = messagebox.askokcancel(
                    "Load Tileset",
                    f"Replace current tileset with {loaded_num_tiles} tile(s) from this file?",
                )

            if confirm:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Redraw handled by update_all_displays
                
                # Ensure global lists are ready (should be MAX_TILES long from init)
                for i in range(loaded_num_tiles):
                    tileset_patterns[i] = new_patterns[i]
                    tileset_colors[i] = new_colors[i]
                # If fewer tiles loaded than currently in set, clear out the rest
                if num_tiles_in_set > loaded_num_tiles:
                    for i in range(loaded_num_tiles, num_tiles_in_set):
                        tileset_patterns[i] = [[0] * TILE_WIDTH for _r_clear in range(TILE_HEIGHT)]
                        tileset_colors[i] = [(WHITE_IDX, BLACK_IDX) for _r_clear in range(TILE_HEIGHT)]
                
                num_tiles_in_set = loaded_num_tiles
                
                current_tile_index = max(
                    0, min(current_tile_index, num_tiles_in_set - 1)
                )
                selected_tile_for_supertile = max(
                    0, min(selected_tile_for_supertile, num_tiles_in_set - 1)
                )

                self.clear_all_caches()
                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()
                self._update_edit_menu_state()

                if filepath is None:
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_tile_editor.winfo_exists():
                            self.notebook.select(self.tab_tile_editor)
                    except tk.TclError:
                        self.debug("[DEBUG] open_tileset: TclError selecting tile editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_tiles_in_set} tiles from {os.path.basename(load_path)}",
                    )
                if filepath is None: # Only mark modified if opened interactively
                    self._mark_project_modified()
                return True
            else: # User cancelled confirmation dialog
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e: # ValueError includes our custom size/format checks
            messagebox.showerror(
                "Open Tileset Error",
                f"Invalid data, size, or format in tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Tileset Error",
                f"Failed to open or parse tileset file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_supertiles(self, filepath=None):
        global num_supertiles, supertiles_data # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Super",
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Save Supertiles As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # --- MODIFIED: Write count of supertiles (hybrid 1-byte/3-byte) ---
                # num_supertiles is the actual count (1 to MAX_SUPERTILES)
                if 1 <= num_supertiles <= 255:
                    f.write(struct.pack("B", num_supertiles))
                elif 256 <= num_supertiles <= MAX_SUPERTILES: # MAX_SUPERTILES is now 65535
                    f.write(struct.pack("B", 0)) # Indicator byte
                    f.write(struct.pack(">H", num_supertiles)) # 2-byte unsigned short for actual count
                else:
                    # This case should not be reached if num_supertiles is always valid (e.g. 0 not allowed)
                    self.debug(f"[DEBUG] save_supertiles: Invalid num_supertiles value ({num_supertiles}) for saving.")
                    raise ValueError(f"num_supertiles ({num_supertiles}) out of expected range for saving.")
                # --- END MODIFIED ---
                
                # Write supertile grid dimensions (these remain 1 byte each)
                f.write(struct.pack("B", self.supertile_grid_width))
                f.write(struct.pack("B", self.supertile_grid_height))

                # --- ADDED: Write reserved bytes after headers and dimensions ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---
                
                tiles_per_definition = self.supertile_grid_width * self.supertile_grid_height
                if tiles_per_definition <= 0 and num_supertiles > 0 : # Defensive check for invalid grid dims
                    self.debug(f"[DEBUG] save_supertiles: Invalid supertile dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}), cannot save data.")
                    raise ValueError("Supertile dimensions are zero or negative, cannot save definition data.")

                # Write data for each supertile
                for i in range(num_supertiles): # Iterate up to the actual number of supertiles
                    if i >= len(supertiles_data): # Safety break
                        self.debug(f"[DEBUG] save_supertiles: Warning - num_supertiles ({num_supertiles}) > len(supertiles_data). Stopping ST data write at ST {i}.")
                        # Pad remaining ST definitions if this happens
                        for _ in range(num_supertiles - i):
                            for _ in range(tiles_per_definition):
                                f.write(struct.pack("B", 0)) # Write 0 for each tile index
                        break
                    
                    definition = supertiles_data[i]
                    
                    # Ensure definition matches project dimensions before writing
                    # Pad/truncate row or cells if necessary for robustness, though ideally data is consistent
                    for r_st in range(self.supertile_grid_height):
                        if r_st < len(definition): # Row exists
                            row_data = definition[r_st]
                            for c_st in range(self.supertile_grid_width):
                                tile_index_val = 0 # Default if cell missing
                                if c_st < len(row_data): # Cell exists
                                    tile_index_val = row_data[c_st]
                                # Ensure tile_index_val is within byte range (0-255) as it's packed as "B"
                                safe_tile_index_val = max(0, min(255, tile_index_val))
                                if tile_index_val != safe_tile_index_val:
                                    self.debug(f"[DEBUG] save_supertiles: Clamping tile index {tile_index_val} to {safe_tile_index_val} in ST {i} at ({r_st},{c_st}).")
                                f.write(struct.pack("B", safe_tile_index_val))
                        else: # Row missing, pad entire row with 0s
                            for _ in range(self.supertile_grid_width):
                                f.write(struct.pack("B", 0))
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Supertiles saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Supertile Error",
                f"Failed to save supertiles file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_supertiles(self, filepath=None, is_part_of_project_load=False): # Added is_part_of_project_load
        global supertiles_data, num_supertiles, current_supertile_index, selected_supertile_for_map, num_tiles_in_set 
        load_path = filepath
        if not load_path:
            # Only ask for file if not part of project load and no path given
            if not is_part_of_project_load:
                load_path = filedialog.askopenfilename(
                    filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                    title="Open Supertiles",
                )
            if not load_path: # If still no load_path (user cancelled or was project load with no path)
                return False

        try:
            loaded_grid_width_from_file = 0
            loaded_grid_height_from_file = 0
            loaded_num_st_from_file = 0
            temp_supertiles_data_from_file = []
            header_size_st_calc = 0 

            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                first_count_byte_val = f.read(1)
                if not first_count_byte_val:
                    raise ValueError("File empty or missing supertile count byte(s).")
                
                indicator_byte = struct.unpack("B", first_count_byte_val)[0]
                header_size_st_calc += 1 

                if indicator_byte == 0: 
                    count_bytes_short = f.read(2)
                    if len(count_bytes_short) < 2:
                        raise EOFError("EOF reading 2-byte supertile count after indicator.")
                    loaded_num_st_from_file = struct.unpack(">H", count_bytes_short)[0]
                    header_size_st_calc += 2 
                else: 
                    loaded_num_st_from_file = indicator_byte
                
                if not (0 <= loaded_num_st_from_file <= MAX_SUPERTILES):
                    raise ValueError(
                        f"Invalid supertile count in file: {loaded_num_st_from_file} (must be 0-{MAX_SUPERTILES})"
                    )
                
                dim_w_byte = f.read(1)
                dim_h_byte = f.read(1)
                if not dim_w_byte or not dim_h_byte:
                    raise EOFError("File missing supertile dimension bytes.")
                
                loaded_grid_width_from_file = struct.unpack("B", dim_w_byte)[0]
                loaded_grid_height_from_file = struct.unpack("B", dim_h_byte)[0]
                header_size_st_calc += 2 

                if not (1 <= loaded_grid_width_from_file <= 32 and 1 <= loaded_grid_height_from_file <= 32):
                    if loaded_num_st_from_file == 0 and loaded_grid_width_from_file == 0 and loaded_grid_height_from_file == 0:
                        pass 
                    else:
                        raise ValueError(f"Invalid supertile dimensions in file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")

                tiles_per_definition_calc = loaded_grid_width_from_file * loaded_grid_height_from_file
                expected_data_payload_size_st = loaded_num_st_from_file * tiles_per_definition_calc 
                
                expected_size_old_format_st = header_size_st_calc + expected_data_payload_size_st
                expected_size_new_format_st = header_size_st_calc + RESERVED_BYTES_COUNT + expected_data_payload_size_st

                has_reserved_bytes_to_read = False
                if file_size_check == expected_size_new_format_st:
                    has_reserved_bytes_to_read = True
                    self.debug(f"Info: Supertile file '{os.path.basename(load_path)}' matches new format size.")
                elif file_size_check == expected_size_old_format_st:
                    has_reserved_bytes_to_read = False
                    self.debug(f"Info: Supertile file '{os.path.basename(load_path)}' matches old format size.")
                else:
                    raise ValueError(
                        f"Supertile file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for {loaded_num_st_from_file} supertiles ({loaded_grid_width_from_file}x{loaded_grid_height_from_file}). "
                        f"Expected old: {expected_size_old_format_st}, Expected new: {expected_size_new_format_st}."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format supertile file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from supertile file.")

                if loaded_num_st_from_file > 0:
                    temp_supertiles_data_from_file = [
                        [[0 for _c in range(loaded_grid_width_from_file)] for _r in range(loaded_grid_height_from_file)]
                        for _st in range(loaded_num_st_from_file)
                    ]
                    
                    bytes_per_definition_read = tiles_per_definition_calc 

                    for i in range(loaded_num_st_from_file):
                        st_bytes_read = f.read(bytes_per_definition_read)
                        if len(st_bytes_read) < bytes_per_definition_read:
                            raise EOFError(f"EOF reading data for supertile {i}. Expected {bytes_per_definition_read}, got {len(st_bytes_read)}.")
                        
                        byte_idx_val = 0
                        for r_load in range(loaded_grid_height_from_file):
                            for c_load in range(loaded_grid_width_from_file):
                                tile_idx_read = st_bytes_read[byte_idx_val] 
                                byte_idx_val += 1
                                if not (0 <= tile_idx_read <= 255): 
                                    self.debug(f"Warning: Invalid Tile index byte {tile_idx_read} in Supertile {i} at [{r_load},{c_load}]. Resetting to 0.")
                                    temp_supertiles_data_from_file[i][r_load][c_load] = 0
                                else:
                                    temp_supertiles_data_from_file[i][r_load][c_load] = tile_idx_read
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Supertile file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm_load = True
            # Only ask for overall confirmation if it's a standalone open and not part of project load
            if not is_part_of_project_load and filepath is None: 
                confirm_load = messagebox.askokcancel(
                    "Load Supertiles",
                    f"Replace current supertiles with {loaded_num_st_from_file} definition(s) from this file?\n(File Dimensions: {loaded_grid_width_from_file}W x {loaded_grid_height_from_file}H)",
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass 

                # Dimension mismatch confirmation only for standalone open
                if not is_part_of_project_load and \
                   (self.supertile_grid_width != loaded_grid_width_from_file or \
                    self.supertile_grid_height != loaded_grid_height_from_file):
                    dim_confirm = messagebox.askokcancel(
                        "Dimension Mismatch",
                        f"Supertile dimensions in file ({loaded_grid_width_from_file}x{loaded_grid_height_from_file}) "
                        f"differ from current project ({self.supertile_grid_width}x{self.supertile_grid_height}).\n\n"
                        "Loading will change project's supertile dimensions. This may affect existing supertile data and map. Continue?",
                        icon="warning"
                    )
                    if not dim_confirm:
                        return False 
                
                # This block now executes if:
                # 1. It's part of project load (is_part_of_project_load=True), OR
                # 2. It's standalone, and user confirmed overall load, AND (if dimensions differed) user confirmed dimension change.
                # It means we are committed to adopting the file's dimensions if they are different.
                if self.supertile_grid_width != loaded_grid_width_from_file or \
                   self.supertile_grid_height != loaded_grid_height_from_file:
                    self.debug(f"[DEBUG] open_supertiles: Adopting ST dimensions from file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")
                    self.supertile_grid_width = loaded_grid_width_from_file
                    self.supertile_grid_height = loaded_grid_height_from_file
                    # Re-initialize global supertiles_data to the new dimensions, clearing old content.
                    # MAX_SUPERTILES is the capacity.
                    supertiles_data = [
                        [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                        for _st_init in range(MAX_SUPERTILES) 
                    ]
                    self.clear_all_caches() # Critical after dimension change
                    self._reconfigure_supertile_definition_canvas() # Update definition canvas size
                    # Note: map data is not "converted" here. It will be re-read by open_map if part of project load.
                    # If standalone, the existing map will now be interpreted with new ST cell sizes.
                
                # Apply loaded data
                for i in range(loaded_num_st_from_file):
                    if i < MAX_SUPERTILES: # Ensure we don't write past allocated global list
                        # temp_supertiles_data_from_file was created with file's dimensions
                        # And supertiles_data was just re-initialized to these same dimensions if they changed.
                        supertiles_data[i] = temp_supertiles_data_from_file[i]
                    else: break # Should not happen if loaded_num_st_from_file <= MAX_SUPERTILES
                
                # If fewer supertiles were loaded than currently exist in project (e.g. standalone load of smaller set)
                if num_supertiles > loaded_num_st_from_file:
                    for i in range(loaded_num_st_from_file, num_supertiles):
                        if i < MAX_SUPERTILES: # Ensure index is valid
                             supertiles_data[i] = [[0]*self.supertile_grid_width for _r_clear in range(self.supertile_grid_height)]

                num_supertiles = loaded_num_st_from_file
                if num_supertiles == 0 and MAX_SUPERTILES > 0 : # Ensure at least one ST if max allows
                    num_supertiles = 1 
                    if supertiles_data: # Should exist if MAX_SUPERTILES > 0
                         supertiles_data[0] = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                
                current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
                selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))
                
                max_valid_tile_idx = num_tiles_in_set - 1
                for st_idx_val in range(num_supertiles):
                    for r_val in range(self.supertile_grid_height):
                        for c_val in range(self.supertile_grid_width):
                            if supertiles_data[st_idx_val][r_val][c_val] > max_valid_tile_idx:
                                self.debug(f"Warning: Supertile {st_idx_val} [{r_val},{c_val}] references tile {supertiles_data[st_idx_val][r_val][c_val]}, "
                                           f"which is out of bounds for current tileset size ({num_tiles_in_set}). Resetting to 0.")
                                supertiles_data[st_idx_val][r_val][c_val] = 0

                self.supertile_image_cache.clear() 
                self.map_render_cache.clear()      
                self.invalidate_minimap_background_cache()
                
                self.update_all_displays(changed_level="all")
                self._update_editor_button_states()
                self._update_edit_menu_state()
                self._update_supertile_rotate_button_state() 

                if not is_part_of_project_load and filepath is None: # Message for standalone interactive open
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_supertile_editor.winfo_exists():
                            self.notebook.select(self.tab_supertile_editor)
                    except tk.TclError:
                         self.debug("[DEBUG] open_supertiles: TclError selecting supertile editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {num_supertiles} supertiles ({self.supertile_grid_width}x{self.supertile_grid_height}) from {os.path.basename(load_path)}",
                    )
                
                # Mark modified only for standalone interactive open, not for project load (project load handles its own flag)
                if not is_part_of_project_load and filepath is None: 
                    self._mark_project_modified()
                return True
            else: 
                return False # User cancelled confirmation dialog

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Invalid data, size, or format in supertile file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Supertile Error",
                f"Failed to open or parse supertiles file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    def save_map(self, filepath=None):
        global map_width, map_height, map_data, num_supertiles # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Map",
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Save Map As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write dimensions (Big-endian, 2 bytes each)
                dim_bytes = struct.pack(">HH", map_width, map_height)
                f.write(dim_bytes)

                # --- ADDED: Write reserved bytes after the header ---
                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)
                # --- END ADDED ---

                # --- MODIFIED: Write map data with conditional index size ---
                # Determine if we need 1-byte or 2-byte indices for ST references
                # based on the current project's num_supertiles.
                # num_supertiles is the actual count (e.g., 1 to 65535)
                
                use_2_byte_indices_for_map = (num_supertiles > 255)
                if use_2_byte_indices_for_map:
                    self.debug(f"[DEBUG] save_map: Using 2-byte ST indices (num_supertiles={num_supertiles}).")
                else:
                    self.debug(f"[DEBUG] save_map: Using 1-byte ST indices (num_supertiles={num_supertiles}).")

                for r in range(map_height):
                    if r >= len(map_data): # Should not happen if map_data is consistent
                        self.debug(f"[DEBUG] save_map: map_height > len(map_data) at row {r}. Padding rest of map.")
                        # Pad remaining rows if data is inconsistent
                        for _pad_r in range(map_height - r):
                            for _pad_c in range(map_width):
                                if use_2_byte_indices_for_map:
                                    f.write(struct.pack(">H", 0))
                                else:
                                    f.write(struct.pack("B", 0))
                        break # Stop processing rows

                    row_data = map_data[r]
                    for c in range(map_width):
                        supertile_index_val = 0 # Default if cell data missing
                        if c < len(row_data):
                            supertile_index_val = row_data[c]
                        
                        if use_2_byte_indices_for_map:
                            # Ensure index is within 2-byte range (0-65535)
                            safe_supertile_index_val = max(0, min(65535, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                self.debug(f"[DEBUG] save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 2-byte save.")
                            index_bytes = struct.pack(">H", safe_supertile_index_val)
                            f.write(index_bytes)
                        else:
                            # Ensure index is within 1-byte range (0-255)
                            safe_supertile_index_val = max(0, min(255, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                self.debug(f"[DEBUG] save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 1-byte save (project ST count <= 255).")
                            index_byte = struct.pack("B", safe_supertile_index_val)
                            f.write(index_byte)
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Map saved successfully to {os.path.basename(save_path)}",
                )
            return True
        except Exception as e:
            messagebox.showerror(
                "Save Map Error",
                f"Failed to save map file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_map(self, filepath=None):
        global map_data, map_width, map_height, num_supertiles # Using globals
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Open Map",
            )
        if not load_path:
            return False

        try:
            loaded_w_map = 0
            loaded_h_map = 0
            new_map_data_from_file_temp = [] 
            map_uses_2byte_indices_in_file = False # To store how indices are in the file
            header_size_map_calc = 4 # For dimension bytes (HH)

            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                dim_bytes = f.read(header_size_map_calc) 
                if len(dim_bytes) < header_size_map_calc:
                    raise ValueError("Invalid map header: not enough bytes for dimensions.")
                loaded_w_map, loaded_h_map = struct.unpack(">HH", dim_bytes)
                
                min_dim_map, max_dim_map = 1, 1024 
                if not (min_dim_map <= loaded_w_map <= max_dim_map and min_dim_map <= loaded_h_map <= max_dim_map):
                    raise ValueError(f"Invalid map dimensions in file: {loaded_w_map}x{loaded_h_map} (must be {min_dim_map}-{max_dim_map} per side)")

                # Calculate expected payload sizes based on dimensions
                num_cells_map = loaded_w_map * loaded_h_map
                expected_payload_1byte_indices = num_cells_map * 1
                expected_payload_2byte_indices = num_cells_map * 2

                # Calculate expected total file sizes for different formats
                # Old format: Dims + 1-byte indices (no reserved bytes)
                expected_size_old_format_map = header_size_map_calc + expected_payload_1byte_indices
                
                # New format: Dims + Reserved + 1-byte indices
                expected_size_new_format_map_1byte = header_size_map_calc + RESERVED_BYTES_COUNT + expected_payload_1byte_indices
                # New format: Dims + Reserved + 2-byte indices
                expected_size_new_format_map_2byte = header_size_map_calc + RESERVED_BYTES_COUNT + expected_payload_2byte_indices

                has_reserved_bytes_to_read = False
                is_old_format_detected = False

                if file_size_check == expected_size_new_format_map_1byte:
                    has_reserved_bytes_to_read = True
                    map_uses_2byte_indices_in_file = False # New format, 1-byte indices
                    self.debug(f"Info: Map file '{os.path.basename(load_path)}' matches new format (1-byte indices).")
                elif file_size_check == expected_size_new_format_map_2byte:
                    has_reserved_bytes_to_read = True
                    map_uses_2byte_indices_in_file = True  # New format, 2-byte indices
                    self.debug(f"Info: Map file '{os.path.basename(load_path)}' matches new format (2-byte indices).")
                elif file_size_check == expected_size_old_format_map:
                    has_reserved_bytes_to_read = False
                    map_uses_2byte_indices_in_file = False # Old format always 1-byte
                    is_old_format_detected = True
                    self.debug(f"Info: Map file '{os.path.basename(load_path)}' matches old format (1-byte indices, no reserved).")
                else:
                    raise ValueError(
                        f"Map file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for dimensions {loaded_w_map}x{loaded_h_map}. Expected old(1B-idx): {expected_size_old_format_map}, "
                        f"new(1B-idx): {expected_size_new_format_map_1byte}, or new(2B-idx): {expected_size_new_format_map_2byte}."
                    )

                if has_reserved_bytes_to_read:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("Unexpected EOF while trying to read reserved bytes in a new format map file.")
                    self.debug(f"Info: Read and skipped {RESERVED_BYTES_COUNT} reserved bytes from map file.")
                
                # Read map data based on inferred index size for the file
                new_map_data_from_file_temp = [[0 for _c in range(loaded_w_map)] for _r in range(loaded_h_map)]
                for r_map_load in range(loaded_h_map):
                    for c_map_load in range(loaded_w_map):
                        st_index_val_read = 0
                        if map_uses_2byte_indices_in_file:
                            idx_bytes = f.read(2)
                            if len(idx_bytes) < 2: raise EOFError(f"EOF reading 2-byte ST index at map ({r_map_load},{c_map_load}).")
                            st_index_val_read = struct.unpack(">H", idx_bytes)[0]
                        else: # 1-byte indices
                            idx_byte = f.read(1)
                            if not idx_byte: raise EOFError(f"EOF reading 1-byte ST index at map ({r_map_load},{c_map_load}).")
                            st_index_val_read = struct.unpack("B", idx_byte)[0]
                        new_map_data_from_file_temp[r_map_load][c_map_load] = st_index_val_read
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    self.debug(f"Warning: Map file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")
            
            # --- End of file reading block ---

            confirm_load_map = True
            if filepath is None:
                confirm_load_map = messagebox.askokcancel("Load Map", "Replace current map with data from this file?")

            if confirm_load_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass # Redraw handled by update_all_displays

                temp_project_map_data = [[0 for _c in range(loaded_w_map)] for _r in range(loaded_h_map)]
                missing_supertile_indices_referenced = set()

                for r_val in range(loaded_h_map):
                    for c_val in range(loaded_w_map):
                        supertile_index_from_file = new_map_data_from_file_temp[r_val][c_val]
                        if not (0 <= supertile_index_from_file < num_supertiles):
                            missing_supertile_indices_referenced.add(supertile_index_from_file)
                            temp_project_map_data[r_val][c_val] = 0 
                        else:
                            temp_project_map_data[r_val][c_val] = supertile_index_from_file
                
                map_width = loaded_w_map
                map_height = loaded_h_map
                map_data = temp_project_map_data 

                if missing_supertile_indices_referenced:
                    sorted_missing = sorted(list(missing_supertile_indices_referenced))
                    msg = "Warning: The loaded map references supertile indices that do not exist in the current project's supertile set.\n\n"
                    msg += f"Missing indices found: {', '.join(map(str, sorted_missing[:20]))}"
                    if len(sorted_missing) > 20: msg += "..."
                    msg += "\n\nThese map cells have been defaulted to use Supertile 0."
                    messagebox.showwarning("Map Load Warning", msg, parent=(self.root if filepath is None else None))

                self.invalidate_minimap_background_cache()
                self.update_all_displays(changed_level="all") 
                self._trigger_minimap_reconfigure() 
                
                if filepath is None:
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_map_editor.winfo_exists():
                            self.notebook.select(self.tab_map_editor)
                    except tk.TclError:
                        self.debug("[DEBUG] open_map: TclError selecting map editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {map_width}x{map_height} map from {os.path.basename(load_path)}",
                    )
                if filepath is None: # Only mark modified if opened interactively
                    self._mark_project_modified()
                return True
            else: # User cancelled confirmation dialog
                return False

        except FileNotFoundError:
            messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e: # ValueError includes our custom size/format checks
            messagebox.showerror(
                "Open Map Error",
                f"Invalid data, size, or format in map file '{os.path.basename(load_path)}':\n{e}",
            )
            return False
        except Exception as e:
            messagebox.showerror(
                "Open Map Error",
                f"Failed to open or parse map file '{os.path.basename(load_path)}':\n{e}",
            )
            return False

    # --- Project Save/Load Methods ---

    def save_project(self):
        if self.current_project_base_path:
            base_path = self.current_project_base_path
            pal_path = base_path + ".SC4Pal" # UPDATED Extension
            til_path = base_path + ".SC4Tiles"
            sup_path = base_path + ".SC4Super"
            map_path = base_path + ".SC4Map"

            self.debug(f"[DEBUG] save_project: Saving to existing base path {base_path}")

            success = True
            if success:
                self.debug(f"[DEBUG] save_project: Saving palette to {pal_path}")
                success = self.save_palette(pal_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving tileset to {til_path}")
                success = self.save_tileset(til_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving supertiles to {sup_path}")
                success = self.save_supertiles(sup_path)
            if success:
                self.debug(f"[DEBUG] save_project: Saving map to {map_path}")
                success = self.save_map(map_path)

            if success:
                self.debug("[DEBUG] save_project: All components saved successfully.")
                self.project_modified = False
                self._update_window_title()
                return True
            else:
                self.debug("[DEBUG] save_project: One or more components failed to save.")
                # Consider showing a messagebox here if a component save fails during "Save Project"
                # For now, it just returns False and logs.
                return False
        else:
            self.debug("[DEBUG] save_project: No current_project_base_path, calling save_project_as.")
            return self.save_project_as()

    def save_project_as(self):
        base_path_from_dialog = filedialog.asksaveasfilename(
            title="Save Project As (Enter Base Name for Components)",
            filetypes=[("MSX Tile Forge Project", "*")], # Simplified filetype, user types name
            parent=self.root,
            # defaultextension can be tricky if user types an extension.
            # It's often better to let them type the base name and append extensions manually.
        )

        if not base_path_from_dialog:
            self.debug("[DEBUG] save_project_as: User cancelled 'Save As' dialog.")
            return False 

        # Ensure we have a clean base path without any user-typed extension
        # For example, if user types "myproject.til", true_base_path should be "myproject"
        true_base_path, user_typed_ext = os.path.splitext(base_path_from_dialog)
        if not true_base_path: # If input was just ".ext" or ""
            self.debug(f"[DEBUG] save_project_as: Invalid base name from dialog: '{base_path_from_dialog}'")
            messagebox.showerror("Save Error", "Invalid base name for project.", parent=self.root)
            return False
        # If user typed something like "myproject" (no ext), splitext gives ("myproject", "").
        # If user typed "myproject.txt", splitext gives ("myproject", ".txt"). We want "myproject".
        # The current logic is: true_base_path will be the part before the last dot.
        # If no dot, user_typed_ext will be empty, and true_base_path is the whole string. This is good.
        
        self.debug(f"[DEBUG] save_project_as: User selected/input: '{base_path_from_dialog}', True base path for components: '{true_base_path}'")

        pal_path = true_base_path + ".SC4Pal"   # UPDATED Extension
        til_path = true_base_path + ".SC4Tiles"
        sup_path = true_base_path + ".SC4Super"
        map_path = true_base_path + ".SC4Map"

        # Check if any of these files already exist and confirm overwrite for the set
        # This is a bit more complex for a project "Save As" because multiple files are involved.
        # A simple approach is to warn if *any* would overwrite and ask for global confirmation.
        existing_files_to_overwrite = []
        if os.path.exists(pal_path): existing_files_to_overwrite.append(os.path.basename(pal_path))
        if os.path.exists(til_path): existing_files_to_overwrite.append(os.path.basename(til_path))
        if os.path.exists(sup_path): existing_files_to_overwrite.append(os.path.basename(sup_path))
        if os.path.exists(map_path): existing_files_to_overwrite.append(os.path.basename(map_path))

        if existing_files_to_overwrite:
            confirm_msg = "One or more project component files already exist at this location:\n"
            confirm_msg += "\n".join(existing_files_to_overwrite)
            confirm_msg += "\n\nOverwrite these files?"
            if not messagebox.askokcancel("Confirm Overwrite", confirm_msg, icon="warning", parent=self.root):
                self.debug("[DEBUG] save_project_as: User cancelled overwrite of existing project files.")
                return False # User cancelled overwrite

        success = True
        # These individual save methods already handle their own success/failure.
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving palette to {pal_path}")
            success = self.save_palette(pal_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving tileset to {til_path}")
            success = self.save_tileset(til_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving supertiles to {sup_path}")
            success = self.save_supertiles(sup_path)
        if success:
            self.debug(f"[DEBUG] save_project_as: Saving map to {map_path}")
            success = self.save_map(map_path)

        if success:
            self.debug("[DEBUG] save_project_as: All components saved successfully.")
            self.current_project_base_path = true_base_path 
            self.project_modified = False
            self._update_window_title()
            return True
        else:
            self.debug("[DEBUG] save_project_as: One or more components failed to save.")
            messagebox.showerror(
                "Project Save Error", 
                "One or more project components failed to save. The project may be partially saved.", # Clarified message
                parent=self.root
            )
            # Don't set current_project_base_path if save wasn't fully successful.
            # Project might still be considered modified.
            return False
    
    def open_project(self):
        filepath = filedialog.askopenfilename(
            filetypes=[
                ("SC4 Palette File (*.SC4Pal)", "*.SC4Pal"),       
                ("MSX Tileset File (*.SC4Tiles)", "*.SC4Tiles"),  
                ("MSX Supertile File (*.SC4Super)", "*.SC4Super"),
                ("MSX Map File (*.SC4Map)", "*.SC4Map"),
                ("Old MSX Palette File (*.msxpal)", "*.msxpal"), 
                ("All Files", "*.*"),
            ],
            title="Open Project (Select Any Component File)",
            parent=self.root
        )
        if not filepath:
            return 

        directory = os.path.dirname(filepath)
        base_name_with_ext = os.path.basename(filepath)
        base_name, selected_ext = os.path.splitext(base_name_with_ext) 
        
        base_path = os.path.join(directory, base_name)

        pal_path_new = base_path + ".SC4Pal"
        pal_path_old = base_path + ".msxpal"
        
        actual_pal_path_to_load = None
        if os.path.exists(pal_path_new):
            actual_pal_path_to_load = pal_path_new
            self.debug(f"[DEBUG] open_project: Found new palette format: {actual_pal_path_to_load}")
        elif os.path.exists(pal_path_old):
            actual_pal_path_to_load = pal_path_old
            self.debug(f"[DEBUG] open_project: Found old palette format: {actual_pal_path_to_load}")

        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        missing_files = []
        if actual_pal_path_to_load is None: 
            missing_files.append(f"{base_name}.SC4Pal (or .msxpal)")
        if not os.path.exists(til_path): missing_files.append(os.path.basename(til_path))
        if not os.path.exists(sup_path): missing_files.append(os.path.basename(sup_path))
        if not os.path.exists(map_path): missing_files.append(os.path.basename(map_path))

        if missing_files:
            messagebox.showerror("Open Project Error", 
                                 f"Cannot open project '{base_name}'.\nMissing component file(s):\n" + "\n".join(missing_files),
                                 parent=self.root)
            return

        if self.project_modified:
            confirm_discard = messagebox.askokcancel("Unsaved Changes", 
                                                     f"Discard current unsaved changes and open project '{base_name}'?", 
                                                     icon="warning", parent=self.root)
            if not confirm_discard:
                return
        
        self.is_ctrl_pressed = False; self.is_shift_pressed = False; self.current_mouse_action = None
        global tile_clipboard_pattern, tile_clipboard_colors, supertile_clipboard_data 
        tile_clipboard_pattern = None; tile_clipboard_colors = None; supertile_clipboard_data = None
        self.map_clipboard_data = None
        self._clear_map_selection(); self._clear_paste_preview_rect() 
        self._clear_marked_unused(trigger_redraw=False) 
        self.clear_all_caches() 
        self.invalidate_minimap_background_cache() 

        success = True
        self.debug(f"Loading project '{base_name}'...")
        
        if success: self.debug(f"  Loading palette: {actual_pal_path_to_load}"); success = self.open_palette(actual_pal_path_to_load)
        if success: self.debug(f"  Loading tileset: {til_path}"); success = self.open_tileset(til_path)
        if success: self.debug(f"  Loading supertiles: {sup_path}"); success = self.open_supertiles(sup_path, is_part_of_project_load=True) # Modified line
        if success: self.debug(f"  Loading map: {map_path}"); success = self.open_map(map_path)
        
        if success:
            self.project_modified = False 
            self.current_project_base_path = base_path 
            self._update_window_title()
            
            self.root.after_idle(self._perform_project_load_ui_updates)
            self.debug(f"[DEBUG] open_project: Project '{base_name}' load sequence initiated. UI updates deferred.")

        else:
            messagebox.showerror("Project Open Error", 
                                 f"Failed to load one or more components for project '{base_name}'. The application state might be inconsistent.",
                                 parent=self.root)
            self.project_modified = True 
            self._update_window_title()
            self.root.after_idle(self.update_all_displays, "all") 
            self.root.after_idle(self._update_edit_menu_state)
            self.root.after_idle(self._update_editor_button_states)
            self.root.after_idle(self._update_supertile_rotate_button_state)

    def _perform_project_load_ui_updates(self):
        """Helper method to perform UI updates after a project load and Tkinter idle cycle."""
        self.debug("[DEBUG] _perform_project_load_ui_updates: Starting deferred UI updates.")
        
        # Ensure the correct tab is selected (e.g., map editor)
        # This might trigger on_tab_change, which itself might have after_idle calls.
        try:
            if self.notebook and self.notebook.winfo_exists() and self.tab_map_editor.winfo_exists():
                 self.notebook.select(self.tab_map_editor)
        except tk.TclError:
            self.debug("[DEBUG] _perform_project_load_ui_updates: TclError selecting map editor tab.")

        # Force Tkinter to process pending events, especially layout changes from tab selection
        self.root.update_idletasks() 

        # Now update all displays; widgets should have their correct sizes.
        self.update_all_displays(changed_level="all")
        
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        
        # Specific updates for map if it's the active tab now
        is_map_tab_active = False
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
        except tk.TclError: pass

        if is_map_tab_active:
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                self.map_canvas.focus_set()
            self.draw_minimap() # draw_minimap should be robust to being called now
            if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                self._do_check_and_enforce_palette_min_width()
        
        self._update_map_cursor() # General cursor update
        self.debug("[DEBUG] _perform_project_load_ui_updates: Deferred UI updates complete.")

    # --- Edit Menu Commands ---

    def set_tileset_size(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        prompt = f"Enter number of tiles (1-{MAX_TILES}):"
        new_size_str = simpledialog.askstring(
            "Set Tileset Size", prompt, initialvalue=str(num_tiles_in_set)
        )

        if new_size_str:
            try:
                new_size = int(new_size_str)

                if not (1 <= new_size <= MAX_TILES):
                    messagebox.showerror(
                        "Invalid Size", f"Size must be between 1 and {MAX_TILES}."
                    )
                    return

                if new_size == num_tiles_in_set:
                    return

                reduced = new_size < num_tiles_in_set
                confirmed_resize = True # Renamed for clarity
                if reduced:
                    affected_supertiles_list = set() # Use a set to avoid duplicates
                    for del_idx_tile in range(new_size, num_tiles_in_set):
                        # _check_tile_usage uses self.supertile_grid_width/height internally
                        usage_list = self._check_tile_usage(del_idx_tile)
                        for st_idx_affected in usage_list:
                            affected_supertiles_list.add(st_idx_affected)

                    confirm_prompt_msg = f"Reducing size to {new_size} will discard tiles {new_size} to {num_tiles_in_set-1}."
                    if affected_supertiles_list:
                        confirm_prompt_msg += "\n\n*** WARNING! ***\nDiscarded tiles are used by Supertile(s):\n"
                        affected_list_sorted = sorted(list(affected_supertiles_list))
                        confirm_prompt_msg += ", ".join(map(str, affected_list_sorted[:10]))
                        if len(affected_list_sorted) > 10:
                            confirm_prompt_msg += "..."
                        confirm_prompt_msg += "\n\nReferences to discarded tiles in these Supertiles will be reset to Tile 0."

                    confirmed_resize = messagebox.askokcancel(
                        "Reduce Tileset Size", confirm_prompt_msg, icon="warning"
                    )

                if confirmed_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()

                    if reduced:
                        for del_idx_tile_loop in range(new_size, num_tiles_in_set):
                            # _update_supertile_refs_for_tile_change uses self.supertile_grid_width/height
                            self._update_supertile_refs_for_tile_change(
                                del_idx_tile_loop, "delete"
                            )
                            self._adjust_marked_indices_after_delete(self.marked_unused_tiles, del_idx_tile_loop)
                        for i in range(new_size, num_tiles_in_set):
                            self.invalidate_tile_cache(i) # Invalidate cache for tiles being removed from active set
                        
                        # Trim the lists
                        del tileset_patterns[new_size:]
                        del tileset_colors[new_size:]
                        # Ensure they are padded back to MAX_TILES if that's the desired behavior for fixed-size arrays
                        # For dynamic Python lists, this just shortens them.
                        # If MAX_TILES is a hard limit for array indexing elsewhere, pad them:
                        # while len(tileset_patterns) < MAX_TILES:
                        #     tileset_patterns.append([[0]*TILE_WIDTH for _r in range(TILE_HEIGHT)])
                        #     tileset_colors.append([(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)])


                    elif new_size > num_tiles_in_set: # Increasing size
                        # Add new blank tiles up to new_size, but not exceeding MAX_TILES
                        tiles_to_add = new_size - num_tiles_in_set
                        for _ in range(tiles_to_add):
                            if len(tileset_patterns) < MAX_TILES: # Check against actual list capacity
                                tileset_patterns.append(
                                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                                )
                                tileset_colors.append(
                                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                                )
                            else: # Should not happen if new_size <= MAX_TILES
                                break 
                    
                    num_tiles_in_set = new_size # Update the count of active tiles

                    current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
                    selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
                self.debug(f"[DEBUG]Error setting tileset size: {e}")

    def set_supertile_count(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        prompt = f"Enter number of supertiles (1-{MAX_SUPERTILES}):"
        new_count_str = simpledialog.askstring(
            "Set Supertile Count", prompt, initialvalue=str(num_supertiles)
        )

        if new_count_str:
            try:
                new_count = int(new_count_str)

                if not (1 <= new_count <= MAX_SUPERTILES):
                    messagebox.showerror(
                        "Invalid Count",
                        f"Count must be between 1 and {MAX_SUPERTILES}.",
                    )
                    return

                if new_count == num_supertiles:
                    return

                reduced_count = new_count < num_supertiles # Renamed for clarity
                confirmed_st_resize = True # Renamed
                if reduced_count:
                    affected_map_cells_list = []
                    for del_idx_st in range(new_count, num_supertiles):
                        usage_on_map = self._check_supertile_usage(del_idx_st)
                        affected_map_cells_list.extend(usage_on_map)

                    confirm_prompt_st = f"Reducing count to {new_count} will discard supertiles {new_count} to {num_supertiles-1}."
                    if affected_map_cells_list: # Check if list is not empty
                        confirm_prompt_st += "\n\n*** WARNING! ***\nDiscarded supertiles are used on the Map."
                        confirm_prompt_st += (
                            "\n\nReferences on the Map will be reset to Supertile 0."
                        )

                    confirmed_st_resize = messagebox.askokcancel(
                        "Reduce Supertile Count", confirm_prompt_st, icon="warning"
                    )

                if confirmed_st_resize:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    self._mark_project_modified()

                    if reduced_count:
                        for del_idx_st_loop in range(new_count, num_supertiles):
                            self._update_map_refs_for_supertile_change(
                                del_idx_st_loop, "delete"
                            )
                            self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, del_idx_st_loop)
                        
                        # Trim the supertiles_data list
                        del supertiles_data[new_count:]
                        # Pad back to MAX_SUPERTILES if it's meant to be fixed-size array for indexing
                        # For dynamic lists, this just shortens.
                        # If padding:
                        # while len(supertiles_data) < MAX_SUPERTILES:
                        #    supertiles_data.append(
                        #        [[0] * self.supertile_grid_width for _r in range(self.supertile_grid_height)]
                        #    )


                    elif new_count > num_supertiles: # Increasing count
                        st_to_add = new_count - num_supertiles
                        for _ in range(st_to_add):
                            if len(supertiles_data) < MAX_SUPERTILES:
                                supertiles_data.append(
                                    [[0] * self.supertile_grid_width for _r_add in range(self.supertile_grid_height)]
                                )
                            else: # Should not happen if new_count <= MAX_SUPERTILES
                                break
                    
                    num_supertiles = new_count # Update active count

                    current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
                    selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

                    self.supertile_image_cache.clear()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(
                        changed_level="all" # Changed to all for safety if map refs changed
                    )
                    self._update_editor_button_states()
                    self._update_edit_menu_state()
                    self._update_supertile_rotate_button_state() # Though ST count doesn't change W/H


            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.")
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
                self.debug(f"[DEBUG]Error setting supertile count: {e}")

    def set_map_dimensions(self):
        global map_width, map_height, map_data

        prompt = "Enter new dimensions (Width x Height):"
        dims_str = simpledialog.askstring(
            "Set Map Dimensions", prompt, initialvalue=f"{map_width}x{map_height}"
        )

        if dims_str:
            try:
                parts = dims_str.lower().split("x")
                if len(parts) != 2:
                    raise ValueError("Format must be WidthxHeight")

                new_w_str = parts[0].strip()
                new_h_str = parts[1].strip()
                new_w = int(new_w_str)
                new_h = int(new_h_str)

                min_dim, max_dim = 1, 1024
                if not (min_dim <= new_w <= max_dim):
                    raise ValueError(f"Width must be between {min_dim} and {max_dim}")
                if not (min_dim <= new_h <= max_dim):
                    raise ValueError(f"Height must be between {min_dim} and {max_dim}")

                if new_w == map_width and new_h == map_height:
                    return  

                reducing = new_w < map_width or new_h < map_height
                confirmed = True  
                if reducing:
                    confirm_prompt = "Reducing map size will discard data outside boundaries. Proceed?"
                    confirmed = messagebox.askokcancel("Resize Map", confirm_prompt)

                if confirmed:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass
                    self._mark_project_modified()
                    new_map_data = [[0 for _ in range(new_w)] for _ in range(new_h)]
                    rows_to_copy = min(map_height, new_h)
                    cols_to_copy = min(map_width, new_w)
                    for r_idx in range(rows_to_copy): # Renamed r
                        for c_idx in range(cols_to_copy): # Renamed c
                            new_map_data[r_idx][c_idx] = map_data[r_idx][c_idx]

                    map_width = new_w
                    map_height = new_h
                    map_data = new_map_data

                    self.update_all_displays(changed_level="map")
                    self._trigger_minimap_reconfigure()  

            except ValueError as e:
                messagebox.showerror("Invalid Input", f"Error setting dimensions: {e}")
            except Exception as e:
                messagebox.showerror(
                    "Error", f"An unexpected error occurred during resize: {e}"
                )

    def clear_current_tile(self):
        global tileset_patterns, tileset_colors, current_tile_index, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        prompt = f"Clear pattern and reset colors for tile {current_tile_index}?"
        if messagebox.askokcancel("Clear Tile", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all") 

            self._mark_project_modified()
            tileset_patterns[current_tile_index] = [
                [0] * TILE_WIDTH for _ in range(TILE_HEIGHT)
            ]
            tileset_colors[current_tile_index] = [
                (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
            ]
            self.invalidate_tile_cache(current_tile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="tile")

    def clear_current_supertile(self):
        global supertiles_data, current_supertile_index # supertiles_data is global
        if not (0 <= current_supertile_index < num_supertiles):
            return
        prompt = f"Clear definition (set all to tile 0) for supertile {current_supertile_index}?"
        if messagebox.askokcancel("Clear Supertile", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            self._mark_project_modified()
            # Initialize with current project's supertile dimensions
            supertiles_data[current_supertile_index] = [
                [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            ]
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles): # If no marks were present
                self.update_all_displays(changed_level="supertile")
            else: # If marks were cleared, a full redraw (from above) already handled it or will.
                  # To be safe, if this branch is hit, ensure the supertile tab is updated.
                self.update_all_displays(changed_level="supertile")

    def clear_map(self):
        global map_data, map_width, map_height
        prompt = "Clear entire map (set all to supertile 0)?"
        if messagebox.askokcancel("Clear Map", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            self._mark_project_modified()
            map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
            self.invalidate_minimap_background_cache()
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="map")

    def copy_current_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Copy Tile", "No valid tile selected.")
            return
        tile_clipboard_pattern = copy.deepcopy(tileset_patterns[current_tile_index])
        tile_clipboard_colors = copy.deepcopy(tileset_colors[current_tile_index])
        print(f"Tile {current_tile_index} copied.")
        self._update_edit_menu_state()

    def paste_tile(self):
        global tile_clipboard_pattern, tile_clipboard_colors, current_tile_index, num_tiles_in_set, tileset_patterns, tileset_colors
        if tile_clipboard_pattern is None or tile_clipboard_colors is None:
            messagebox.showinfo("Paste Tile", "Tile clipboard is empty.")
            return
        if not (0 <= current_tile_index < num_tiles_in_set):
            messagebox.showwarning("Paste Tile", "No valid tile selected to paste onto.") # Clarified message
            return
        
        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        self._mark_project_modified()
        tileset_patterns[current_tile_index] = copy.deepcopy(tile_clipboard_pattern)
        tileset_colors[current_tile_index] = copy.deepcopy(tile_clipboard_colors)
        self.invalidate_tile_cache(current_tile_index)
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="tile")
        print(f"Pasted onto Tile {current_tile_index}.")

    def copy_current_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Copy Supertile", "No valid supertile selected.")
            return
        
        # The clipboard will store a definition matching current project's ST dimensions
        supertile_clipboard_data = copy.deepcopy(
            supertiles_data[current_supertile_index] # supertiles_data is global
        )
        # Store dimensions with clipboard data for safer paste
        if hasattr(self, 'supertile_grid_width') and hasattr(self, 'supertile_grid_height'):
             # This is a good idea, but supertile_clipboard_data is just the list of lists currently.
             # To store dimensions, we'd need to change it to a dictionary:
             # self.supertile_clipboard_data_with_dims = {
             #    "width": self.supertile_grid_width,
             #    "height": self.supertile_grid_height,
             #    "data": copy.deepcopy(supertiles_data[current_supertile_index])
             # }
             # For now, sticking to existing global structure of supertile_clipboard_data.
             # Paste operation will assume clipboard data matches current project ST dimensions.
             pass

        print(f"Supertile {current_supertile_index} copied.")
        self._update_edit_menu_state()

    def paste_supertile(self):
        global supertile_clipboard_data, current_supertile_index, num_supertiles, supertiles_data
        if supertile_clipboard_data is None:
            messagebox.showinfo("Paste Supertile", "Supertile clipboard is empty.")
            return
        if not (0 <= current_supertile_index < num_supertiles):
            messagebox.showwarning("Paste Supertile", "No valid supertile selected to paste onto.")
            return
        
        # --- Optional: Check for dimension mismatch if clipboard stored them ---
        # if hasattr(self, 'supertile_clipboard_data_with_dims'): # If clipboard was a dict
        #     clip_w = self.supertile_clipboard_data_with_dims["width"]
        #     clip_h = self.supertile_clipboard_data_with_dims["height"]
        #     clip_data_actual = self.supertile_clipboard_data_with_dims["data"]
        #     if clip_w != self.supertile_grid_width or clip_h != self.supertile_grid_height:
        #         if not messagebox.askokcancel("Dimension Mismatch",
        #             f"Clipboard ST is {clip_w}x{clip_h}, current project STs are {self.supertile_grid_width}x{self.supertile_grid_height}.\n"
        #             "Pasting may result in data truncation or padding. Continue?"):
        #             return
        #         # If continuing, would need logic to crop/pad clip_data_actual to fit current dimensions
        #         # For now, we assume direct copy of structure.
        #         # This is a placeholder for more advanced handling.
        # else:
        #     clip_data_actual = supertile_clipboard_data # Use as is

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        # Direct copy of list structure. Assumes dimensions match.
        # If clipboard_data is from a different ST dimension, this could lead to issues.
        try:
            # Check clipboard structure against current supertile dimensions
            # This is a basic check; more robust would be deep comparison or explicit padding/truncation.
            if len(supertile_clipboard_data) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(supertile_clipboard_data[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0):
                supertiles_data[current_supertile_index] = copy.deepcopy(
                    supertile_clipboard_data # Global clipboard data
                )
                self._mark_project_modified()
                self.invalidate_supertile_cache(current_supertile_index)
                self.invalidate_minimap_background_cache()
                if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                    self.update_all_displays(changed_level="supertile")
                else:
                    self.update_all_displays(changed_level="supertile") # Ensure supertile tab is updated
                print(f"Pasted onto Supertile {current_supertile_index}.")
            else:
                messagebox.showerror("Paste Error", "Supertile clipboard dimensions do not match current project supertile dimensions. Paste aborted.")
                # If marks were cleared but paste failed, redraw to reflect current state
                if self.marked_unused_tiles or self.marked_unused_supertiles:
                     self.update_all_displays(changed_level="all")

        except Exception as e:
            messagebox.showerror("Paste Error", f"Could not paste supertile data due to structure mismatch or error: {e}")
            # If marks were cleared but paste failed
            if self.marked_unused_tiles or self.marked_unused_supertiles:
                 self.update_all_displays(changed_level="all")

    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        first_pattern_row = current_pattern[0]
        first_color_row = current_colors[0]
        for i in range(TILE_HEIGHT - 1):
            current_pattern[i] = current_pattern[i + 1]
            current_colors[i] = current_colors[i + 1]
        current_pattern[TILE_HEIGHT - 1] = first_pattern_row
        current_colors[TILE_HEIGHT - 1] = first_color_row
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted up.")

    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        last_pattern_row = current_pattern[TILE_HEIGHT - 1]
        last_color_row = current_colors[TILE_HEIGHT - 1]
        for i in range(TILE_HEIGHT - 1, 0, -1):
            current_pattern[i] = current_pattern[i - 1]
            current_colors[i] = current_colors[i - 1]
        current_pattern[0] = last_pattern_row
        current_colors[0] = last_color_row
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted down.")

    def shift_tile_left(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        for r in range(TILE_HEIGHT):
            row_data = current_pattern[r]
            if TILE_WIDTH > 0:
                first_pixel = row_data[0]
            for c in range(TILE_WIDTH - 1):
                row_data[c] = row_data[c + 1]
            row_data[TILE_WIDTH - 1] = first_pixel
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted left.")

    def shift_tile_right(self):
        global tileset_patterns, current_tile_index, num_tiles_in_set
        if not (0 <= current_tile_index < num_tiles_in_set):
            return
        current_pattern = tileset_patterns[current_tile_index]
        for r in range(TILE_HEIGHT):
            row_data = current_pattern[r]
            if TILE_WIDTH > 0:
                last_pixel = row_data[TILE_WIDTH - 1]
            for c in range(TILE_WIDTH - 1, 0, -1):
                row_data[c] = row_data[c - 1]
            row_data[0] = last_pixel
        self.invalidate_tile_cache(current_tile_index)
        self.update_all_displays(changed_level="tile")
        print(f"Tile {current_tile_index} shifted right.")

    # --- Zoom Methods ---
    def change_map_zoom_mult(self, factor):  # Renamed from change_map_zoom
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        view_x1, view_y1, view_x2, view_y2 = (
            canvas.xview()[0],
            canvas.yview()[0],
            canvas.xview()[1],
            canvas.yview()[1],
        )
        center_x_canvas = canvas.canvasx(
            (canvas.winfo_width() / 2)
        )  # Approximation of center
        center_y_canvas = canvas.canvasy((canvas.winfo_height() / 2))
        self.zoom_map_at_point(factor, center_x_canvas, center_y_canvas)

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size based on 8x8 base and zoom."""
        base_tile_size = 8  # 100% zoom = 8 pixels
        zoomed_size = base_tile_size * self.map_zoom_level
        return max(1, int(zoomed_size))  # Ensure at least 1 pixel

    # --- Scrolling Methods ---

    def scroll_viewers_to_tile(self, tile_index):
        """Scrolls the tileset viewers to make the specified tile index visible."""
        # Basic input validation
        if tile_index < 0:
            return

        # Define layout parameters
        padding = 1
        tile_size = VIEWER_TILE_SIZE
        items_per_row = NUM_TILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(tile_index, items_per_row)
        target_y = row * (tile_size + padding)

        # --- Scroll main viewer ---
        canvas_main = self.tileset_canvas
        try:
            # Get scroll region info (might be tuple or string)
            scroll_info_tuple = canvas_main.cget("scrollregion")
            # Convert to string and split for consistent parsing
            scroll_info = str(scroll_info_tuple).split()

            # Check if format is valid ("0 0 width height")
            if len(scroll_info) == 4:
                # Extract total height
                total_height = float(scroll_info[3])

                # Avoid division by zero
                if total_height > 0:
                    # Calculate scroll fraction
                    fraction = target_y / total_height
                    # Clamp fraction to valid range [0.0, 1.0]
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    # Perform the scroll
                    canvas_main.yview_moveto(clamped_fraction)
            # else: (Optional: handle invalid scrollregion format if needed)
            #     print(f"Warning: Invalid scrollregion format for main tileset viewer: {scroll_info}")

        except Exception as e:
            # Catch any error during scrolling
            print(f"Error scrolling main tileset viewer: {e}")

        # --- Scroll Supertile tab's viewer ---
        canvas_st = self.st_tileset_canvas
        try:
            scroll_info_st_tuple = canvas_st.cget("scrollregion")
            scroll_info_st = str(scroll_info_st_tuple).split()

            if len(scroll_info_st) == 4:
                total_height_st = float(scroll_info_st[3])

                if total_height_st > 0:
                    fraction_st = target_y / total_height_st
                    clamped_fraction_st = min(1.0, max(0.0, fraction_st))
                    canvas_st.yview_moveto(clamped_fraction_st)
            # else:
            #     print(f"Warning: Invalid scrollregion format for ST tileset viewer: {scroll_info_st}")

        except Exception as e:
            print(f"Error scrolling ST tileset viewer: {e}")

    def scroll_selectors_to_supertile(self, supertile_index):
        """Scrolls the supertile selectors to make the specified index visible."""
        # Basic input validation
        if supertile_index < 0:
            return

        # Define layout parameters
        padding = 1
        item_size = SUPERTILE_SELECTOR_PREVIEW_SIZE
        items_per_row = NUM_SUPERTILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(supertile_index, items_per_row)
        target_y = row * (item_size + padding)

        # --- Scroll Supertile tab's selector ---
        canvas_st = self.supertile_selector_canvas
        try:
            scroll_info_tuple = canvas_st.cget("scrollregion")
            scroll_info = str(scroll_info_tuple).split()

            if len(scroll_info) == 4:
                total_height = float(scroll_info[3])

                if total_height > 0:
                    fraction = target_y / total_height
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    canvas_st.yview_moveto(clamped_fraction)
            # else:
            #     print(f"Warning: Invalid scrollregion format for ST selector: {scroll_info}")

        except Exception as e:
            print(f"Error scrolling ST selector: {e}")

        # --- Scroll Map tab's selector ---
        canvas_map = self.map_supertile_selector_canvas
        try:
            scroll_info_map_tuple = canvas_map.cget("scrollregion")
            scroll_info_map = str(scroll_info_map_tuple).split()

            if len(scroll_info_map) == 4:
                total_height_map = float(scroll_info_map[3])

                if total_height_map > 0:
                    fraction_map = target_y / total_height_map
                    clamped_fraction_map = min(1.0, max(0.0, fraction_map))
                    canvas_map.yview_moveto(clamped_fraction_map)
            # else:
            #     print(f"Warning: Invalid scrollregion format for Map selector: {scroll_info_map}")

        except Exception as e:
            print(f"Error scrolling Map selector: {e}")

    # --- vvv NEW Grid/Window Handlers vvv ---
    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide window view
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
            valid = True
            if not (min_w <= new_w <= max_w):
                messagebox.showerror(
                    "Invalid Width", f"Window width must be {min_w}-{max_w}."
                )
                valid = False
            if not (min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Height", f"Window height must be {min_h}-{max_h}."
                )
                valid = False

            if not valid:
                # Reset entries to current state if invalid
                self._update_window_size_vars_from_state()  # Use internal helper
                return

            # If size changed (or even if not, just redraw for simplicity)
            self._clamp_window_view_position()  # Ensure position is valid for new size
            self.draw_map_canvas()
            self.draw_minimap()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:  # Handles non-integer input in IntVars
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
            self._update_window_size_vars_from_state()  # Reset on error
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")
            self._update_window_size_vars_from_state()

    def _update_window_size_vars_from_state(self):
        """Internal helper to set IntVars from the state variables."""
        # Needed because the IntVars are bound to entries, direct setting is best
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Trigger update if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())

    def _clamp_window_view_position(self):
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        # Total map dimension in base tiles:
        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        # Max top-left position for the window view
        max_tile_x_clamp = total_map_tiles_w - current_w
        max_tile_y_clamp = total_map_tiles_h - current_h

        # Ensure max is not negative
        max_tile_x_clamp = max(0, max_tile_x_clamp)
        max_tile_y_clamp = max(0, max_tile_y_clamp)
        
        self.window_view_tile_x = max(0, min(self.window_view_tile_x, max_tile_x_clamp))
        self.window_view_tile_y = max(0, min(self.window_view_tile_y, max_tile_y_clamp))

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        """Moves the window view by dx, dy TILE steps."""
        if not self.show_window_view.get():
            return  # Only move if visible

        # Calculate new target position
        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        # Clamp within map bounds (recalculate max based on current size)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update if position changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus."""
        key = event.keysym.lower()  # Get lowercase keysym

        if key == "c":
            self.cycle_grid_color()
        elif self.show_window_view.get():  # Only move window if visible
            if key == "w":
                self.move_window_view_keyboard(0, -1)  # Move up
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)  # Move left
            elif key == "s":
                self.move_window_view_keyboard(0, 1)  # Move down
            elif key == "d":
                self.move_window_view_keyboard(1, 0)  # Move right

    # --- Window View Drag/Resize Handlers ---
    def _get_handle_at(self, canvas_x, canvas_y):
        """Checks if the click is on a resize handle, returns handle tag ('nw', 'n', etc.) or None."""
        if not self.show_window_view.get():
            return None
        # Find items tagged 'window_view_handle' near the click
        search_radius = WIN_VIEW_HANDLE_SIZE  # Search slightly larger than handle
        items = self.map_canvas.find_overlapping(
            canvas_x - search_radius,
            canvas_y - search_radius,
            canvas_x + search_radius,
            canvas_y + search_radius,
        )
        for item_id in items:
            tags = self.map_canvas.gettags(item_id)
            if "window_view_handle" in tags:
                for t in tags:
                    if t.startswith("handle_"):
                        return t.split("_")[1]  # Return 'nw', 'n', etc.
        return None  # No handle found

    def _is_inside_window_view(self, canvas_x, canvas_y):
        """Checks if the click is inside the window view rectangle bounds."""
        if not self.show_window_view.get():
            return False
        zoomed_tile_size = self.get_zoomed_tile_size()
        win_px = self.window_view_tile_x * zoomed_tile_size
        win_py = self.window_view_tile_y * zoomed_tile_size
        win_pw = self.window_view_tile_w.get() * zoomed_tile_size
        win_ph = self.window_view_tile_h.get() * zoomed_tile_size
        return (
            win_px <= canvas_x < win_px + win_pw
            and win_py <= canvas_y < win_py + win_ph
        )

    def handle_map_click_or_drag_start(self, event):
        """Handles initial NON-CTRL click: determines action (paint/window drag/resize).
        Sets up state AND performs the initial paint action if applicable.
        Also clears map selection if starting a paint/window action.
        """
        global last_painted_map_cell

        # --- Check for active modifiers that override this handler ---
        if self.is_shift_pressed:
            self.debug("[DEBUG]Shift pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if ctrl_pressed_at_click:
            self.debug("[DEBUG]Ctrl pressed, ignoring Button-1 for paint/window ops.")
            return "break"
        if self.current_mouse_action is not None:
            self.debug(f"[DEBUG]Warning: Button-1 pressed while action '{self.current_mouse_action}' active.")
            return "break"
        # --- End Modifier Check ---

        # --- Clear previous selection when starting a new action ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        canvas = self.map_canvas
        canvas.focus_set()
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        action_determined = None
        handle = self._get_handle_at(canvas_x, canvas_y)

        # Determine action based on click location
        if handle and self.show_window_view.get():
            action_determined = "window_resizing"
            self.current_mouse_action = action_determined
            self.window_view_resize_handle = handle
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self.drag_start_win_tw = self.window_view_tile_w.get()
            self.drag_start_win_th = self.window_view_tile_h.get()

        elif (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            action_determined = "window_dragging"
            self.current_mouse_action = action_determined
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y

        else:  # Painting case
            action_determined = "painting"
            self.current_mouse_action = action_determined
            last_painted_map_cell = None  # Reset for this paint sequence
            self._paint_map_cell(canvas_x, canvas_y)  # Perform first paint

        self._update_map_cursor()  # Update cursor based on the determined action

        return "break"

    def handle_map_drag(self, event):
        """Handles motion for non-panning actions (paint, window drag/resize)."""

        # Ignore if panning or no suitable action is set from Button-1 press
        # This prevents interference if Ctrl was pressed *after* Button-1 was down but before motion.
        if self.current_mouse_action not in [
            "painting",
            "window_dragging",
            "window_resizing",
        ]:
            return  # Don't handle if not in a valid non-pan drag state

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Perform action based on the current state
        if self.current_mouse_action == "painting":
            self._paint_map_cell(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_dragging":
            self._do_window_move_drag(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_resizing":
            self._do_window_resize_drag(canvas_x, canvas_y)

        return "break"  # Prevent other B1-Motion bindings

    def handle_map_drag_release(self, event):
        """Handles mouse button release: ends the current action (paint, pan, window ops)."""
        global last_painted_map_cell  # Ensure global is accessible
        action_at_release = self.current_mouse_action

        last_painted_map_cell = None  # Stop continuous paint if it was happening

        # Reset the current action state FIRST
        self.current_mouse_action = None

        # Perform any finalization based on the action that just finished
        if action_at_release == "panning":
            pass  # No explicit action needed, scan_dragto stopped with motion

        elif action_at_release == "window_dragging":
            # Position is already snapped during drag, just update minimap (done below)
            pass

        elif action_at_release == "window_resizing":
            # Clamp final position and update entries/IntVar state just in case
            self._clamp_window_view_position()
            self._update_window_size_vars_from_state()  # Sync IntVars post-resize
            self.window_view_resize_handle = None
            # Redraw needed to finalize visual state and ensure entries match
            self.draw_map_canvas()  # Redraw map canvas to remove potential temp visuals

        elif action_at_release == "painting":
            pass  # No specific finalization needed

        self._update_map_cursor()
        self.draw_minimap()

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window movement during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        delta_x_pixels = current_canvas_x - self.drag_start_x
        delta_y_pixels = current_canvas_y - self.drag_start_y

        # Calculate movement in TILE units, snapping to grid
        # Use floor for consistent snapping direction
        delta_tile_x = math.floor(delta_x_pixels / zoomed_tile_size)
        delta_tile_y = math.floor(delta_y_pixels / zoomed_tile_size)

        # Calculate potential new top-left TILE coordinate
        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y

        # Clamp position within map bounds (using current W/H)
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * SUPERTILE_GRID_DIM) - current_w)
        max_tile_y = max(0, (map_height * SUPERTILE_GRID_DIM) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        # Update state and redraw ONLY if position actually changes
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()  # Redraw to show moved window
            self.draw_minimap()

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window resize during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        # Starting state in TILE units
        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th
        start_br_tx = start_tx + start_tw  # Bottom-right tile X (exclusive)
        start_br_ty = start_ty + start_th  # Bottom-right tile Y (exclusive)

        # Current mouse position snapped to TILE grid
        current_tile_x = math.floor(current_canvas_x / zoomed_tile_size)
        current_tile_y = math.floor(current_canvas_y / zoomed_tile_size)

        # Calculate new potential corners based on handle
        new_tx = start_tx
        new_ty = start_ty
        new_br_tx = start_br_tx
        new_br_ty = start_br_ty
        handle = self.window_view_resize_handle

        # Adjust based on handle dragged
        if "n" in handle:
            new_ty = current_tile_y
        if "s" in handle:
            new_br_ty = current_tile_y + 1  # +1 because BR is exclusive
        if "w" in handle:
            new_tx = current_tile_x
        if "e" in handle:
            new_br_tx = current_tile_x + 1

        # Ensure top-left is never beyond bottom-right
        new_tx = min(new_tx, new_br_tx - 1)  # Ensure width >= 1
        new_ty = min(new_ty, new_br_ty - 1)  # Ensure height >= 1
        new_br_tx = max(new_br_tx, new_tx + 1)
        new_br_ty = max(new_br_ty, new_ty + 1)

        # Calculate new width and height in tiles
        new_tw = new_br_tx - new_tx
        new_th = new_br_ty - new_ty

        # Clamp dimensions to allowed limits
        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        # Adjust position if clamping changed dimensions, preserving the fixed corner/edge
        if "n" in handle and clamped_th != new_th:
            new_ty = new_br_ty - clamped_th
        if "w" in handle and clamped_tw != new_tw:
            new_tx = new_br_tx - clamped_tw
        if "s" in handle:
            new_br_ty = (
                new_ty + clamped_th
            )  # Recalculate needed? No, height is clamped.
        if "e" in handle:
            new_br_tx = new_tx + clamped_tw

        # Clamp position to stay within map boundaries
        max_map_tile_x = map_width * SUPERTILE_GRID_DIM
        max_map_tile_y = map_height * SUPERTILE_GRID_DIM
        clamped_tx = max(0, min(new_tx, max_map_tile_x - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y - clamped_th))

        # Final check if clamping position changed dimensions again (shouldn't drastically)
        final_tw = min(clamped_tw, max_map_tile_x - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y - clamped_ty)

        # Update state only if position or size changed
        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw
            or self.window_view_tile_h.get() != final_th
        ):
            #
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)  # Update IntVars
            self.window_view_tile_h.set(final_th)
            # self._update_window_size_vars_from_state() # Update entries
            self.draw_map_canvas()  # Redraw to show resize
            self.draw_minimap()

    # --- Minimap Methods ---

    def toggle_minimap(self):
        """Opens/raises the resizable minimap window."""
        if self.minimap_window is None or not tk.Toplevel.winfo_exists(
            self.minimap_window
        ):
            self.minimap_window = tk.Toplevel(self.root)
            self.minimap_window.title("Minimap")
            # Set initial size, but allow resizing
            self.minimap_window.geometry(
                f"{MINIMAP_INITIAL_WIDTH}x{MINIMAP_INITIAL_HEIGHT}"
            )
            # self.minimap_window.resizable(False, False) # REMOVE or set True

            self.minimap_canvas = tk.Canvas(
                self.minimap_window, bg="dark slate gray", highlightthickness=0
            )
            # Make canvas fill the resizable window
            self.minimap_canvas.pack(fill=tk.BOTH, expand=True)  # MODIFIED pack options
            self.minimap_window.protocol("WM_DELETE_WINDOW", self._on_minimap_close)
            self.minimap_window.bind("<Configure>", self._on_minimap_configure)

            # Initial draw (will use initial geometry)
            # Need to ensure canvas has dimensions before first draw
            self.minimap_window.update_idletasks()  # Process geometry requests
            self.draw_minimap()
        else:
            self.minimap_window.lift()
            self.minimap_window.focus_set()

    def _on_minimap_close(self):
        """Handles the closing of the minimap window."""
        if self.minimap_window:
            self.minimap_window.destroy()  # Destroy the window
        self.minimap_window = None  # Reset state variable
        self.minimap_canvas = None

    def draw_minimap(self):
        if self.minimap_window is None or self.minimap_canvas is None:
            return
        if not tk.Toplevel.winfo_exists(self.minimap_window):
            self._on_minimap_close()
            return

        canvas_mm = self.minimap_canvas # Renamed
        canvas_mm.delete("all")

        current_minimap_w_px = canvas_mm.winfo_width()
        current_minimap_h_px = canvas_mm.winfo_height()
        if current_minimap_w_px <= 1 or current_minimap_h_px <= 1:
            return

        if (
            self.minimap_background_cache is None
            or self.minimap_bg_rendered_width != current_minimap_w_px
            or self.minimap_bg_rendered_height != current_minimap_h_px
        ):
            self.minimap_background_cache = self._create_minimap_background_image(
                current_minimap_w_px, current_minimap_h_px
            )

        if self.minimap_background_cache:
            canvas_mm.create_image(
                0, 0, image=self.minimap_background_cache, anchor=tk.NW, tags="minimap_bg_image"
            )
        else:
            canvas_mm.create_rectangle(
                0, 0, current_minimap_w_px, current_minimap_h_px, fill="gray10"
            )

        # Total map dimensions in base MSX pixels
        map_total_msx_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_total_msx_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT
        
        if map_total_msx_pixel_w <= 0 or map_total_msx_pixel_h <= 0:
            return

        scale_x_overlay = current_minimap_w_px / map_total_msx_pixel_w
        scale_y_overlay = current_minimap_h_px / map_total_msx_pixel_h
        scale_overlay = min(scale_x_overlay, scale_y_overlay)

        scaled_map_content_w_overlay = map_total_msx_pixel_w * scale_overlay
        scaled_map_content_h_overlay = map_total_msx_pixel_h * scale_overlay
        offset_x_overlay_render = (current_minimap_w_px - scaled_map_content_w_overlay) / 2
        offset_y_overlay_render = (current_minimap_h_px - scaled_map_content_h_overlay) / 2

        try:
            main_map_canvas = self.map_canvas # Renamed
            scroll_x_fractions = main_map_canvas.xview()
            scroll_y_fractions = main_map_canvas.yview()

            # Total BASE map dimensions in MSX pixels (same as map_total_msx_pixel_w/h above)
            # This is what the scroll fractions are relative to.
            # map_total_base_msx_w = map_width * self.supertile_grid_width * TILE_WIDTH
            # map_total_base_msx_h = map_height * self.supertile_grid_height * TILE_HEIGHT
            # No need to recalculate, use map_total_msx_pixel_w/h

            if map_total_msx_pixel_w > 0 and map_total_msx_pixel_h > 0:
                map_viewport_msx_px_x1 = scroll_x_fractions[0] * map_total_msx_pixel_w
                map_viewport_msx_px_y1 = scroll_y_fractions[0] * map_total_msx_pixel_h
                map_viewport_msx_px_x2 = scroll_x_fractions[1] * map_total_msx_pixel_w
                map_viewport_msx_px_y2 = scroll_y_fractions[1] * map_total_msx_pixel_h

                vp_x1_draw = offset_x_overlay_render + map_viewport_msx_px_x1 * scale_overlay
                vp_y1_draw = offset_y_overlay_render + map_viewport_msx_px_y1 * scale_overlay
                vp_x2_draw = offset_x_overlay_render + map_viewport_msx_px_x2 * scale_overlay
                vp_y2_draw = offset_y_overlay_render + map_viewport_msx_px_y2 * scale_overlay

                canvas_mm.create_rectangle(
                    vp_x1_draw, vp_y1_draw, vp_x2_draw, vp_y2_draw,
                    outline=self.MINIMAP_VIEWPORT_COLOR, width=2, tags="minimap_viewport"
                )
        except Exception as e:
            self.debug(f"[DEBUG]Error drawing minimap viewport: {e}")
            pass

        if self.show_window_view.get():
            try:
                win_tx_mm = self.window_view_tile_x # In base tiles
                win_ty_mm = self.window_view_tile_y
                win_tw_mm = self.window_view_tile_w.get()
                win_th_mm = self.window_view_tile_h.get()

                # Window view dimensions in MSX pixels
                win_map_msx_px1 = win_tx_mm * TILE_WIDTH
                win_map_msx_py1 = win_ty_mm * TILE_HEIGHT
                win_map_msx_px2 = win_map_msx_px1 + (win_tw_mm * TILE_WIDTH)
                win_map_msx_py2 = win_map_msx_py1 + (win_th_mm * TILE_HEIGHT)

                wv_x1_draw = offset_x_overlay_render + win_map_msx_px1 * scale_overlay
                wv_y1_draw = offset_y_overlay_render + win_map_msx_py1 * scale_overlay
                wv_x2_draw = offset_x_overlay_render + win_map_msx_px2 * scale_overlay
                wv_y2_draw = offset_y_overlay_render + win_map_msx_py2 * scale_overlay

                canvas_mm.create_rectangle(
                    wv_x1_draw, wv_y1_draw, wv_x2_draw, wv_y2_draw,
                    outline=self.MINIMAP_WIN_VIEW_COLOR, width=2, dash=(4, 4), tags="minimap_window_view"
                )
            except Exception as e:
                self.debug(f"[DEBUG]Error drawing minimap window view: {e}")
                pass

    def _on_minimap_configure(self, event):
        """Callback when the minimap window is resized/moved."""
        # We only care about size changes for redrawing
        # Basic debouncing: wait a short time after the last configure event
        # before redrawing to avoid excessive calls during drag-resizing.
        debounce_ms = 150  # Adjust as needed (milliseconds)

        # Cancel any pending redraw timer
        if self.minimap_resize_timer is not None:
            self.root.after_cancel(self.minimap_resize_timer)

        # Schedule a new redraw after the debounce period
        self.minimap_resize_timer = self.root.after(
            debounce_ms, self._redraw_minimap_after_resize
        )

    def _redraw_minimap_after_resize(self):
        self.minimap_resize_timer = None 

        if not self.minimap_window or not tk.Toplevel.winfo_exists(self.minimap_window):
            return

        if self._minimap_resizing_internally:
            return

        try:
            current_width_mm_cfg = self.minimap_window.winfo_width()
            current_height_mm_cfg = self.minimap_window.winfo_height()

            # Map aspect ratio based on total MSX pixels
            map_total_msx_pixel_w_cfg = map_width * self.supertile_grid_width * TILE_WIDTH
            map_total_msx_pixel_h_cfg = map_height * self.supertile_grid_height * TILE_HEIGHT

            if map_total_msx_pixel_h_cfg <= 0 or map_total_msx_pixel_w_cfg <= 0 or \
               current_width_mm_cfg <= 1 or current_height_mm_cfg <= 1:
                self.invalidate_minimap_background_cache()
                self.draw_minimap()
                return

            map_aspect_ratio_cfg = map_total_msx_pixel_w_cfg / map_total_msx_pixel_h_cfg
            ideal_height_cfg = int(round(current_width_mm_cfg / map_aspect_ratio_cfg))

            if abs(current_height_mm_cfg - ideal_height_cfg) > 1: # Allow 1px tolerance
                self._minimap_resizing_internally = True
                new_geometry_cfg = f"{current_width_mm_cfg}x{ideal_height_cfg}"
                self.debug(f"[DEBUG]Minimap Configure: Forcing aspect ratio. New geometry: {new_geometry_cfg}")
                self.minimap_window.geometry(new_geometry_cfg)
                self.root.after(50, setattr, self, "_minimap_resizing_internally", False)
                # Redraw will be triggered by the geometry change causing another <Configure>
                return 
        except Exception as e:
            self.debug(f"[DEBUG]Error during minimap aspect ratio enforcement: {e}")
            self._minimap_resizing_internally = False # Ensure flag is reset

        self.debug(f"[DEBUG]Minimap Configure: Aspect ratio OK or no change needed. Redrawing.")
        self.invalidate_minimap_background_cache()
        self.draw_minimap()

    def _trigger_minimap_reconfigure(self):
        """Forces the minimap to re-evaluate its size and aspect ratio if it exists."""
        if self.minimap_window and tk.Toplevel.winfo_exists(self.minimap_window):
            # A simple way to trigger <Configure> is to slightly change the size
            # We can just call the resize logic directly though.
            print("Map dimensions changed, triggering minimap aspect check/redraw.")
            # Reset the resize timer to avoid duplicate calls if configure is also pending
            if self.minimap_resize_timer is not None:
                self.root.after_cancel(self.minimap_resize_timer)
                self.minimap_resize_timer = None
            # Directly call the logic that handles resizing and drawing
            self._redraw_minimap_after_resize()

    def invalidate_minimap_background_cache(self):
        """Clears the cached minimap background image."""
        self.minimap_background_cache = None
        # Reset rendered size trackers too
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0

    def _create_minimap_background_image(self, target_width_mm, target_height_mm): # Renamed params
        if target_width_mm <= 0 or target_height_mm <= 0:
            return None

        minimap_img_bg = tk.PhotoImage(width=target_width_mm, height=target_height_mm) # Renamed
        
        # Base map pixel dimensions (MSX pixels, assuming TILE_WIDTH/HEIGHT are base tile MSX pixels)
        map_base_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_base_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT

        if map_base_pixel_w <= 0 or map_base_pixel_h <= 0:
            self.debug("[DEBUG]Warning: Invalid base map pixel dimensions for minimap background.")
            minimap_img_bg.put("black", to=(0, 0, target_width_mm, target_height_mm))
            # Update cache trackers even for fallback
            self.minimap_bg_rendered_width = target_width_mm
            self.minimap_bg_rendered_height = target_height_mm
            self.minimap_background_cache = minimap_img_bg
            return minimap_img_bg

        scale_x_mm = target_width_mm / map_base_pixel_w
        scale_y_mm = target_height_mm / map_base_pixel_h
        scale_mm = min(scale_x_mm, scale_y_mm)
        
        scaled_map_content_w = map_base_pixel_w * scale_mm
        scaled_map_content_h = map_base_pixel_h * scale_mm
        offset_x_mm_render = (target_width_mm - scaled_map_content_w) / 2
        offset_y_mm_render = (target_height_mm - scaled_map_content_h) / 2
        
        bg_fill_color_mm = "#000000" # Black for letter/pillarbox

        for y_pix_mm in range(target_height_mm):
            row_hex_colors_mm = []
            for x_pix_mm in range(target_width_mm):
                pixel_color_hex_mm = bg_fill_color_mm

                if (offset_x_mm_render <= x_pix_mm < offset_x_mm_render + scaled_map_content_w and
                    offset_y_mm_render <= y_pix_mm < offset_y_mm_render + scaled_map_content_h):

                    map_src_base_x = (x_pix_mm - offset_x_mm_render) / max(1e-9, scale_mm)
                    map_src_base_y = (y_pix_mm - offset_y_mm_render) / max(1e-9, scale_mm)

                    map_src_base_x = max(0, min(map_base_pixel_w - 1, map_src_base_x))
                    map_src_base_y = max(0, min(map_base_pixel_h - 1, map_src_base_y))

                    map_pixel_col_src = int(map_src_base_x)
                    map_pixel_row_src = int(map_src_base_y)

                    # Pixels per supertile width/height
                    pixels_per_st_w = self.supertile_grid_width * TILE_WIDTH
                    pixels_per_st_h = self.supertile_grid_height * TILE_HEIGHT
                    if pixels_per_st_w <=0 : pixels_per_st_w = 1 # Avoid div by zero
                    if pixels_per_st_h <=0 : pixels_per_st_h = 1


                    st_col_mm = map_pixel_col_src // pixels_per_st_w
                    st_row_mm = map_pixel_row_src // pixels_per_st_h

                    tile_col_in_st_mm = (map_pixel_col_src % pixels_per_st_w) // TILE_WIDTH
                    tile_row_in_st_mm = (map_pixel_row_src % pixels_per_st_h) // TILE_HEIGHT
                    
                    pixel_col_in_tile_mm = map_pixel_col_src % TILE_WIDTH
                    pixel_row_in_tile_mm = map_pixel_row_src % TILE_HEIGHT
                    
                    try:
                        # Ensure st_row_mm, st_col_mm are within map_data bounds
                        if 0 <= st_row_mm < map_height and 0 <= st_col_mm < map_width:
                            supertile_idx_mm = map_data[st_row_mm][st_col_mm]
                            if 0 <= supertile_idx_mm < num_supertiles:
                                # Ensure definition structure is valid for current ST dimensions
                                st_def_mm = supertiles_data[supertile_idx_mm]
                                if st_def_mm and len(st_def_mm) == self.supertile_grid_height and \
                                   (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(st_def_mm[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) and \
                                   0 <= tile_row_in_st_mm < self.supertile_grid_height and \
                                   0 <= tile_col_in_st_mm < self.supertile_grid_width:

                                    tile_idx_mm = st_def_mm[tile_row_in_st_mm][tile_col_in_st_mm]
                                    if 0 <= tile_idx_mm < num_tiles_in_set:
                                        # Check bounds for tile pattern/color access
                                        if 0 <= pixel_row_in_tile_mm < TILE_HEIGHT and \
                                           0 <= pixel_col_in_tile_mm < TILE_WIDTH:
                                            pattern_val_mm = tileset_patterns[tile_idx_mm][pixel_row_in_tile_mm][pixel_col_in_tile_mm]
                                            fg_idx_mm, bg_idx_mm = tileset_colors[tile_idx_mm][pixel_row_in_tile_mm]
                                            
                                            # Validate palette indices
                                            if not (0 <= fg_idx_mm < len(self.active_msx_palette) and \
                                                    0 <= bg_idx_mm < len(self.active_msx_palette)):
                                                self.debug(f"[DEBUG]Warning: Invalid palette indices ({fg_idx_mm}, {bg_idx_mm}) in minimap render.")
                                                fg_idx_mm = WHITE_IDX; bg_idx_mm = BLACK_IDX # Fallback

                                            fg_color_mm = self.active_msx_palette[fg_idx_mm]
                                            bg_color_mm = self.active_msx_palette[bg_idx_mm]
                                            pixel_color_hex_mm = fg_color_mm if pattern_val_mm == 1 else bg_color_mm
                                        else: pixel_color_hex_mm = INVALID_TILE_COLOR # pixel in tile out of bounds
                                    else: pixel_color_hex_mm = INVALID_TILE_COLOR # tile_idx_mm out of bounds
                                else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # ST def structure issue or tile in ST out of bounds
                            else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR # supertile_idx_mm out of bounds
                        else: pixel_color_hex_mm = "#808080" # Grey for outside map supertile grid
                    except IndexError:
                        pixel_color_hex_mm = "#FF0000" # Bright Red for major error
                
                row_hex_colors_mm.append(pixel_color_hex_mm)

            try:
                minimap_img_bg.put("{" + " ".join(row_hex_colors_mm) + "}", to=(0, y_pix_mm))
            except tk.TclError:
                self.debug(f"[DEBUG]Warning [Minimap BG]: TclError put row {y_pix_mm}: {e}")
                if row_hex_colors_mm:
                    minimap_img_bg.put(row_hex_colors_mm[0], to=(0, y_pix_mm, target_width_mm, y_pix_mm + 1))

        self.debug("[DEBUG]Minimap background generated.")
        self.minimap_bg_rendered_width = target_width_mm
        self.minimap_bg_rendered_height = target_height_mm
        self.minimap_background_cache = minimap_img_bg
        return minimap_img_bg

    def _update_window_title(self):
        """Updates the main window title based on the current project path."""
        base_title = "MSX Tile Forge"
        modifier = "*" if self.project_modified else ""

        if self.current_project_base_path:
            # Extract just the filename part
            project_name = os.path.basename(self.current_project_base_path)
            self.root.title(
                f"{base_title} - {project_name}{modifier}"
            )  # Prepend modifier
        else:
            self.root.title(f"{base_title} - Untitled{modifier}")  # Prepend modifier

    def _update_map_cursor(self):
        """Sets the map canvas cursor based on current action and modifier keys."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        new_cursor = ""  # Default arrow cursor

        # Determine cursor based on the active operation FIRST
        if self.current_mouse_action == "panning":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_dragging":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_resizing":
            new_cursor = "sizing"  # Generic resize
        elif self.map_selection_active:  # NEW: Selection in progress
            new_cursor = "crosshair"
        # --- Modifier key hints (if NO mouse action is active) ---
        elif self.is_ctrl_pressed:
            try:  # Check location for hinting
                canvas_x = self.map_canvas.canvasx(
                    self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                )
                canvas_y = self.map_canvas.canvasy(
                    self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                )
                handle = (
                    self._get_handle_at(canvas_x, canvas_y)
                    if self.show_window_view.get()
                    else None
                )
                if handle:
                    new_cursor = "sizing"  # Hint resize
                elif (
                    self._is_inside_window_view(canvas_x, canvas_y)
                    and self.show_window_view.get()
                ):
                    new_cursor = "fleur"  # Hint window drag
                else:
                    new_cursor = "hand2"  # Hint panning
            except tk.TclError:
                new_cursor = "hand2"  # Default hint for Ctrl pressed
        elif self.is_shift_pressed:  # NEW: Shift held, no action -> hint selection
            new_cursor = "crosshair"
        # --- Default action (if no action and no relevant modifier) ---
        else:
            new_cursor = "pencil"  # Default paint cursor

        # Only change the cursor if it's different
        try:
            current_cursor = self.map_canvas.cget("cursor")
            if current_cursor != new_cursor:
                self.map_canvas.config(cursor=new_cursor)
        except tk.TclError:
            pass

    def handle_ctrl_press(self, event):
        """Handles Control key press."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state and cursor if Ctrl wasn't already considered pressed
            if not self.is_ctrl_pressed:
                self.is_ctrl_pressed = True
                # Update cursor only if no mouse action is currently happening
                # If a mouse button is down, let the existing action determine cursor
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_ctrl_release(self, event):
        """Handles Control key release. Stops panning if active."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state if Ctrl was actually considered pressed
            if self.is_ctrl_pressed:
                self.is_ctrl_pressed = False
                # If panning was the current action, stop it.
                # Window dragging/resizing continues until mouse release even if Ctrl comes up.
                if self.current_mouse_action == "panning":
                    self.current_mouse_action = None
                self._update_map_cursor()

    def handle_pan_start(self, event):
        """Handles the start of panning (Ctrl + Left Click) OR window dragging with Ctrl."""
        # --- Check for Shift modifier ---
        if self.is_shift_pressed:
            self.debug("[DEBUG]Shift pressed, ignoring Ctrl-Button-1 for pan/window drag.")
            return "break"
        # --- End Shift Check ---

        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if not ctrl_pressed_at_click or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # --- Clear previous selection when starting pan/window drag ---
        self._clear_map_selection()  # Clear selection visual and state
        # --- End Clear Selection ---

        if (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            self.current_mouse_action = "window_dragging"
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self._update_map_cursor()
        else:
            # Initiate PANNING
            self.current_mouse_action = "panning"
            canvas.scan_mark(event.x, event.y)
            self._update_map_cursor()

        return "break"

    def handle_pan_motion(self, event):
        """Handles mouse motion during panning OR window dragging with Ctrl."""
        if self.current_mouse_action not in ["panning", "window_dragging"]:
            return

        canvas = self.map_canvas

        if self.current_mouse_action == "panning":
            canvas.scan_dragto(event.x, event.y, gain=1)
            # After scan_dragto, the view has changed, so redraw the map content
            self.draw_map_canvas() # <<< ADDED THIS LINE
            self.draw_minimap()    # Minimap was already being updated

        elif self.current_mouse_action == "window_dragging":
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)
            self._do_window_move_drag(canvas_x, canvas_y) # This calls draw_map_canvas internally if needed

        return "break"

    def handle_canvas_enter(self, event):
        """Handles mouse entering the canvas area."""
        # Set cursor based on current state
        self._update_map_cursor()

        # --- >> ADDED: Draw paste preview on enter if applicable << ---
        if event.widget == self.map_canvas:
            is_map_tab_active = False
            if self.notebook and self.notebook.winfo_exists():
                try:
                     selected_tab_index = self.notebook.index(self.notebook.select())
                     if selected_tab_index == 3: # Map Editor tab index
                         is_map_tab_active = True
                except tk.TclError:
                    pass # Ignore if notebook not ready

            # Draw preview if map tab active and clipboard has data
            if is_map_tab_active and self.map_clipboard_data:
                self._draw_paste_preview_rect(event=event)

    def handle_canvas_leave(self, event):
        """Handles mouse leaving the canvas area."""
        # Reset cursor to default when leaving, unless an action is in progress
        if self.current_mouse_action is None:
            # Only reset if the specific widget leaving is the map canvas
            if event.widget == self.map_canvas:
                try:
                    if self.map_canvas.winfo_exists():
                        self.map_canvas.config(cursor="")
                except tk.TclError:
                    pass # Ignore if destroyed

        # Reset coordinate display when mouse leaves map canvas
        if event.widget == self.map_canvas and hasattr(self, "map_coords_label"):
            self.map_coords_label.config(text="ST Coords: -, -")

        # Clear paste preview when leaving map canvas
        if event.widget == self.map_canvas:
            self._clear_paste_preview_rect()

    def _update_edit_menu_state(self):
        if not self.edit_menu:
            self.debug("[DEBUG] _update_edit_menu_state: self.edit_menu is None. Aborting.")
            return
        if not tk.Menu.winfo_exists(self.edit_menu): # Check if menu widget still exists
            self.debug("[DEBUG] _update_edit_menu_state: self.edit_menu widget no longer exists. Aborting.")
            return

        self.debug(f"[DEBUG] _update_edit_menu_state: Attempting to update. Copy index: {self.copy_menu_item_index}, Paste index: {self.paste_menu_item_index}")

        if self.copy_menu_item_index == -1 or self.paste_menu_item_index == -1:
            self.debug("[DEBUG] _update_edit_menu_state: Stored menu item indices are -1. Aborting.")
            return

        # --- ADD MORE DEBUGGING HERE ---
        if self.debug_enabled: 
            try:
                actual_copy_type = self.edit_menu.type(self.copy_menu_item_index)
                actual_paste_type = self.edit_menu.type(self.paste_menu_item_index)
                self.debug(f"[DEBUG] _update_edit_menu_state: Actual type of item at copy_menu_item_index ({self.copy_menu_item_index}) is '{actual_copy_type}'")
                self.debug(f"[DEBUG] _update_edit_menu_state: Actual type of item at paste_menu_item_index ({self.paste_menu_item_index}) is '{actual_paste_type}'")

                num_items_now = self.edit_menu.index(tk.END) # This can be None if menu is empty
                if num_items_now is not None:
                    self.debug(f"[DEBUG] _update_edit_menu_state: Total items in edit_menu NOW: {num_items_now + 1}")
                    for i in range(num_items_now + 1):
                        item_type_str = self.edit_menu.type(i)
                        item_label_str = 'N/A'
                        if item_type_str == 'command':
                            item_label_str = self.edit_menu.entrycget(i, 'label')
                        elif item_type_str == 'cascade':
                             item_label_str = self.edit_menu.entrycget(i, 'label') + " (Cascade)"
                        # Add other types if necessary (checkbutton, radiobutton, separator)
                        self.debug(f"  [DEBUG] _update_edit_menu_state: Item {i}: Type='{item_type_str}', Label='{item_label_str}'")
                else:
                    self.debug("[DEBUG] _update_edit_menu_state: edit_menu.index(tk.END) is None (menu might be empty or not fully formed).")


            except tk.TclError as e_debug_update:
                self.debug(f"[DEBUG] _update_edit_menu_state: TclError during debug print: {e_debug_update}")
        # --- END MORE DEBUGGING ---

        selected_tab_index = 0 
        try:
            if self.notebook and self.notebook.winfo_exists():
                current_selection = self.notebook.select()
                if current_selection:
                    selected_tab_index = self.notebook.index(current_selection)
        except tk.TclError:
            selected_tab_index = 0 

        can_copy = False
        can_paste = False
        copy_label = "Copy"
        paste_label = "Paste"

        if selected_tab_index == 1: 
            copy_label = "Copy Tile"
            paste_label = "Paste Tile"
            can_copy = 0 <= current_tile_index < num_tiles_in_set
            can_paste = (
                tile_clipboard_pattern is not None
                and 0 <= current_tile_index < num_tiles_in_set
            )

        elif selected_tab_index == 2: 
            copy_label = "Copy Supertile"
            paste_label = "Paste Supertile"
            can_copy = 0 <= current_supertile_index < num_supertiles
            can_paste = (
                supertile_clipboard_data is not None
                and 0 <= current_supertile_index < num_supertiles
            )

        elif selected_tab_index == 3: 
            copy_label = "Copy Map Region"
            paste_label = "Paste Map Region"
            can_copy = (
                self.map_selection_start_st is not None
                and self.map_selection_end_st is not None
            )
            can_paste = self.map_clipboard_data is not None

        else: 
            self.debug(f"[DEBUG] _update_edit_menu_state: Tab index is {selected_tab_index}. Setting Copy/Paste disabled.")
            copy_label = "Copy"
            paste_label = "Paste"
            can_copy = False
            can_paste = False

        copy_state = tk.NORMAL if can_copy else tk.DISABLED
        paste_state = tk.NORMAL if can_paste else tk.DISABLED

        try:
            # Re-check types just before configuring, in case the debug prints above are misleading due to timing
            current_copy_type_final_check = self.edit_menu.type(self.copy_menu_item_index)
            current_paste_type_final_check = self.edit_menu.type(self.paste_menu_item_index)

            if current_copy_type_final_check == "command":
                self.edit_menu.entryconfig(
                    self.copy_menu_item_index, state=copy_state, label=copy_label
                )
            else:
                self.debug(f"[DEBUG] _update_edit_menu_state FINAL CHECK ERROR: Item at copy index {self.copy_menu_item_index} is type '{current_copy_type_final_check}', not 'command'.")


            if current_paste_type_final_check == "command":
                self.edit_menu.entryconfig(
                    self.paste_menu_item_index, state=paste_state, label=paste_label
                )
            else:
                self.debug(f"[DEBUG] _update_edit_menu_state FINAL CHECK ERROR: Item at paste index {self.paste_menu_item_index} is type '{current_paste_type_final_check}', not 'command'.")


        except tk.TclError as e:
            self.debug(f"[DEBUG] _update_edit_menu_state: TclError during entryconfig: {e}")
            pass
        except Exception as e:
            self.debug(f"[DEBUG] _update_edit_menu_state: UNEXPECTED ERROR during menu update: {e}")
            pass

    def handle_generic_copy(self):
        """Handles the generic 'Copy' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return # Cannot determine active tab

        # Clear map clipboard and preview ONLY if copy action is NOT for map region
        if active_tab_index != 3:
            # Check if map clipboard actually needs clearing before doing work
            if self.map_clipboard_data is not None:
                self.map_clipboard_data = None
                self._clear_paste_preview_rect()
                # Update menu state since map paste is now disabled
                self._update_edit_menu_state() # Update only if clipboard was cleared

        # Perform copy based on active tab
        if active_tab_index == 1:  # Tile Editor Tab
            self.copy_current_tile()
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.copy_current_supertile()
        elif active_tab_index == 3:  # Map Editor Tab
            norm_coords = self._get_normalized_selection_st()
            if norm_coords: # If a selection exists, perform the copy
                min_c, min_r, max_c, max_r = norm_coords
                sel_w = max_c - min_c + 1
                sel_h = max_r - min_r + 1
                copied_data = []
                for r_idx in range(min_r, max_r + 1):
                    row_data = []
                    for c_idx in range(min_c, max_c + 1):
                        if 0 <= r_idx < map_height and 0 <= c_idx < map_width:
                            row_data.append(map_data[r_idx][c_idx])
                        else:
                            row_data.append(0)  # Append default if outside map
                    copied_data.append(row_data)

                # Set the map clipboard
                self.map_clipboard_data = {
                    "width": sel_w,
                    "height": sel_h,
                    "data": copied_data,
                }
                # Clear selection visual/state after successful copy
                self._clear_map_selection()
                # Explicitly clear any old paste preview visual
                self._clear_paste_preview_rect()
                # Redraw map canvas to remove selection rectangle
                self.draw_map_canvas()
                # Update menu state (enables Paste)
                self._update_edit_menu_state()
                # Attempt to draw the *new* paste preview based on current mouse pos
                try:
                    pointer_x = self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                    pointer_y = self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                    if (0 <= pointer_x < self.map_canvas.winfo_width() and
                        0 <= pointer_y < self.map_canvas.winfo_height()):
                        canvas_x = self.map_canvas.canvasx(pointer_x)
                        canvas_y = self.map_canvas.canvasy(pointer_y)
                        self._draw_paste_preview_rect(canvas_coords=(canvas_x, canvas_y))
                except Exception:
                     pass # Ignore errors getting pointer position

            # else: # If no selection exists, simply do nothing for the map clipboard
            #    print("Copy Map Region: No selection active.") # Optional info message

    def handle_generic_paste(self):
        """Handles the generic 'Paste' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return 

        # Clear marks before any paste operation, if they are active
        # This needs to be done carefully to ensure the correct redraw happens.
        marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)

        if active_tab_index == 1:  # Tile Editor Tab
            self.paste_tile() # This will call update_all_displays if marks were not cleared
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.paste_supertile() # This will call update_all_displays if marks were not cleared
        elif active_tab_index == 3:  # Map Editor Tab 
            if self.map_clipboard_data:
                canvas = self.map_canvas
                try:
                    pointer_x = canvas.winfo_pointerx()
                    pointer_y = canvas.winfo_pointery()
                    root_x = canvas.winfo_rootx()
                    root_y = canvas.winfo_rooty()
                    canvas_x = canvas.canvasx(pointer_x - root_x)
                    canvas_y = canvas.canvasy(pointer_y - root_y)
                except tk.TclError:
                    messagebox.showerror("Paste Error", "Could not get mouse position.")
                    if marks_were_cleared: self.update_all_displays(changed_level="all") # Redraw if marks cleared but paste failed
                    return

                paste_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)
                if paste_coords is None:
                    if marks_were_cleared: self.update_all_displays(changed_level="all")
                    return

                paste_st_col, paste_st_row = paste_coords
                clip_w = self.map_clipboard_data["width"]
                clip_h = self.map_clipboard_data["height"]
                clip_data = self.map_clipboard_data["data"]
                modified = False

                for r_offset in range(clip_h):
                    for c_offset in range(clip_w):
                        target_map_row = paste_st_row + r_offset
                        target_map_col = paste_st_col + c_offset

                        if (0 <= target_map_row < map_height and 0 <= target_map_col < map_width):
                            if r_offset < len(clip_data) and c_offset < len(clip_data[r_offset]):
                                st_index_to_paste = clip_data[r_offset][c_offset]
                                if map_data[target_map_row][target_map_col] != st_index_to_paste:
                                    map_data[target_map_row][target_map_col] = st_index_to_paste
                                    modified = True

                if modified:
                    self._mark_project_modified()
                    self.invalidate_minimap_background_cache()
                    # If marks were already cleared, this redraw is fine.
                    # If not, paste_tile/paste_supertile would have handled a more targeted redraw.
                    # For map paste, a full map canvas redraw is generally needed.
                    self.draw_map_canvas()  
                    self.draw_minimap()  
                # else:
                #    print("Paste: No changes made to map.")

            else:
                messagebox.showinfo("Paste", "Map clipboard is empty.")
                # If marks were cleared but no paste happened, still need to redraw
                if marks_were_cleared: self.update_all_displays(changed_level="all")

        # If marks were cleared by this paste operation and no specific redraw happened in the branches
        if marks_were_cleared and active_tab_index not in [1, 2, 3]: # e.g. if on palette tab
            self.update_all_displays(changed_level="all")

    def _setup_global_key_bindings(self):
        """Sets up global keyboard shortcuts (accelerators) for menu commands."""
        self.root.bind_all("<Control-n>", lambda event: self.new_project())
        self.root.bind_all("<Control-o>", lambda event: self.open_project())
        self.root.bind_all("<Control-s>", lambda event: self.save_project())
        self.root.bind_all(
            "<Control-Shift-KeyPress-S>", lambda event: self.save_project_as()
        )
        # MODIFIED: Ctrl+Q should also go through confirm_quit
        self.root.bind_all("<Control-q>", lambda event: self.confirm_quit())

        self.root.bind_all("<Control-c>", lambda event: self.handle_generic_copy())
        self.root.bind_all("<Control-v>", lambda event: self.handle_generic_paste())
        self.root.bind_all("<Control-m>", lambda event: self.toggle_minimap())

        self.debug("[DEBUG] Global key bindings set up.")

    def handle_map_tab_keypress(self, event):
        """Handles key presses specifically bound when the Map Tab is active."""
        key = event.keysym.lower()

        if key == "g":  # MODIFIED CHECK
            # Only cycle color if the key is 'g' (this handler is only active on map tab)
            self.cycle_grid_color()
            return "break"  # Prevent any other default actions for 'g'

    def _place_tile_in_supertile(self, r_place, c_place): # Renamed r, c
        global supertiles_data, current_supertile_index, selected_tile_for_supertile # Globals
        
        if not (0 <= current_supertile_index < num_supertiles):
            return False
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return False
        
        # Check against current project's supertile dimensions
        if not (0 <= r_place < self.supertile_grid_height and 0 <= c_place < self.supertile_grid_width):
            return False

        # Ensure definition structure is consistent before trying to access/modify
        current_definition_place = supertiles_data[current_supertile_index]
        if not current_definition_place or len(current_definition_place) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition_place[0]) != self.supertile_grid_width)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dim mismatch in _place_tile_in_supertile.")
            return False


        if current_definition_place[r_place][c_place] != selected_tile_for_supertile:
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            # Modify the global supertiles_data directly
            supertiles_data[current_supertile_index][r_place][c_place] = selected_tile_for_supertile
            
            self.invalidate_supertile_cache(current_supertile_index)
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="supertile")
            else: # Marks were cleared
                self.update_all_displays(changed_level="all") # Ensure full redraw
            self._mark_project_modified()
            return True
        else:
            return False

    def handle_supertile_def_drag(self, event):
        if not (0 <= selected_tile_for_supertile < num_tiles_in_set):
            return

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile
        mini_tile_dsize = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_dsize <= 0 or not canvas.winfo_exists():
            return

        col_drag = event.x // mini_tile_dsize
        row_drag = event.y // mini_tile_dsize

        current_cell_drag = (row_drag, col_drag)

        # Check bounds against current project's supertile dimensions
        # The _place_tile_in_supertile will do the ultimate bounds check against self.sgw/sgh
        if (0 <= row_drag < self.supertile_grid_height and \
            0 <= col_drag < self.supertile_grid_width and \
            current_cell_drag != self.last_placed_supertile_cell):

            placed_drag = self._place_tile_in_supertile(row_drag, col_drag)

            if placed_drag:
                self.last_placed_supertile_cell = current_cell_drag

    def handle_supertile_def_release(self, event):
        """Resets the drag state when the mouse button is released over the supertile definition canvas."""
        self.last_placed_supertile_cell = None

    def _update_map_coords_display(self, event):
        """Updates the coordinate label based on mouse motion over the map canvas."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        canvas = self.map_canvas
        try:
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)

            # Calculate supertile size at current zoom USING PROJECT DIMENSIONS
            zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims() # <--- USE THIS

            if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0: # Check both
                if hasattr(self, "map_coords_label"):
                    self.map_coords_label.config(text="ST Coords: Error")
                return

            # Calculate supertile row/col
            st_col = int(canvas_x // zoomed_st_pixel_w) # Use width for col
            st_row = int(canvas_y // zoomed_st_pixel_h) # Use height for row

            if 0 <= st_row < map_height and 0 <= st_col < map_width:
                coords_text = f"ST Coords: {st_col}, {st_row}"
            else:
                coords_text = "ST Coords: Out"

            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text=coords_text)

        except Exception as e:
            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text="ST Coords: Error")

    def _mark_project_modified(self):
        """Sets the project modified flag to True and updates the window title if needed."""
        if not self.project_modified:
            self.project_modified = True
            self._update_window_title()  # Update title when first marked as modified

    def flip_supertile_horizontal(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        if not (0 <= current_supertile_index < num_supertiles):
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition = supertiles_data[current_supertile_index]
        
        # Ensure definition structure matches project settings before modification
        if not current_definition or len(current_definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition[0]) != self.supertile_grid_width)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for horizontal flip.")
            # Optionally show error or skip
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile") # Redraw to show original if error
            return

        new_definition_flipped = []
        for r_flip_h in range(self.supertile_grid_height): # Iterate through rows
            # Ensure row exists and is a list before reversing
            if r_flip_h < len(current_definition) and isinstance(current_definition[r_flip_h], list):
                 new_definition_flipped.append(current_definition[r_flip_h][::-1]) # Reverse each row
            else: # Handle malformed row, append a blank row of correct width
                 new_definition_flipped.append([0] * self.supertile_grid_width)


        supertiles_data[current_supertile_index] = new_definition_flipped

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else: # Marks were cleared
            self.update_all_displays(changed_level="all") # Ensure full redraw
        print(f"Supertile {current_supertile_index} flipped horizontally.")

    def flip_supertile_vertical(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        if not (0 <= current_supertile_index < num_supertiles):
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_to_flip = supertiles_data[current_supertile_index]
        
        # Optional: Check if current_definition_to_flip actual height matches self.supertile_grid_height
        if len(current_definition_to_flip) != self.supertile_grid_height:
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} height mismatch for vertical flip. Proceeding with actual length.")
            # This might indicate inconsistent data. For robustness, one might pad/truncate current_definition_to_flip
            # to self.supertile_grid_height before reversing, or create a new list.
            # For now, we reverse what's there.
            pass

        current_definition_to_flip.reverse() # Reverses the list of rows

        # No need to reassign to supertiles_data[current_supertile_index] as reverse() is in-place

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} flipped vertically.")

    def rotate_supertile_90cw(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        if not (0 <= current_supertile_index < num_supertiles):
            return

        # --- Disable rotation for non-square supertiles ---
        if self.supertile_grid_width != self.supertile_grid_height:
            messagebox.showinfo("Rotate Supertile", "Rotation is only enabled for square supertiles.", parent=self.root)
            return
        # --- End disable ---

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_rotate = supertiles_data[current_supertile_index]
        
        # Since it's square, dim_rotate = self.supertile_grid_width (or height)
        dim_rotate = self.supertile_grid_width 
        
        # Ensure definition structure matches before rotation
        if not current_definition_rotate or len(current_definition_rotate) != dim_rotate or \
           (dim_rotate > 0 and (len(current_definition_rotate[0]) != dim_rotate)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for rotation.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        new_definition_rotated = [[0 for _c in range(dim_rotate)] for _r in range(dim_rotate)]

        for r_rot in range(dim_rotate):
            for c_rot in range(dim_rotate):
                # Check bounds just in case definition was malformed despite earlier check
                if r_rot < len(current_definition_rotate) and c_rot < len(current_definition_rotate[r_rot]):
                    new_definition_rotated[c_rot][(dim_rotate - 1) - r_rot] = current_definition_rotate[r_rot][c_rot]
                # Else, new_definition_rotated already has 0 for that cell

        supertiles_data[current_supertile_index] = new_definition_rotated

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} rotated 90 CW.")

    def shift_supertile_up(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_height = self.supertile_grid_height # Use current project setting
        if not (0 <= current_supertile_index < num_supertiles) or current_st_height <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift = supertiles_data[current_supertile_index]
        
        # Ensure definition structure matches project settings
        if not current_definition_shift or len(current_definition_shift) != current_st_height:
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} height mismatch for shift up.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return
        
        # Store the first row (which will wrap around to the bottom)
        # Ensure it's a deepcopy if rows themselves are mutable lists and you want to avoid aliasing issues,
        # though for lists of integers (tile indices), direct assignment is fine for the row itself.
        first_row_data = current_definition_shift[0][:] # Shallow copy of the row is sufficient

        for r_shift_up in range(current_st_height - 1):
            current_definition_shift[r_shift_up] = current_definition_shift[r_shift_up + 1]

        current_definition_shift[current_st_height - 1] = first_row_data
        
        # No need to reassign to supertiles_data as modification is in-place

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted up.")

    def shift_supertile_down(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_height = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_height <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_d = supertiles_data[current_supertile_index]

        if not current_definition_shift_d or len(current_definition_shift_d) != current_st_height:
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} height mismatch for shift down.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return
            
        last_row_data = current_definition_shift_d[current_st_height - 1][:] # Shallow copy

        for r_shift_d in range(current_st_height - 1, 0, -1):
            current_definition_shift_d[r_shift_d] = current_definition_shift_d[r_shift_d - 1]

        current_definition_shift_d[0] = last_row_data

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted down.")

    def shift_supertile_left(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global
        
        current_st_w = self.supertile_grid_width
        current_st_h = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w <= 0 or current_st_h <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_l = supertiles_data[current_supertile_index]

        # Basic structure check
        if not current_definition_shift_l or len(current_definition_shift_l) != current_st_h or \
           (current_st_h > 0 and (len(current_definition_shift_l[0]) != current_st_w)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift left.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        for r_shift_l in range(current_st_h): # Iterate through each row
            # Ensure row exists (it should, based on height check)
            if r_shift_l < len(current_definition_shift_l):
                row_data_list = current_definition_shift_l[r_shift_l]
                # Ensure row_data_list has expected width
                if len(row_data_list) == current_st_w and current_st_w > 0 :
                    first_tile_in_row = row_data_list[0]
                    for c_shift_l in range(current_st_w - 1):
                        row_data_list[c_shift_l] = row_data_list[c_shift_l + 1]
                    row_data_list[current_st_w - 1] = first_tile_in_row
                # else: Malformed row width, skip shifting this row or pad/error. For now, skip.
            # else: Malformed definition (too few rows), skip.

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted left.")

    def shift_supertile_right(self):
        global supertiles_data, current_supertile_index, num_supertiles # supertiles_data global

        current_st_w = self.supertile_grid_width
        current_st_h = self.supertile_grid_height
        if not (0 <= current_supertile_index < num_supertiles) or current_st_w <= 0 or current_st_h <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            self.update_all_displays(changed_level="all")

        current_definition_shift_r = supertiles_data[current_supertile_index]

        if not current_definition_shift_r or len(current_definition_shift_r) != current_st_h or \
           (current_st_h > 0 and (len(current_definition_shift_r[0]) != current_st_w)):
            self.debug(f"[DEBUG]Warning: Supertile {current_supertile_index} dimensions mismatch for shift right.")
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                 self.update_all_displays(changed_level="supertile")
            return

        for r_shift_r in range(current_st_h):
            if r_shift_r < len(current_definition_shift_r):
                row_data_list_r = current_definition_shift_r[r_shift_r]
                if len(row_data_list_r) == current_st_w and current_st_w > 0:
                    last_tile_in_row = row_data_list_r[current_st_w - 1]
                    for c_shift_r in range(current_st_w - 1, 0, -1):
                        row_data_list_r[c_shift_r] = row_data_list_r[c_shift_r - 1]
                    row_data_list_r[0] = last_tile_in_row
                # else: Malformed row width
            # else: Malformed definition

        self._mark_project_modified()
        self.invalidate_supertile_cache(current_supertile_index)
        self.invalidate_minimap_background_cache()
        if not (self.marked_unused_tiles or self.marked_unused_supertiles):
            self.update_all_displays(changed_level="supertile")
        else:
            self.update_all_displays(changed_level="all")
        print(f"Supertile {current_supertile_index} shifted right.")

    def handle_supertile_def_right_click(self, event):
        global selected_tile_for_supertile, current_supertile_index, num_supertiles, num_tiles_in_set, supertiles_data

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile in editor
        mini_tile_disp_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_disp_size <= 0 or not canvas.winfo_exists():
            return

        col = event.x // mini_tile_disp_size
        row = event.y // mini_tile_disp_size

        # Check click against current project's supertile dimensions
        if (
            0 <= row < self.supertile_grid_height
            and 0 <= col < self.supertile_grid_width
            and 0 <= current_supertile_index < num_supertiles
        ):
            try:
                # Ensure definition structure matches before accessing
                definition_rc = supertiles_data[current_supertile_index]
                if not definition_rc or len(definition_rc) != self.supertile_grid_height or \
                   (self.supertile_grid_height > 0 and (len(definition_rc[0]) != self.supertile_grid_width)):
                    self.debug(f"[DEBUG]Warning: ST def {current_supertile_index} dim mismatch in right_click.")
                    return

                clicked_tile_index_val = definition_rc[row][col]

                if 0 <= clicked_tile_index_val < num_tiles_in_set:
                    if selected_tile_for_supertile != clicked_tile_index_val:
                        selected_tile_for_supertile = clicked_tile_index_val
                        self.debug(f"[DEBUG]Right-click selected Tile: {selected_tile_for_supertile}")
                        self.draw_tileset_viewer(
                            self.st_tileset_canvas, selected_tile_for_supertile
                        )
                        self.update_supertile_info_labels()
                        self.scroll_viewers_to_tile(selected_tile_for_supertile)
                # else:
                    self.debug(f"[DEBUG]Right-click: Tile index {clicked_tile_index_val} at ST def [{row},{col}] is out of tile bounds (max {num_tiles_in_set-1}).")

            except IndexError: # Should be caught by structure check above
                self.debug(f"[DEBUG]Right-click: IndexError accessing supertile data for ST {current_supertile_index} at def [{row},{col}].")
                pass
            except Exception as e:
                self.debug(f"[DEBUG]Right-click: Unexpected error in supertile def handler: {e}")
                pass
        # else: Click was outside the definition grid based on current W/H dimensions

    def handle_map_canvas_right_click(self, event):
        """Handles right-click on the map canvas to select the clicked supertile."""
        global selected_supertile_for_map, map_data, map_width, map_height, num_supertiles

        # Prevent interference with panning or other actions
        if self.current_mouse_action is not None:
            return "break"  # Stop event propagation if another action is active

        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        # Calculate zoomed supertile size
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return
        zoomed_supertile_size = SUPERTILE_GRID_DIM * zoomed_tile_size
        if zoomed_supertile_size <= 0:
            return

        # Get canvas coordinates (handles scrolling)
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Calculate map column and row in supertile units
        map_col = int(canvas_x // zoomed_supertile_size)
        map_row = int(canvas_y // zoomed_supertile_size)

        # Check if the click is within the map bounds
        if 0 <= map_row < map_height and 0 <= map_col < map_width:
            try:
                # Get the supertile index at the clicked map cell
                clicked_supertile_index = map_data[map_row][map_col]

                # Check if the retrieved supertile index is valid
                if 0 <= clicked_supertile_index < num_supertiles:
                    # Check if the selection actually changed
                    if selected_supertile_for_map != clicked_supertile_index:
                        selected_supertile_for_map = clicked_supertile_index
                        print(
                            f"Right-click selected Supertile: {selected_supertile_for_map}"
                        )
                        # Redraw the supertile selector in the map tab
                        self.draw_supertile_selector(
                            self.map_supertile_selector_canvas,
                            selected_supertile_for_map,
                        )
                        # Update the info label
                        self.update_map_info_labels()
                        # Scroll the selector to the selected supertile
                        self.scroll_selectors_to_supertile(selected_supertile_for_map)
                else:
                    print(
                        f"Right-click: Supertile index {clicked_supertile_index} at map [{map_row},{map_col}] is out of bounds (max {num_supertiles-1})."
                    )

            except IndexError:
                print(
                    f"Right-click: Error accessing map data at [{map_row},{map_col}]."
                )
            except Exception as e:
                print(f"Right-click: Unexpected error in map canvas handler: {e}")

    def _check_tile_usage(self, tile_index_check): # Renamed tile_index
        used_in_supertiles_list = [] # Renamed
        if not (0 <= tile_index_check < num_tiles_in_set):
            return used_in_supertiles_list

        for st_idx_check in range(num_supertiles):
            definition_check = supertiles_data[st_idx_check] # global
            
            # Check consistency of this definition with project settings
            if not definition_check or len(definition_check) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_check[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: Supertile {st_idx_check} has inconsistent dimensions in _check_tile_usage. Skipping.")
                continue # Skip this malformed supertile definition

            found_in_current_st = False
            for r_check in range(self.supertile_grid_height):
                for c_check in range(self.supertile_grid_width):
                    # Bounds check for r_check, c_check within definition_check already done by loops
                    # and the initial structure check.
                    if definition_check[r_check][c_check] == tile_index_check:
                        if st_idx_check not in used_in_supertiles_list:
                            used_in_supertiles_list.append(st_idx_check)
                        found_in_current_st = True
                        break 
                if found_in_current_st:
                    break 
        return used_in_supertiles_list

    def _check_supertile_usage(self, supertile_index):
        """Checks if a supertile_index is used in the map data.
        Returns a list of (row, col) map coordinates that use it.
        """
        used_in_map = []
        if not (0 <= supertile_index < num_supertiles):
            return used_in_map  # Invalid index

        for r in range(map_height):
            for c in range(map_width):
                if map_data[r][c] == supertile_index:
                    used_in_map.append((r, c))
        return used_in_map

    # --- NEW: Reference Update Helpers ---
    def _update_supertile_refs_for_tile_change(self, tile_idx_changed, action_type): # Renamed index, action
        # This method assumes supertiles_data (global) is correctly structured
        # according to self.supertile_grid_width and self.supertile_grid_height.

        for st_idx_update in range(num_supertiles):
            current_definition_update = supertiles_data[st_idx_update] # global

            # Basic check for definition consistency
            if not current_definition_update or len(current_definition_update) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(current_definition_update[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: Supertile {st_idx_update} has inconsistent dimensions in _update_supertile_refs. Skipping.")
                continue

            for r_update in range(self.supertile_grid_height):
                for c_update in range(self.supertile_grid_width):
                    # Bounds for r_update, c_update are implicitly handled by loops
                    # and the consistency check above.
                    current_tile_ref = current_definition_update[r_update][c_update]
                    
                    if action_type == "insert":
                        if current_tile_ref >= tile_idx_changed:
                            # current_definition_update[r_update][c_update] += 1
                            # It's safer to modify the global directly if that's the pattern
                            supertiles_data[st_idx_update][r_update][c_update] += 1
                    elif action_type == "delete":
                        if current_tile_ref == tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] = 0 # Replace deleted with tile 0
                        elif current_tile_ref > tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] -= 1
                    # else: No action for unknown action_type (already printed warning if that happened)
        
        # No specific warning for unknown action_type here, assumed to be handled by caller or design.

    def _update_map_refs_for_supertile_change(self, index, action):
        """Updates supertile indices in the map data after a supertile insert/delete.

        Args:
            index (int): The index where the supertile insert/delete occurred.
            action (str): 'insert' or 'delete'.
        """
        if action == "insert":
            # Increment references >= index
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] >= index:
                        map_data[r][c] += 1
        elif action == "delete":
            # Decrement references > index, set == index to 0
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] == index:
                        map_data[r][c] = 0  # Replace deleted with supertile 0
                    elif map_data[r][c] > index:
                        map_data[r][c] -= 1
        else:
            print(
                f"Warning: Unknown action '{action}' in _update_map_refs_for_supertile_change"
            )

    def _insert_tile(self, index):
        """Core logic to insert a blank tile at the specified index.

        Args:
            index (int): The index at which to insert.

        Returns:
            bool: True if insertion was successful, False otherwise.
        """
        global num_tiles_in_set, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX

        if not (
            0 <= index <= num_tiles_in_set
        ):  # Allow inserting at the end (index == count)
            print(
                f"Error: Insert tile index {index} out of range [0, {num_tiles_in_set}]."
            )
            return False
        if num_tiles_in_set >= MAX_TILES:
            print("Error: Cannot insert tile, maximum tiles reached.")
            # Optionally show messagebox if needed later, but core logic just returns False
            # messagebox.showwarning("Maximum Tiles", f"Cannot insert: Max {MAX_TILES} tiles reached.")
            return False

        # Create blank tile data
        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]

        # Insert into data lists
        tileset_patterns.insert(index, blank_pattern)
        tileset_colors.insert(index, blank_colors)
        # Remove the overflow if MAX_TILES was exceeded by insert (shouldn't happen due to check)
        # Although Python lists grow, our MAX_TILES implies a fixed-size array conceptually
        if len(tileset_patterns) > MAX_TILES:
            tileset_patterns.pop()
        if len(tileset_colors) > MAX_TILES:
            tileset_colors.pop()

        # Update references in supertiles
        self._update_supertile_refs_for_tile_change(index, "insert")

        # Mark modified AFTER successful data changes
        self._mark_project_modified()
        return True

    def _delete_tile(self, index):
        """Core logic to delete the tile at the specified index.

        Args:
            index (int): The index of the tile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global num_tiles_in_set, tileset_patterns, tileset_colors

        if not (0 <= index < num_tiles_in_set):
            print(
                f"Error: Delete tile index {index} out of range [0, {num_tiles_in_set - 1}]."
            )
            return False
        if num_tiles_in_set <= 1:
            print("Error: Cannot delete the last tile.")
            # messagebox.showwarning("Cannot Delete", "Cannot delete the last remaining tile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data lists
        del tileset_patterns[index]
        del tileset_colors[index]

        # Append dummy data to keep list size MAX_TILES (conceptually)
        # Or adjust MAX_TILES usage if lists are truly dynamic
        # For now, let's assume we might refill later, so keep placeholders?
        # Alternative: just let list shrink. Let's let it shrink.
        # tileset_patterns.append([[0]*TILE_WIDTH for _ in range(TILE_HEIGHT)])
        # tileset_colors.append([(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)])

        # Update references in supertiles
        self._update_supertile_refs_for_tile_change(index, "delete")

        # Mark modified AFTER successful data changes
        self._mark_project_modified()
        return True

    def _insert_supertile(self, index_to_insert_at): # Renamed index
        global num_supertiles, supertiles_data # supertiles_data is global

        if not (0 <= index_to_insert_at <= num_supertiles):
            self.debug(f"[DEBUG]Error: Insert supertile index {index_to_insert_at} out of range [0, {num_supertiles}].")
            return False
        if num_supertiles >= MAX_SUPERTILES:
            self.debug("[DEBUG]Error: Cannot insert supertile, maximum reached.")
            return False

        # Create blank supertile data using current project dimensions
        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]

        supertiles_data.insert(index_to_insert_at, blank_st_definition) # Inserts into global
        
        # If supertiles_data is meant to be strictly MAX_SUPERTILES in length (padded)
        if len(supertiles_data) > MAX_SUPERTILES:
            supertiles_data.pop() # Remove the last one if insertion exceeded MAX_SUPERTILES conceptual limit

        self._update_map_refs_for_supertile_change(index_to_insert_at, "insert")
        self._mark_project_modified()
        return True

    def _delete_supertile(self, index):
        """Core logic to delete the supertile at the specified index.

        Args:
            index (int): The index of the supertile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global num_supertiles, supertiles_data

        if not (0 <= index < num_supertiles):
            print(
                f"Error: Delete supertile index {index} out of range [0, {num_supertiles - 1}]."
            )
            return False
        if num_supertiles <= 1:
            print("Error: Cannot delete the last supertile.")
            # messagebox.showwarning("Cannot Delete", "Cannot delete the last remaining supertile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data list
        del supertiles_data[index]
        # Let list shrink

        # Update references in map
        self._update_map_refs_for_supertile_change(index, "delete")

        self._mark_project_modified()
        return True

    def _update_editor_button_states(self):
        global num_tiles_in_set, num_supertiles # Using globals

        # --- Tile Editor Buttons ---
        can_add_tile = num_tiles_in_set < MAX_TILES
        can_insert_tile = num_tiles_in_set < MAX_TILES # Same condition as adding for enabling insert
        can_delete_tile = num_tiles_in_set > 1

        if hasattr(self, "add_tile_button") and self.add_tile_button.winfo_exists():
            self.add_tile_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED
            )
        if hasattr(self, "add_many_tiles_button") and self.add_many_tiles_button.winfo_exists():
            self.add_many_tiles_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_tile_button") and self.insert_tile_button.winfo_exists():
            self.insert_tile_button.config(
                state=tk.NORMAL if can_insert_tile else tk.DISABLED
            )
        if hasattr(self, "delete_tile_button") and self.delete_tile_button.winfo_exists():
            self.delete_tile_button.config(
                state=tk.NORMAL if can_delete_tile else tk.DISABLED
            )

        can_add_supertile = num_supertiles < MAX_SUPERTILES 
        can_insert_supertile = num_supertiles < MAX_SUPERTILES # Same condition
        can_delete_supertile = num_supertiles > 1

        if hasattr(self, "add_supertile_button") and self.add_supertile_button.winfo_exists():
            self.add_supertile_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED
            )
        if hasattr(self, "add_many_supertiles_button") and self.add_many_supertiles_button.winfo_exists():
            self.add_many_supertiles_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_supertile_button") and self.insert_supertile_button.winfo_exists():
            self.insert_supertile_button.config(
                state=tk.NORMAL if can_insert_supertile else tk.DISABLED
            )
        if hasattr(self, "delete_supertile_button") and self.delete_supertile_button.winfo_exists():
            self.delete_supertile_button.config(
                state=tk.NORMAL if can_delete_supertile else tk.DISABLED
            )

    def handle_add_tile(self):  
        global num_tiles_in_set, current_tile_index
        
        # Clear marks BEFORE any modification that changes usage or indices
        if self._clear_marked_unused(trigger_redraw=False):
            # If marks were cleared, ensure a full redraw happens after other operations
            # by setting a flag or letting update_all_displays in success path handle it.
            # For simplicity here, we'll rely on the update_all_displays in the success path.
            pass

        success = self._insert_tile(num_tiles_in_set)  # Insert at the very end

        if success:
            num_tiles_in_set += 1
            new_tile_idx = num_tiles_in_set - 1
            current_tile_index = new_tile_idx  # Select the newly added tile

            self.clear_all_caches()  
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")  # Update everything
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()  
            # self._mark_project_modified() is called within _insert_tile
            print(f"Added new tile {new_tile_idx}")
        else:
            messagebox.showwarning(
                "Add Tile Failed", f"Could not add tile. Maximum {MAX_TILES} reached?"
            )

    def handle_insert_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if self._clear_marked_unused(trigger_redraw=False):
            pass # Full redraw will happen if successful

        insert_idx = current_tile_index
        success = self._insert_tile(insert_idx)

        if success:
            num_tiles_in_set += 1
            current_tile_index = insert_idx # Selection stays at the new blank tile

            if selected_tile_for_supertile >= insert_idx:
                selected_tile_for_supertile += 1
            # Clamp to be safe, though _insert_tile should ensure num_tiles_in_set is valid for this
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_tile
            print(f"Inserted tile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Tile Failed",
                f"Could not insert tile. Maximum {MAX_TILES} reached?",
            )

    def handle_delete_tile(self):
        global num_tiles_in_set, current_tile_index, selected_tile_for_supertile

        if num_tiles_in_set <= 1:
            messagebox.showinfo("Delete Tile", "Cannot delete the last tile.")
            return

        delete_idx = current_tile_index
        if not (0 <= delete_idx < num_tiles_in_set):
            messagebox.showerror("Delete Tile Error", "Invalid tile index selected.")
            return

        usage = self._check_tile_usage(delete_idx)
        confirm_msg = f"Delete Tile {delete_idx}?"
        if usage:
            confirm_msg += "\n\n*** WARNING! ***\nThis tile is used by the following Supertile(s):\n"
            confirm_msg += ", ".join(map(str, usage[:10]))  
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += (
                f"\n\nReferences in these Supertiles will be reset to Tile 0."
            )

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"):
            return
        
        # Adjust marked set BEFORE actual data deletion and BEFORE _delete_tile
        # because _delete_tile will change num_tiles_in_set which might affect _adjust_marked logic
        # if it relied on the old num_tiles_in_set.
        self._adjust_marked_indices_after_delete(self.marked_unused_tiles, delete_idx)

        success = self._delete_tile(delete_idx) # Core logic does NOT clear marks

        if success:
            num_tiles_in_set -= 1
            # Adjust selection: stay at index if possible, else clamp to new max
            current_tile_index = min(delete_idx, num_tiles_in_set - 1)
            current_tile_index = max(0, current_tile_index) # Ensure not -1 if last tile deleted

            # Adjust other selections if they pointed to deleted or higher index
            if selected_tile_for_supertile == delete_idx:
                selected_tile_for_supertile = 0 # Default to 0 if deleted
            elif selected_tile_for_supertile > delete_idx:
                selected_tile_for_supertile -= 1
            selected_tile_for_supertile = min(selected_tile_for_supertile, num_tiles_in_set -1)
            selected_tile_for_supertile = max(0, selected_tile_for_supertile)


            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # This will redraw with adjusted marks
            self.scroll_viewers_to_tile(current_tile_index)  
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _delete_tile
            print(f"Deleted tile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Tile Failed", "An error occurred during tile deletion."
            )

    def handle_add_supertile(self):  
        global num_supertiles, current_supertile_index

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        success = self._insert_supertile(num_supertiles)  

        if success:
            num_supertiles += 1
            new_st_idx = num_supertiles - 1
            current_supertile_index = new_st_idx  

            self.supertile_image_cache.clear()  
            self.invalidate_minimap_background_cache()
            self.update_all_displays(
                changed_level="all" # Changed to all
            )  
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_supertile
            print(f"Added new supertile {new_st_idx}")
        else:
            messagebox.showwarning(
                "Add Supertile Failed",
                f"Could not add supertile. Maximum {MAX_SUPERTILES} reached?",
            )

    def handle_insert_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        insert_idx = current_supertile_index
        success = self._insert_supertile(insert_idx)

        if success:
            num_supertiles += 1
            current_supertile_index = insert_idx

            if selected_supertile_for_map >= insert_idx:
                selected_supertile_for_map += 1
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles -1)

            self.supertile_image_cache.clear()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # Changed to all
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is called within _insert_supertile
            print(f"Inserted supertile at index {insert_idx}")
        else:
            messagebox.showwarning(
                "Insert Supertile Failed",
                f"Could not insert supertile. Maximum {MAX_SUPERTILES} reached?",
            )

    def handle_delete_supertile(self):
        global num_supertiles, current_supertile_index, selected_supertile_for_map

        if num_supertiles <= 1:
            messagebox.showinfo("Delete Supertile", "Cannot delete the last supertile.")
            return

        delete_idx = current_supertile_index
        if not (0 <= delete_idx < num_supertiles):
            messagebox.showerror(
                "Delete Supertile Error", "Invalid supertile index selected."
            )
            return

        usage = self._check_supertile_usage(delete_idx)
        confirm_msg = f"Delete Supertile {delete_idx}?"
        if usage:
            map_coords_str = ", ".join(
                [f"({r_idx},{c_idx})" for r_idx, c_idx in usage[:10]] # Renamed r,c
            )  
            confirm_msg += (
                "\n\n*** WARNING! ***\nThis supertile is used on the Map at:\n"
            )
            confirm_msg += map_coords_str
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += f"\n\nReferences on the Map will be reset to Supertile 0."

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"):
            return
        
        self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, delete_idx)

        success = self._delete_supertile(delete_idx) # Does not clear marks

        if success:
            num_supertiles -= 1
            current_supertile_index = min(delete_idx, num_supertiles - 1)
            current_supertile_index = max(0, current_supertile_index)


            if selected_supertile_for_map == delete_idx:
                selected_supertile_for_map = 0
            elif selected_supertile_for_map > delete_idx:
                selected_supertile_for_map -= 1
            selected_supertile_for_map = min(selected_supertile_for_map, num_supertiles - 1)
            selected_supertile_for_map = max(0, selected_supertile_for_map)


            self.supertile_image_cache.clear()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all") # Redraws with adjusted marks
            self.scroll_selectors_to_supertile(current_supertile_index)
            self._update_editor_button_states()
            # self._mark_project_modified() is in _delete_supertile
            print(f"Deleted supertile at index {delete_idx}")
        else:
            messagebox.showerror(
                "Delete Supertile Failed",
                "An error occurred during supertile deletion.",
            )

    def _reposition_tile(self, source_index_tile, target_index_tile): # Renamed
        global num_tiles_in_set, tileset_patterns, tileset_colors # Globals
        global current_tile_index, selected_tile_for_supertile, supertiles_data # Globals

        if not (0 <= source_index_tile < num_tiles_in_set):
            self.debug(f"[DEBUG]Error: Invalid source index {source_index_tile} for tile move.")
            return False
        
        # Clamp target_index_tile to be within valid bounds for insertion [0, num_tiles_in_set]
        # If target_index_tile == num_tiles_in_set, it means move to the very end.
        clamped_target_index_tile = max(0, min(target_index_tile, num_tiles_in_set))

        if source_index_tile == clamped_target_index_tile or \
           (clamped_target_index_tile == num_tiles_in_set and source_index_tile == num_tiles_in_set -1) : # Moving last item to end
             if source_index_tile == clamped_target_index_tile -1 and clamped_target_index_tile == num_tiles_in_set : # Moving last to end is okay
                  pass # Allow moving last to effectively be "at the end" which is its current pos + 1 for insert
             elif source_index_tile == clamped_target_index_tile :
                  return False # No move needed if source is already at target (and not the special end case)


        self.debug(f"[DEBUG]Repositioning Tile: From {source_index_tile} to {clamped_target_index_tile}")

        moved_pattern_data = tileset_patterns.pop(source_index_tile)
        moved_colors_data = tileset_colors.pop(source_index_tile)

        # Actual insertion index if target was after source (due to pop)
        actual_insert_idx = clamped_target_index_tile
        if clamped_target_index_tile > source_index_tile:
            actual_insert_idx -= 1
        actual_insert_idx = max(0, actual_insert_idx) # Ensure not negative after adjustment

        tileset_patterns.insert(actual_insert_idx, moved_pattern_data)
        tileset_colors.insert(actual_insert_idx, moved_colors_data)

        # Update Supertile References
        for st_idx_refo in range(num_supertiles):
            definition_refo = supertiles_data[st_idx_refo] # global
            if not definition_refo or len(definition_refo) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_refo[0]) != self.supertile_grid_width)):
                self.debug(f"[DEBUG]Warning: ST {st_idx_refo} dim mismatch in _reposition_tile. Skipping ref update.")
                continue

            for r_refo in range(self.supertile_grid_height):
                for c_refo in range(self.supertile_grid_width):
                    current_ref_val = definition_refo[r_refo][c_refo]
                    new_ref_val = current_ref_val

                    if current_ref_val == source_index_tile:
                        new_ref_val = actual_insert_idx
                    elif source_index_tile < actual_insert_idx: # Moved DOWN (target > source logically, actual_insert_idx reflects this)
                        if source_index_tile < current_ref_val <= actual_insert_idx:
                             new_ref_val = current_ref_val - 1
                    elif source_index_tile > actual_insert_idx: # Moved UP (target < source logically)
                        if actual_insert_idx <= current_ref_val < source_index_tile:
                             new_ref_val = current_ref_val + 1
                    
                    if new_ref_val != current_ref_val:
                         supertiles_data[st_idx_refo][r_refo][c_refo] = new_ref_val # Update global

        # Update Selections
        if current_tile_index == source_index_tile:
            current_tile_index = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < current_tile_index <= actual_insert_idx:
            current_tile_index -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= current_tile_index < source_index_tile:
            current_tile_index += 1

        if selected_tile_for_supertile == source_index_tile:
            selected_tile_for_supertile = actual_insert_idx
        elif source_index_tile < actual_insert_idx and source_index_tile < selected_tile_for_supertile <= actual_insert_idx:
            selected_tile_for_supertile -= 1
        elif source_index_tile > actual_insert_idx and actual_insert_idx <= selected_tile_for_supertile < source_index_tile:
            selected_tile_for_supertile += 1

        current_tile_index = max(0, min(current_tile_index, num_tiles_in_set - 1))
        selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, num_tiles_in_set - 1))

        self._mark_project_modified()
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.debug(f"[DEBUG]  Successfully moved Tile {source_index_tile} to {actual_insert_idx}")
        return True

    def _reposition_supertile(self, source_index_st, target_index_st): # Renamed
        global num_supertiles, supertiles_data, map_data, map_width, map_height # Globals
        global current_supertile_index, selected_supertile_for_map 

        if not (0 <= source_index_st < num_supertiles):
            self.debug(f"[DEBUG]Error: Invalid source index {source_index_st} for supertile move.")
            return False
        
        clamped_target_index_st = max(0, min(target_index_st, num_supertiles))

        if source_index_st == clamped_target_index_st or \
           (clamped_target_index_st == num_supertiles and source_index_st == num_supertiles -1) :
             if source_index_st == clamped_target_index_st -1 and clamped_target_index_st == num_supertiles :
                  pass
             elif source_index_st == clamped_target_index_st :
                  return False

        self.debug(f"[DEBUG]Repositioning Supertile: From {source_index_st} to {clamped_target_index_st}")

        moved_st_definition = supertiles_data.pop(source_index_st) # Global

        actual_insert_idx_st = clamped_target_index_st
        if clamped_target_index_st > source_index_st:
            actual_insert_idx_st -= 1
        actual_insert_idx_st = max(0, actual_insert_idx_st)

        supertiles_data.insert(actual_insert_idx_st, moved_st_definition) # Global

        # Update Map References
        for r_map_refo in range(map_height):
            for c_map_refo in range(map_width):
                current_map_ref = map_data[r_map_refo][c_map_refo] # Global
                new_map_ref = current_map_ref

                if current_map_ref == source_index_st:
                    new_map_ref = actual_insert_idx_st
                elif source_index_st < actual_insert_idx_st: 
                    if source_index_st < current_map_ref <= actual_insert_idx_st:
                         new_map_ref = current_map_ref - 1
                elif source_index_st > actual_insert_idx_st: 
                    if actual_insert_idx_st <= current_map_ref < source_index_st:
                         new_map_ref = current_map_ref + 1
                
                if new_map_ref != current_map_ref:
                     map_data[r_map_refo][c_map_refo] = new_map_ref # Global

        # Update Selections
        if current_supertile_index == source_index_st:
            current_supertile_index = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < current_supertile_index <= actual_insert_idx_st:
            current_supertile_index -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= current_supertile_index < source_index_st:
            current_supertile_index += 1

        if selected_supertile_for_map == source_index_st:
            selected_supertile_for_map = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st and source_index_st < selected_supertile_for_map <= actual_insert_idx_st:
            selected_supertile_for_map -= 1
        elif source_index_st > actual_insert_idx_st and actual_insert_idx_st <= selected_supertile_for_map < source_index_st:
            selected_supertile_for_map += 1

        current_supertile_index = max(0, min(current_supertile_index, num_supertiles - 1))
        selected_supertile_for_map = max(0, min(selected_supertile_for_map, num_supertiles - 1))

        self._mark_project_modified()
        self.supertile_image_cache.clear() # Clear all ST cache as many could have effectively changed ID
        self.invalidate_minimap_background_cache()
        self.debug(f"[DEBUG]  Successfully moved Supertile {source_index_st} to {actual_insert_idx_st}")
        return True

    def _get_index_from_canvas_coords(self, canvas, x_event, y_event, item_type_str):
        padding = 1
        items_across_calc = 0
        item_render_w = 0
        item_render_h = 0
        max_items_count = 0

        if not canvas.winfo_exists(): # Early exit if canvas is gone
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Canvas {canvas} does not exist.")
            return -1 

        if item_type_str == "tile":
            items_across_calc = NUM_TILES_ACROSS # Constant for tile viewers
            item_render_w = VIEWER_TILE_SIZE
            item_render_h = VIEWER_TILE_SIZE
            max_items_count = num_tiles_in_set
        elif item_type_str == "supertile":
            item_render_w = self.supertile_grid_width * TILE_WIDTH
            item_render_h = self.supertile_grid_height * TILE_HEIGHT
            max_items_count = num_supertiles

            if item_render_w <= 0 or item_render_h <= 0:
                self.debug(f"[DEBUG] _get_index_from_canvas_coords: Invalid item_render_w/h for supertile ({item_render_w}x{item_render_h}).")
                return -1

            actual_canvas_w = canvas.winfo_width()
            if actual_canvas_w <= 1: # Canvas not sized yet or too small
                self.debug(f"[DEBUG] _get_index_from_canvas_coords: actual_canvas_w ({actual_canvas_w}) too small for supertile.")
                return -1 

            # --- UNIFIED "FIT AS MANY AS POSSIBLE" LOGIC ---
            # This logic should now be identical to the one in draw_supertile_selector
            if item_render_w + (2 * padding) > actual_canvas_w : # Not even one fits with padding on both sides
                items_across_calc = 0 
                if item_render_w <= actual_canvas_w : # Fits if no padding considered for this check
                    items_across_calc = 1
                # else: it's wider than canvas, items_across_calc remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                if (item_render_w + padding) <= 0: # Avoid division by zero if item_render_w is huge negative (should not happen)
                    items_across_calc = 0
                else:
                    items_across_calc = (actual_canvas_w - padding) // (item_render_w + padding)
            
            items_across_calc = max(1, items_across_calc) # Ensure at least 1 item if possible
            self.debug(f"[DEBUG] _get_index_from_canvas_coords (supertile): CanvasW={actual_canvas_w}, ItemW={item_render_w}, Calculated items_across_calc={items_across_calc}")
            # --- END UNIFIED LOGIC ---

        else:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Error: Invalid item_type '{item_type_str}'")
            return -1

        if item_render_w <= 0 or item_render_h <= 0 or items_across_calc <= 0:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Error: Invalid calculated layout params for {item_type_str} (item_w={item_render_w}, item_h={item_render_h}, items_across={items_across_calc})")
            return -1

        try:
            canvas_content_x = canvas.canvasx(x_event)
            canvas_content_y = canvas.canvasy(y_event)
        except tk.TclError:
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: TclError getting canvasx/y for {item_type_str}. Canvas likely not ready.")
            return -1 

        # Calculate total content dimensions based on dynamic layout
        num_logical_rows_calc = math.ceil(max_items_count / items_across_calc) if items_across_calc > 0 else 0
        # Use actual_canvas_w for total_content_w if items_across_calc is based on it,
        # or derive from items_across_calc if that's the definitive count.
        # The scrollregion width in draw_supertile_selector is based on its items_across.
        # So, use items_across_calc here for consistency with how scrollregion is set.
        total_content_w = (items_across_calc * item_render_w) + ((items_across_calc + 1) * padding)
        total_content_h = (num_logical_rows_calc * item_render_h) + ((num_logical_rows_calc + 1) * padding)
        
        # Check if click is within the logical content area defined by items_across_calc
        # This check becomes more important if items_across_calc differs from what might physically fit
        # if the canvas is wider than what items_across_calc would fill.
        # However, with the unified logic, items_across_calc should reflect the drawn layout.
        if not (canvas_content_x >= 0 and canvas_content_x < total_content_w and \
                canvas_content_y >= 0 and canvas_content_y < total_content_h):
            # If click is outside the calculated total content width/height based on items_across_calc,
            # it might be in empty space if the canvas is wider than this content.
            # Consider it "outside grid content area".
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Click ({canvas_content_x},{canvas_content_y}) outside content area ({total_content_w}x{total_content_h}).")
            return -2 

        col_calc = 0
        if (item_render_w + padding) > 0 : # Avoid division by zero
            col_calc = int(canvas_content_x // (item_render_w + padding))
        
        row_calc = 0
        if (item_render_h + padding) > 0 : # Avoid division by zero
            row_calc = int(canvas_content_y // (item_render_h + padding))
        
        col_calc = max(0, col_calc) 
        row_calc = max(0, row_calc)

        index_calc = row_calc * items_across_calc + col_calc

        if 0 <= index_calc < max_items_count:
            return index_calc
        else:
            # Clicked within the logical grid area but beyond the last *valid* item.
            # This can signify a drop target at the end of the list.
            # Or it could be a click in an empty cell if the grid is not full.
            # Return max_items_count (the count) to indicate this "end of list" target or empty area.
            # For drag-and-drop, targetting max_items_count usually means "append".
            # For a simple click, if index_calc >= max_items_count, it means no valid item was clicked.
            # The caller (e.g., handle_viewer_drag_release or a click handler) needs to interpret this.
            # A click should probably only react if 0 <= index_calc < max_items_count.
            # A drag-release might use max_items_count as a valid drop target.
            self.debug(f"[DEBUG] _get_index_from_canvas_coords: Calculated index {index_calc} is >= max_items_count {max_items_count}. Returning {max_items_count}.")
            return max_items_count

    def handle_viewer_drag_motion(self, event):
        if self.drag_start_index == -1 or self.drag_item_type is None or self.drag_canvas is None:
            return

        canvas_motion = event.widget 

        if not self.drag_active:
            dx = event.x - self.drag_press_x
            dy = event.y - self.drag_press_y
            distance_squared = dx*dx + dy*dy

            if distance_squared >= (DRAG_THRESHOLD_PIXELS * DRAG_THRESHOLD_PIXELS):
                self.drag_active = True
                
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if self.drag_item_type == "tile":
                        other_highlight_idx = -1
                        if self.drag_canvas == self.tileset_canvas:
                             other_highlight_idx = selected_tile_for_supertile
                        elif self.drag_canvas == self.st_tileset_canvas:
                             other_highlight_idx = current_tile_index
                        self.draw_tileset_viewer(self.drag_canvas, other_highlight_idx) # Pass original selection
                    elif self.drag_item_type == "supertile":
                        other_highlight_idx_st = -1
                        if self.drag_canvas == self.supertile_selector_canvas:
                            other_highlight_idx_st = selected_supertile_for_map
                        elif self.drag_canvas == self.map_supertile_selector_canvas:
                            other_highlight_idx_st = current_supertile_index
                        self.draw_supertile_selector(self.drag_canvas, other_highlight_idx_st) # Pass original selection
                try:
                    if canvas_motion.winfo_exists():
                        canvas_motion.config(cursor="hand2")
                except tk.TclError: pass
            else:
                return # Threshold not met
        
        if not self.drag_active: 
            return

        target_canvas_for_indicator = self.drag_canvas # Indicator drawn on original drag canvas
        if not target_canvas_for_indicator or not target_canvas_for_indicator.winfo_exists():
            self.drag_active = False; self.drag_item_type = None; self.drag_start_index = -1; self.drag_canvas = None
            if self.drag_indicator_id and canvas_motion.winfo_exists():
                try: canvas_motion.delete(self.drag_indicator_id)
                except tk.TclError: pass
            self.drag_indicator_id = None
            return

        target_idx_motion = self._get_index_from_canvas_coords(
            canvas_motion, event.x, event.y, self.drag_item_type
        )

        if self.drag_indicator_id:
            try: target_canvas_for_indicator.delete(self.drag_indicator_id)
            except tk.TclError: pass
            self.drag_indicator_id = None

        if target_idx_motion >= 0 and canvas_motion == target_canvas_for_indicator:
            padding_ind = 1
            item_w_ind, item_h_ind, items_across_ind, max_items_ind = 0,0,0,0

            if self.drag_item_type == "tile":
                item_w_ind = VIEWER_TILE_SIZE
                item_h_ind = VIEWER_TILE_SIZE
                items_across_ind = NUM_TILES_ACROSS
                max_items_ind = num_tiles_in_set
            elif self.drag_item_type == "supertile":
                item_w_ind = self.supertile_grid_width * TILE_WIDTH
                item_h_ind = self.supertile_grid_height * TILE_HEIGHT

                max_items_ind = num_supertiles
                
                target_layout_w_ind = 256
                actual_canvas_w_ind = target_canvas_for_indicator.winfo_width()
                effective_layout_w_ind = min(target_layout_w_ind, actual_canvas_w_ind)
                current_items_across_ind = 0
                for p_o_2_val_ind in [32, 16, 8, 4, 2, 1]:
                    if p_o_2_val_ind == 0: continue
                    req_w_ind = (p_o_2_val_ind * item_w_ind) + ((p_o_2_val_ind + 1) * padding_ind)
                    if req_w_ind <= effective_layout_w_ind:
                        current_items_across_ind = p_o_2_val_ind
                        break
                if current_items_across_ind == 0:
                    if item_w_ind + 2 * padding_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    elif item_w_ind <= effective_layout_w_ind: current_items_across_ind = 1
                    else: current_items_across_ind = 1
                items_across_ind = max(1, current_items_across_ind)

            if item_w_ind > 0 and item_h_ind > 0 and items_across_ind > 0:
                indicator_pos_idx = min(target_idx_motion, max_items_ind) 
                
                row_ind, col_ind = divmod(indicator_pos_idx, items_across_ind)
                
                line_x_pos = (col_ind * (item_w_ind + padding_ind)) + (padding_ind / 2) 
                line_y1_pos = (row_ind * (item_h_ind + padding_ind)) + (padding_ind / 2)
                line_y2_pos = line_y1_pos + item_h_ind 

                self.drag_indicator_id = target_canvas_for_indicator.create_line(
                    line_x_pos, line_y1_pos, line_x_pos, line_y2_pos,
                    fill="yellow", width=3, tags="drop_indicator"
                )
        try:
            if canvas_motion.winfo_exists() and canvas_motion.cget("cursor") != "hand2":
                 canvas_motion.config(cursor="hand2")
        except tk.TclError: pass

    def handle_viewer_drag_release(self, event):
        """Handles mouse button release over viewer/selector canvases.
        Completes either a click selection or a drag-and-drop repositioning.
        """
        global current_tile_index, selected_tile_for_supertile  # Selections
        global current_supertile_index, selected_supertile_for_map  # Selections

        canvas = event.widget  # Canvas where release occurred
        was_dragging = self.drag_active  # Check drag state BEFORE resetting

        # --- Always clean up visual drag indicators first ---
        if self.drag_indicator_id:
            # Try deleting from original drag canvas first, then current canvas
            try:
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    self.drag_canvas.delete(self.drag_indicator_id)
                elif canvas.winfo_exists():  # Fallback to current canvas
                    canvas.delete(self.drag_indicator_id)
            except tk.TclError:
                pass  # Ignore if already gone
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists():
                canvas.config(cursor="")  # Reset cursor on the current canvas
        except tk.TclError:
            pass

        # --- Determine Item Type and Max Items based on Canvas ---
        # This is needed for both click and drag-release scenarios
        item_type = None
        max_items = 0
        source_canvas_type = None  # Track where drag started for potential validation

        if canvas == self.tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "tile_editor_main"
        elif canvas == self.st_tileset_canvas:
            item_type = "tile"
            max_items = num_tiles_in_set
            source_canvas_type = "supertile_editor_tile"
        elif canvas == self.supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "supertile_editor_main"
        elif canvas == self.map_supertile_selector_canvas:
            item_type = "supertile"
            max_items = num_supertiles
            source_canvas_type = "map_editor_palette"
        else:
            # Should not happen if bindings are correct
            print(f"Warning: Drag release on unknown canvas: {canvas}")
            # Reset drag state fully and exit
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            return

        # --- Get Index Under Cursor ---
        index_at_release = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, item_type
        )

        # --- Handle Release ---
        if not was_dragging:
            # --- Scenario 1: It was just a CLICK (no drag initiated or minimal movement) ---
            if 0 <= index_at_release < max_items:  # Ensure click was on a valid item
                # Perform the original selection logic based on the canvas type
                if item_type == "tile":
                    if (
                        source_canvas_type == "tile_editor_main"
                    ):  # Main tile editor viewer
                        if current_tile_index != index_at_release:
                            current_tile_index = index_at_release
                            self.update_all_displays(
                                changed_level="tile"
                            )  # Redraw editor, viewers
                            self.scroll_viewers_to_tile(
                                current_tile_index
                            )  # Scroll to selection
                    elif (
                        source_canvas_type == "supertile_editor_tile"
                    ):  # Supertile's tile selector
                        if selected_tile_for_supertile != index_at_release:
                            selected_tile_for_supertile = index_at_release
                            # Only redraw this specific viewer and label
                            self.draw_tileset_viewer(
                                self.st_tileset_canvas, selected_tile_for_supertile
                            )
                            self.update_supertile_info_labels()
                            self.scroll_viewers_to_tile(
                                selected_tile_for_supertile
                            )  # Scroll this viewer
                elif item_type == "supertile":
                    if (
                        source_canvas_type == "supertile_editor_main"
                    ):  # Main supertile selector
                        if current_supertile_index != index_at_release:
                            current_supertile_index = index_at_release
                            self.update_all_displays(changed_level="supertile")
                            self.scroll_selectors_to_supertile(
                                current_supertile_index
                            )  # Scroll
                    elif (
                        source_canvas_type == "map_editor_palette"
                    ):  # Map's supertile selector
                        if selected_supertile_for_map != index_at_release:
                            selected_supertile_for_map = index_at_release
                            # Only redraw this specific selector and label
                            self.draw_supertile_selector(
                                self.map_supertile_selector_canvas,
                                selected_supertile_for_map,
                            )
                            self.update_map_info_labels()
                            self.scroll_selectors_to_supertile(
                                selected_supertile_for_map
                            )  # Scroll

        else:
            # --- Scenario 2: It was a DRAG RELEASE ---
            source_index = self.drag_start_index
            dragged_item_type = self.drag_item_type  # Get type from drag state

            # Basic validation: Drag type must match release canvas type
            if dragged_item_type != item_type:
                print(
                    f"Warning: Drag type mismatch. Started '{dragged_item_type}', dropped on '{item_type}'. Cancelling."
                )
                # Redraw the source canvas to remove drag highlight
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if dragged_item_type == "tile":
                        self.draw_tileset_viewer(
                            self.drag_canvas, -1
                        )  # Use dummy highlight index
                    elif dragged_item_type == "supertile":
                        self.draw_supertile_selector(self.drag_canvas, -1)
                # Reset state fully handled below
            else:
                # Determine the final target index for the repositioning logic
                # index_at_release == max_items means drop at the end
                # index_at_release == -2 means dropped outside valid grid area
                # index_at_release == -1 means error in calculation
                valid_drop_target = False
                final_target_index = -1

                if index_at_release == max_items:  # Drop at the very end
                    final_target_index = max_items  # Pass count to reposition logic
                    valid_drop_target = True
                elif 0 <= index_at_release < max_items:  # Drop onto a specific index
                    final_target_index = index_at_release
                    valid_drop_target = True

                if valid_drop_target and final_target_index != source_index:
                    # Proceed with repositioning
                    success = False
                    print(
                        f"Completing Drag: Moving {item_type} from {source_index} to target {final_target_index}"
                    )
                    if item_type == "tile":
                        success = self._reposition_tile(
                            source_index, final_target_index
                        )
                    elif item_type == "supertile":
                        success = self._reposition_supertile(
                            source_index, final_target_index
                        )

                    if success:
                        # Repositioning handles index updates and marking modified
                        # Need full redraw and cache clear due to potential cascading reference changes
                        self.clear_all_caches()
                        self.invalidate_minimap_background_cache()
                        self.update_all_displays(changed_level="all")
                        # Scroll viewers/selectors to the *new* location of the primary selection index
                        if item_type == "tile":
                            self.scroll_viewers_to_tile(current_tile_index)
                        elif item_type == "supertile":
                            self.scroll_selectors_to_supertile(current_supertile_index)
                    else:
                        # Repositioning failed (e.g., internal error, should be rare)
                        messagebox.showerror(
                            "Reposition Error",
                            f"Failed to move {item_type} from {source_index} to {final_target_index}.",
                        )
                        # Attempt redraw even on failure to show current state
                        self.update_all_displays(changed_level="all")

                else:
                    # Dropped outside (-2), on itself, or calculation error (-1)
                    # Just redraw the relevant displays to remove drag highlight
                    print(
                        f"Drag cancelled or no move needed (target_index: {index_at_release}, source: {source_index})."
                    )
                    if item_type == "tile":
                        self.update_all_displays(changed_level="tile")
                    elif item_type == "supertile":
                        self.update_all_displays(changed_level="supertile")

        # --- Final Reset of Drag State (regardless of click or drag) ---
        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_canvas = None
        # Indicator ID and cursor should already be cleaned up above


    def _set_pencil_cursor(self, event):
        """Sets the cursor to 'pencil' for the widget that received the event."""
        try:
            # Check if widget still exists before configuring
            if event.widget.winfo_exists():
                event.widget.config(cursor="pencil")
        except tk.TclError:
            pass  # Ignore if widget is destroyed during event handling

    def _reset_cursor(self, event):
        """Resets the cursor to default for the widget that received the event."""
        try:
            if event.widget.winfo_exists():
                # Don't reset map canvas blindly, let its own logic handle it on leave
                if event.widget != self.map_canvas:
                    event.widget.config(cursor="")
                # If it *is* the map canvas, its existing <Leave> handler will take care of it
        except tk.TclError:
            pass  # Ignore if widget is destroyed

    # --- New Handlers and Helpers for Map Selection ---

    def handle_shift_press(self, event):
        """Handles Shift key press."""
        if "Shift" in event.keysym:
            if not self.is_shift_pressed:
                self.is_shift_pressed = True
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_shift_release(self, event):
        """Handles Shift key release."""
        if "Shift" in event.keysym:
            if self.is_shift_pressed:
                self.is_shift_pressed = False
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def _get_supertile_coords_from_canvas(self, canvas_x_coord, canvas_y_coord): # Renamed params
        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims()

        if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0:
            return None # Cannot calculate if dimensions are invalid

        st_col_calc = int(canvas_x_coord // zoomed_st_pixel_w)
        st_row_calc = int(canvas_y_coord // zoomed_st_pixel_h)

        if 0 <= st_row_calc < map_height and 0 <= st_col_calc < map_width:
            return (st_col_calc, st_row_calc)
        else:
            return None

    def _get_normalized_selection_st(self):
        """Returns normalized selection bounds (min_c, min_r, max_c, max_r) or None."""
        if self.map_selection_start_st is None or self.map_selection_end_st is None:
            return None

        start_c, start_r = self.map_selection_start_st
        end_c, end_r = self.map_selection_end_st

        min_c = min(start_c, end_c)
        min_r = min(start_r, end_r)
        max_c = max(start_c, end_c)
        max_r = max(start_r, end_r)

        return (min_c, min_r, max_c, max_r)

    def _draw_selection_rectangle(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        if self.map_selection_rect_id:
            try:
                canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass # Item might already be gone
            self.map_selection_rect_id = None

        norm_coords_sel = self._get_normalized_selection_st()
        if norm_coords_sel is None:
            return

        min_c_sel, min_r_sel, max_c_sel, max_r_sel = norm_coords_sel

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_sel, zoomed_st_pixel_h_sel = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_sel <= 0 or zoomed_st_pixel_h_sel <= 0:
            return

        px1_sel = min_c_sel * zoomed_st_pixel_w_sel
        py1_sel = min_r_sel * zoomed_st_pixel_h_sel
        px2_sel = (max_c_sel + 1) * zoomed_st_pixel_w_sel # +1 because coords are inclusive
        py2_sel = (max_r_sel + 1) * zoomed_st_pixel_h_sel

        try:
            self.map_selection_rect_id = canvas.create_rectangle(
                px1_sel, py1_sel, px2_sel, py2_sel,
                outline="yellow",
                dash=(4, 4),
                width=2,
                tags=("selection_rect",)
            )
            # Ensure it's drawn below other interactive elements
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_selection_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                canvas.tag_lower(self.map_selection_rect_id, "supertile_grid")
        except tk.TclError:
            self.map_selection_rect_id = None # Failed to create

    def _clear_map_selection(self):
        """Clears ONLY the map selection visual and related state variables."""
        canvas = self.map_canvas
        # Clear the visual rectangle
        if self.map_selection_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass
            self.map_selection_rect_id = None

        # Check if state needs updating before resetting (for menu update trigger)
        needs_menu_update = self.map_selection_start_st is not None

        # Reset selection state variables
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_selection_active = False # Ensure selection drag state is reset

        # Update menu if selection was active
        if needs_menu_update:
            self._update_edit_menu_state()
        # Do not redraw map here, let the caller handle redraw if needed
        # Do not clear paste preview or clipboard here

    def handle_map_selection_start(self, event):
        """Handles Shift + Button-1 press to start map selection."""
        if self.is_ctrl_pressed or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        self._clear_map_selection()

        start_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if start_coords:
            self.map_selection_start_st = start_coords
            self.map_selection_end_st = start_coords
            self.map_selection_active = True
            self._draw_selection_rectangle()
            self._update_map_cursor()
        else:
            self.map_selection_start_st = None
            self.map_selection_end_st = None
            self.map_selection_active = False

        return "break"

    def handle_map_selection_motion(self, event):
        """Handles Shift + B1 motion to update selection rectangle."""
        if not self.map_selection_active:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        current_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if current_coords:
            if self.map_selection_end_st != current_coords:
                self.map_selection_end_st = current_coords
                self._draw_selection_rectangle()
        # else: # Keep last valid end_st when mouse is outside

        return "break"

    def handle_map_selection_release(self, event):
        """Handles Shift + Button-1 release to finalize map selection."""
        if not self.map_selection_active:
            self._clear_map_selection()
            return

        self.map_selection_active = False

        if (
            self.map_selection_start_st is not None
            and self.map_selection_end_st is not None
        ):
            self.debug(f"[DEBUG]Selection finalized: {self.map_selection_start_st} to {self.map_selection_end_st}")
            # Final rectangle drawn by motion handler, redraw map to make it persistent
            self.draw_map_canvas()
            self._update_edit_menu_state()
        else:
            self._clear_map_selection()

        self._update_map_cursor()

        return "break"

    def handle_map_escape(self, event):
        """Handles Escape key press on map canvas to clear clipboard, paste preview, and selection."""
        self.debug("[DEBUG]Escape pressed, clearing clipboard, paste preview, and selection.")

        # Check what was active before clearing
        cleared_clipboard = self.map_clipboard_data is not None
        cleared_preview = self.map_paste_preview_rect_id is not None
        cleared_selection = self.map_selection_start_st is not None

        # Always attempt to clear clipboard, preview, and selection state
        self.map_clipboard_data = None
        self._clear_paste_preview_rect()
        self._clear_map_selection() # This now only clears selection visuals/state

        # Update menu state if the clipboard was cleared
        if cleared_clipboard:
            self._update_edit_menu_state()

        # Redraw map if the selection rectangle was visible to ensure it's removed
        # Clearing the paste preview doesn't require a full map redraw
        if cleared_selection and self.map_canvas.winfo_exists():
             self.draw_map_canvas()

        return "break" # Prevent other Escape bindings

    def _update_map_cursor_and_coords(self, event):
        """Combined handler for Motion to update both cursor and coords, and manage paste preview."""
        # Update coordinate display first
        self._update_map_coords_display(event)

        # Update cursor based on current state (e.g., pan, select, paint)
        self._update_map_cursor()

        # --- Paste Preview Logic ---
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                 selected_tab_index = self.notebook.index(self.notebook.select())
                 if selected_tab_index == 3: # Map Editor tab index
                     is_map_tab_active = True
            except tk.TclError:
                pass # Ignore if notebook not ready

        # Conditions to show paste preview: Map tab active AND map clipboard has data
        if is_map_tab_active and self.map_clipboard_data:
            self._draw_paste_preview_rect(event=event)
        else:
            # Clear preview if conditions are not met (e.g., wrong tab, no clipboard data)
            # This handles cases where clipboard is cleared while mouse is over canvas
            self._clear_paste_preview_rect()

    # --- New Paste Preview Methods ---
    def _draw_paste_preview_rect(self, event=None, canvas_coords=None):
        canvas = self.map_canvas
        if not canvas.winfo_exists() or not self.map_clipboard_data or not self.notebook:
            self._clear_paste_preview_rect()
            return
        try:
            if self.notebook.index(self.notebook.select()) != 3: # Map Editor tab index
                 self._clear_paste_preview_rect()
                 return
        except tk.TclError:
            self._clear_paste_preview_rect()
            return

        current_canvas_x_paste, current_canvas_y_paste = -1, -1
        if canvas_coords:
            current_canvas_x_paste, current_canvas_y_paste = canvas_coords
        elif event:
            try:
                current_canvas_x_paste = canvas.canvasx(event.x)
                current_canvas_y_paste = canvas.canvasy(event.y)
            except tk.TclError:
                self._clear_paste_preview_rect()
                return
        else:
             self._clear_paste_preview_rect()
             return

        paste_st_coords_preview = self._get_supertile_coords_from_canvas(current_canvas_x_paste, current_canvas_y_paste)

        if paste_st_coords_preview is None:
            self._clear_paste_preview_rect()
            return

        paste_st_col_preview, paste_st_row_preview = paste_st_coords_preview
        clip_w_preview = self.map_clipboard_data.get('width', 0)
        clip_h_preview = self.map_clipboard_data.get('height', 0)

        if clip_w_preview <= 0 or clip_h_preview <= 0:
            self._clear_paste_preview_rect()
            return

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_preview, zoomed_st_pixel_h_preview = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_preview <= 0 or zoomed_st_pixel_h_preview <= 0:
             self._clear_paste_preview_rect()
             return

        px1_preview = paste_st_col_preview * zoomed_st_pixel_w_preview
        py1_preview = paste_st_row_preview * zoomed_st_pixel_h_preview
        px2_preview = px1_preview + (clip_w_preview * zoomed_st_pixel_w_preview)
        py2_preview = py1_preview + (clip_h_preview * zoomed_st_pixel_h_preview)

        fill_color_preview = "#0000FF"
        stipple_pattern_preview = "gray50"

        if self.map_paste_preview_rect_id:
            try:
                canvas.coords(self.map_paste_preview_rect_id, px1_preview, py1_preview, px2_preview, py2_preview)
                canvas.itemconfig(self.map_paste_preview_rect_id, state=tk.NORMAL, fill=fill_color_preview, stipple=stipple_pattern_preview)
            except tk.TclError:
                self.map_paste_preview_rect_id = None
        
        if not self.map_paste_preview_rect_id:
            try:
                self.map_paste_preview_rect_id = canvas.create_rectangle(
                    px1_preview, py1_preview, px2_preview, py2_preview,
                    fill=fill_color_preview,
                    stipple=stipple_pattern_preview,
                    outline="", 
                    width=0,
                    tags=("paste_preview_rect",)
                )
            except tk.TclError:
                 self.map_paste_preview_rect_id = None
                 return

        try:
            if self.map_selection_rect_id:
                 canvas.tag_lower(self.map_paste_preview_rect_id, self.map_selection_rect_id)
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_paste_preview_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                 canvas.tag_lower(self.map_paste_preview_rect_id, "supertile_grid")
        except tk.TclError:
            pass


    def _clear_paste_preview_rect(self):
        """Safely deletes the paste preview rectangle from the canvas."""
        canvas = self.map_canvas
        if self.map_paste_preview_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_paste_preview_rect_id)
            except tk.TclError:
                pass # Ignore error if item already deleted or canvas gone
            finally:
                 # Ensure ID is cleared even if deletion fails
                 self.map_paste_preview_rect_id = None

    def show_about_box(self):
        """Displays the About information box with the application icon."""
        # Create a Toplevel window
        about_win = tk.Toplevel(self.root)
        about_win.title("About MSX Tile Forge")
        about_win.resizable(False, False) 
        about_win.transient(self.root) 
        about_win.grab_set() 

        # Main frame for content
        main_frame = ttk.Frame(about_win, padding="15")
        main_frame.pack(expand=True, fill="both")

        icon_label = None
        # Try to get the icon reference stored during startup on the root window
        app_icon_photo = getattr(self.root, 'app_icon_ref', None) # This should now find it

        if app_icon_photo:
            icon_label = ttk.Label(main_frame, image=app_icon_photo)
            # Keep reference for the label within this Toplevel
            icon_label.image = app_icon_photo 
            icon_label.grid(row=0, column=0, padx=(0, 15), pady=(0, 10), sticky="nw")

        # Text information frame
        text_frame = ttk.Frame(main_frame)
        text_frame.grid(row=0, column=1, sticky="nsew")

        # Program Name (Bold)
        style = ttk.Style()
        style.configure("About.TLabel", font=("-size", 10, "bold")) # Adjusted font size slightly
        name_label = ttk.Label(text_frame, text="MSX Tile Forge", style="About.TLabel")
        name_label.pack(anchor="w", pady=(0, 5))

        # Version and Author
        info_text = f"Version: {APP_VERSION}\nAuthor: Damned Angel + Gemini AI"
        info_label = ttk.Label(text_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(anchor="w")

        # OK Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2 if icon_label else 1, pady=(15, 0))

        ok_button = ttk.Button(button_frame, text="OK", command=about_win.destroy, width=10)
        ok_button.pack()

        about_win.update_idletasks() 
        main_width = self.root.winfo_width()
        main_height = self.root.winfo_height()
        main_x = self.root.winfo_x()
        main_y = self.root.winfo_y()

        pop_width = about_win.winfo_width()
        pop_height = about_win.winfo_height()

        pop_x = main_x + (main_width // 2) - (pop_width // 2)
        pop_y = main_y + (main_height // 2) - (pop_height // 2)

        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        pop_x = max(0, min(pop_x, screen_width - pop_width))
        pop_y = max(0, min(pop_y, screen_height - pop_height))

        about_win.geometry(f"+{pop_x}+{pop_y}")
        ok_button.focus_set()
        about_win.wait_window()

    def _find_unused_tiles(self):
        """Identifies tiles not used in any supertile definition."""
        global tileset_patterns, supertiles_data, num_tiles_in_set, num_supertiles
        used_tile_indices = set()
        # Tile 0 is implicitly used/reserved, don't mark it as unused
        for st_idx in range(num_supertiles):
            for r in range(SUPERTILE_GRID_DIM):
                for c in range(SUPERTILE_GRID_DIM):
                    used_tile_indices.add(supertiles_data[st_idx][r][c])
        
        unused_tiles = set()
        for i in range(1, num_tiles_in_set): # Start from 1, tile 0 is never "unused"
            if i not in used_tile_indices:
                unused_tiles.add(i)
        return unused_tiles

    def _find_unused_supertiles(self):
        """Identifies supertiles not used in the map_data."""
        global map_data, map_width, map_height, num_supertiles
        used_st_indices = set()
        # Supertile 0 is implicitly used/reserved
        for r_idx in range(map_height): # Renamed r
            for c_idx in range(map_width): # Renamed c
                used_st_indices.add(map_data[r_idx][c_idx])
        # self.debug(f"[DEBUG]DEBUG: Used Supertile Indices from map_data: {used_st_indices}") # DEBUG

        unused_supertiles = set()
        for i in range(1, num_supertiles): # Start from 1
            if i not in used_st_indices:
                unused_supertiles.add(i)
        self.debug(f"[DEBUG]DEBUG: Found Unused Supertiles (indices): {unused_supertiles}") # DEBUG
        return unused_supertiles

    def _clear_marked_unused(self, trigger_redraw=True):
        """Clears all 'marked unused' states and optionally redraws relevant viewers."""
        tile_marks_cleared = bool(self.marked_unused_tiles)
        st_marks_cleared = bool(self.marked_unused_supertiles)

        self.marked_unused_tiles.clear()
        self.marked_unused_supertiles.clear()

        if trigger_redraw and (tile_marks_cleared or st_marks_cleared):
            # Redraw only if marks were actually cleared to avoid unnecessary redraws
            # Determine active tab to redraw correctly
            current_tab_index = -1
            try:
                if self.notebook and self.notebook.winfo_exists():
                    selected_tab_name = self.notebook.select()
                    if selected_tab_name:
                        current_tab_index = self.notebook.index(selected_tab_name)
            except tk.TclError:
                pass

            if current_tab_index == 1: # Tile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
            elif current_tab_index == 2: # Supertile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                if st_marks_cleared:
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
            elif current_tab_index == 3: # Map Editor
                if st_marks_cleared: # Map editor only shows supertiles
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        return tile_marks_cleared or st_marks_cleared


    def _adjust_marked_indices_after_delete(self, marked_set, deleted_index):
        """Adjusts indices in a 'marked_set' after an item at 'deleted_index' is removed."""
        if deleted_index in marked_set:
            marked_set.remove(deleted_index)
        
        new_marked_set = set()
        for idx in marked_set:
            if idx > deleted_index:
                new_marked_set.add(idx - 1)
            else:
                new_marked_set.add(idx)
        marked_set.clear()
        marked_set.update(new_marked_set)


    def handle_mark_unused_tiles(self):
        """Handles the 'Mark Unused' button click in the Tile Editor tab."""
        if self.marked_unused_tiles: # If already marked, clear them
            self._clear_marked_unused(trigger_redraw=False) 
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index) 
        else:
            # Clear any supertile marks from other tab before marking tiles
            # This ensures only tile marks are active if this button is pressed
            if self.marked_unused_supertiles:
                self.marked_unused_supertiles.clear()
                 # Redraw ST selectors if they were marked to remove blue borders
                if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

            self.marked_unused_tiles = self._find_unused_tiles()
            if not self.marked_unused_tiles:
                messagebox.showinfo("Mark Unused Tiles", "No unused tiles found.")
            else:
                print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)

    def handle_mark_unused_supertiles_and_tiles(self):
        """Handles the 'Mark Unused' button in the Supertile Editor tab."""
        # If either set has marks, clear both
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self._clear_marked_unused(trigger_redraw=False) 
            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        else: # Neither set has marks, so we are in "mark" mode
            self.marked_unused_tiles = self._find_unused_tiles()
            self.marked_unused_supertiles = self._find_unused_supertiles() 
            
            if not self.marked_unused_tiles and not self.marked_unused_supertiles:
                messagebox.showinfo("Mark Unused", "No unused tiles or supertiles found.")
            else:
                # Only print the sets if they contain items
                if self.marked_unused_tiles: 
                    print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list for consistency
                if self.marked_unused_supertiles: 
                    print(f"Marked unused supertiles: {sorted(list(self.marked_unused_supertiles))}") # Print sorted list

            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)

    # --- ROM Importer Methods (NEW SECTION) ---

    def open_rom_importer(self):
        """Handles the 'Import Tiles from ROM...' menu command."""
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        rom_filepath = filedialog.askopenfilename(
            title="Select ROM File",
            filetypes=[("All files", "*.*"), ("Binary files", "*.bin"), ("ROM files", "*.rom")]
        )
        if not rom_filepath:
            return # User cancelled

        try:
            with open(rom_filepath, "rb") as f:
                rom_data = f.read()
            if not rom_data:
                messagebox.showerror("ROM Import Error", "Selected file is empty.")
                return
        except Exception as e:
            messagebox.showerror("ROM Import Error", f"Could not read ROM file:\n{e}")
            return

        # If successful, create and show the dialog
        self._create_rom_importer_dialog(rom_filepath, rom_data)

    def _create_rom_importer_dialog(self, rom_filepath, rom_data):
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        self.rom_import_dialog = tk.Toplevel(self.root)
        dialog = self.rom_import_dialog
        dialog.title(f"ROM Tile Importer - {os.path.basename(rom_filepath)}")
        dialog.transient(self.root)
        dialog.grab_set()

        dialog.rom_data = rom_data
        dialog.rom_filepath = rom_filepath
        dialog.fine_offset_var = tk.IntVar(value=0)
        dialog.rom_importer_selection = {}
        dialog.rom_importer_anchor_idx = -1
        dialog.current_importer_fg_idx = WHITE_IDX
        dialog.current_importer_bg_idx = BLACK_IDX
        dialog.hover_info_text_var = tk.StringVar(value="Offset: N/A | Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")
        dialog.top_left_grid_byte_offset_text_var = tk.StringVar(value="Grid Top-Left Byte: N/A")
        dialog.redraw_timer_id = None
        dialog.slider_redraw_timer_id = None
        dialog.rom_importer_grid_cols = 1

        dialog.pil_rom_viewport_image = None 
        dialog.tk_rom_photoimage = None      

        try:
            safe_tile_w = max(1, TILE_WIDTH)
            safe_tile_h = max(1, TILE_HEIGHT)
            dialog.temp_tile_image_unscaled_ref = tk.PhotoImage(width=safe_tile_w, height=safe_tile_h)
        except tk.TclError as e_photo:
            self.debug(f"[DEBUG] CRITICAL: Failed to create temp_tile_image_unscaled_ref: {e_photo}")
            messagebox.showerror("Importer Init Error", "Failed to initialize image resources for importer.", parent=dialog)
            if tk.Toplevel.winfo_exists(dialog):
                dialog.destroy()
            return

        main_dialog_frame = ttk.Frame(dialog, padding=5)
        main_dialog_frame.pack(expand=True, fill="both")
        main_dialog_frame.grid_columnconfigure(0, weight=0)
        main_dialog_frame.grid_columnconfigure(1, weight=1)
        main_dialog_frame.grid_rowconfigure(0, weight=1)
        main_dialog_frame.grid_rowconfigure(1, weight=0)

        left_column_frame = ttk.Frame(main_dialog_frame)
        left_column_frame.grid(row=0, column=0, sticky="nswe", padx=(0, 10))

        preview_label_frame = ttk.LabelFrame(left_column_frame, text="Live Preview")
        preview_label_frame.pack(side=tk.TOP, pady=(0, 10), anchor="n", fill=tk.X)
        preview_canvas_size = TILE_WIDTH * EDITOR_PIXEL_SIZE
        dialog.preview_canvas = tk.Canvas(
            preview_label_frame,
            width=max(1, preview_canvas_size),
            height=max(1, preview_canvas_size),
            bg="grey",
            highlightthickness=0
        )
        dialog.preview_canvas.pack(padx=5, pady=5, anchor="center")

        offset_control_frame = ttk.Frame(left_column_frame)
        offset_control_frame.pack(side=tk.TOP, pady=(0,10), fill=tk.X)
        ttk.Label(offset_control_frame, text="Fine Offset (0-7 bytes):").pack(side=tk.TOP, anchor="w")
        offset_slide_frame = ttk.Frame(offset_control_frame)
        offset_slide_frame.pack(side=tk.TOP, fill=tk.X, expand=True, padx=9)
        offset_slider = ttk.Scale(
            offset_slide_frame, from_=0, to=7, orient=tk.HORIZONTAL,
            variable=dialog.fine_offset_var, command=self._on_fine_offset_slider_change
        )
        offset_slider.pack(side=tk.TOP, fill=tk.X, expand=True)
        offset_tick_frame = ttk.Frame(offset_control_frame)
        offset_tick_frame.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(2,0))
        for i in range(8):
            offset_tick_frame.grid_columnconfigure(i, weight=1)
            lbl = ttk.Label(offset_tick_frame, text=str(i), font=("TkSmallCaptionFont", 7))
            lbl.grid(row=0, column=i)

        importer_color_frame = ttk.LabelFrame(left_column_frame, text="Preview/Import Colors")
        importer_color_frame.pack(side=tk.TOP, pady=(10,5), fill=tk.X)

        fg_color_subframe = ttk.Frame(importer_color_frame)
        fg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(fg_color_subframe, text="FG (1-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_fg_swatch = tk.Label(fg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_fg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_fg_swatch.bind("<Button-1>",
            lambda e, swatch_type='fg': self._pick_importer_color(swatch_type))

        bg_color_subframe = ttk.Frame(importer_color_frame)
        bg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(bg_color_subframe, text="BG (0-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_bg_swatch = tk.Label(bg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_bg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_bg_swatch.bind("<Button-1>",
            lambda e, swatch_type='bg': self._pick_importer_color(swatch_type))

        info_bar_frame = ttk.Frame(left_column_frame, padding=3)
        info_bar_frame.pack(side=tk.TOP, fill=tk.X, expand=False, pady=(5,5))
        dialog.status_bar_top_left_label = ttk.Label(info_bar_frame, textvariable=dialog.top_left_grid_byte_offset_text_var, anchor="w", justify=tk.LEFT)
        dialog.status_bar_top_left_label.pack(side=tk.TOP, fill=tk.X)
        hover_label = ttk.Label(info_bar_frame, textvariable=dialog.hover_info_text_var, anchor="w", justify=tk.LEFT)
        hover_label.pack(side=tk.TOP, fill=tk.X)
        selection_label = ttk.Label(info_bar_frame, textvariable=dialog.selection_info_text_var, anchor="w", justify=tk.LEFT)
        selection_label.pack(side=tk.TOP, fill=tk.X)

        canvas_frame = ttk.Frame(main_dialog_frame)
        canvas_frame.grid(row=0, column=1, sticky="nswe")
        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)

        rom_v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        rom_h_scroll = ttk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL)

        dialog.canvas = tk.Canvas(
            canvas_frame,
            bg="darkgrey",
            yscrollcommand=rom_v_scroll.set,
            xscrollcommand=rom_h_scroll.set,
            highlightthickness=0
        )

        def _schedule_debounced_draw_from_scroll_rom():
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

            if current_dialog.redraw_timer_id is not None:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

        def yview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.yview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        def xview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.xview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        rom_v_scroll.config(command=yview_wrapper_debounced_rom)
        rom_h_scroll.config(command=xview_wrapper_debounced_rom)

        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        rom_v_scroll.grid(row=0, column=1, sticky="ns")
        rom_h_scroll.grid(row=1, column=0, sticky="ew")

        buttons_frame = ttk.Frame(main_dialog_frame)
        buttons_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10,0))
        buttons_frame.grid_columnconfigure(0, weight=1)
        buttons_frame.grid_columnconfigure(1, weight=0)
        buttons_frame.grid_columnconfigure(2, weight=0)
        buttons_frame.grid_columnconfigure(3, weight=1)

        dialog.import_button = ttk.Button(
            buttons_frame, text="Import", command=self._execute_rom_tile_import, state=tk.DISABLED
        )
        cancel_button = ttk.Button(
            buttons_frame, text="Cancel", command=self._close_rom_importer_dialog
        )
        dialog.import_button.grid(row=0, column=1, padx=(0,5))
        cancel_button.grid(row=0, column=2, padx=(5,0))

        dialog.canvas.bind("<Configure>", lambda e: self._on_rom_importer_setting_change(configure_event=True))
        dialog.canvas.bind("<Motion>", self._on_rom_canvas_motion)
        dialog.canvas.bind("<Leave>", self._on_rom_canvas_leave)
        dialog.canvas.bind("<Button-1>", self._on_rom_canvas_left_click)
        dialog.canvas.bind("<Button-3>", self._on_rom_canvas_right_click)
        dialog.bind("<Escape>", lambda e: self._clear_rom_import_selection()) 
        dialog.canvas.bind("<FocusIn>", lambda e: None) 
        dialog.canvas.bind("<Key>", self._on_rom_canvas_keypress)
        dialog.canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-4>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-5>", self._on_mousewheel_scroll)
        dialog.canvas.focus_set()
        dialog.protocol("WM_DELETE_WINDOW", self._close_rom_importer_dialog)

        self._update_importer_color_swatches()
        dialog.after(50, lambda: self._on_rom_importer_setting_change(configure_event=True))

        dialog.update_idletasks()
        root_w = self.root.winfo_width()
        root_h = self.root.winfo_height()
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        dialog.update_idletasks() 
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = root_x + (root_w // 2) - (dialog_w // 2)
        y_pos = root_y + (root_h // 2) - (dialog_h // 2)
        
        screen_width_dialog = dialog.winfo_screenwidth()
        screen_height_dialog = dialog.winfo_screenheight()
        x_pos = max(0, min(x_pos, screen_width_dialog - dialog_w))
        y_pos = max(0, min(y_pos, screen_height_dialog - dialog_h))

        dialog.geometry(f"{dialog_w}x{dialog_h}+{x_pos}+{y_pos}")
        dialog.lift()

    def _close_rom_importer_dialog(self):
        """Closes and cleans up the ROM importer dialog."""
        if self.rom_import_dialog:
            self.rom_import_dialog.grab_release() # Release grab before destroying
            self.rom_import_dialog.destroy()
            self.rom_import_dialog = None # Clear reference

    def _on_rom_importer_setting_change(self, event=None, configure_event=False):
        # Called when fine_offset slider changes or canvas is configured/resized.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        if configure_event:
            self.debug("[DEBUG] _on_rom_importer_setting_change: Configure event triggered.")
            
            if not hasattr(dialog, 'redraw_timer_id'): # Ensure attribute exists
                dialog.redraw_timer_id = None

            if dialog.redraw_timer_id is not None:
                dialog.after_cancel(dialog.redraw_timer_id)
            # _perform_debounced_rom_canvas_draw handles clearing its own timer ID
            dialog.redraw_timer_id = dialog.after(150, self._perform_debounced_rom_canvas_draw) # Standard debounce for configure
            return 
        # else:
            # Non-configure events (e.g., direct calls if any, or slider)
            # Slider changes are handled by _on_fine_offset_slider_change which has its own debounce.
            # If this function were to be called directly for an immediate update by something else,
            # then that calling code would be responsible for the context.
            self.debug("[DEBUG] _on_rom_importer_setting_change: Non-configure event. No action taken here directly.")
            pass

    def _draw_rom_importer_canvas(self):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        self.debug(f"\n[DEBUG] ### _draw_rom_importer_canvas ### Pillow Viewport Strategy")

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[D] Canvas gone.")
            return

        rom_data = dialog.rom_data
        global_fine_offset_for_grid = dialog.fine_offset_var.get()
        current_fg_render_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        current_bg_render_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        selection_dict = getattr(dialog, 'rom_importer_selection', {})

        # Canvas viewport dimensions
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 1 or canvas_viewport_height <= 1:
            self.debug("[D] Canvas too small for Pillow viewport.")
            # Optionally clear canvas or draw a placeholder if needed
            try:
                if canvas.winfo_exists():
                    canvas.delete("all_rom_content")
                    canvas.config(scrollregion=(0,0,1,1))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            return

        # Delete old main image content (if any)
        try:
            if canvas.winfo_exists(): canvas.delete("rom_content_image")
        except tk.TclError: self.debug("[D] TclError deleting old rom_content_image."); # Continue if possible

        # Display parameters for items in the grid
        tile_display_size = VIEWER_TILE_SIZE # How big each 8x8 ROM tile appears on canvas
        padding = 1

        # Determine number of grid columns based on current canvas width
        current_draw_grid_cols = max(1, canvas_viewport_width // (tile_display_size + padding))
        dialog.rom_importer_grid_cols = current_draw_grid_cols # Store for other functions

        # Calculate total potential tiles from ROM data
        total_potential_tiles = 0
        if len(rom_data) > global_fine_offset_for_grid:
            total_potential_tiles = (len(rom_data) - global_fine_offset_for_grid) // TILE_WIDTH

        if total_potential_tiles <= 0:
            # Handle empty ROM data or offset beyond data length
            try:
                if canvas.winfo_exists():
                    canvas.config(scrollregion=(0,0,1,1))
                    # Create/clear the Pillow viewport even if empty
                    if dialog.pil_rom_viewport_image is None or \
                       dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
                       dialog.pil_rom_viewport_image.height != canvas_viewport_height:
                        dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                    else:
                        dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height))
                    
                    dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
                    view_content_x1_empty, view_content_y1_empty = 0,0 
                    try:
                        view_content_x1_empty = canvas.canvasx(0)
                        view_content_y1_empty = canvas.canvasy(0)
                    except tk.TclError: pass
                    canvas.create_image(view_content_x1_empty, view_content_y1_empty, image=dialog.tk_rom_photoimage, anchor=tk.NW, tags=("rom_content_image", "all_rom_content"))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            self.debug("[DEBUG] ### _draw_rom_importer_canvas END (no potential tiles) ###")
            return

        # Calculate scrollregion based on total content
        num_total_content_rows = math.ceil(total_potential_tiles / current_draw_grid_cols) if current_draw_grid_cols > 0 else 0
        scroll_region_width = current_draw_grid_cols * (tile_display_size + padding) + padding
        scroll_region_height = num_total_content_rows * (tile_display_size + padding) + padding
        scroll_region_width = max(1.0, float(scroll_region_width))
        scroll_region_height = max(1.0, float(scroll_region_height))
        
        current_scroll_region_str = ""
        try:
            sr_val = canvas.cget("scrollregion")
            current_scroll_region_str = " ".join(map(str, sr_val)) if isinstance(sr_val, tuple) else str(sr_val)
        except tk.TclError: pass
        new_scroll_region_str = f"0 0 {scroll_region_width} {scroll_region_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                if canvas.winfo_exists(): canvas.config(scrollregion=(0, 0, scroll_region_width, scroll_region_height))
            except tk.TclError: self.debug("[D] TclError setting scrollregion."); return

        # Get current viewport's top-left content coordinates
        view_content_x1 = canvas.canvasx(0)
        view_content_y1 = canvas.canvasy(0)

        # Update top-left grid byte offset label
        # (This logic remains similar, calculating based on visible grid start)
        start_grid_row_idx_for_label = max(0, int(view_content_y1 // (tile_display_size + padding)))
        start_grid_col_idx_for_label = max(0, int(view_content_x1 // (tile_display_size + padding)))
        actual_first_visible_tile_idx_in_data = (start_grid_row_idx_for_label * current_draw_grid_cols) + start_grid_col_idx_for_label
        if not hasattr(dialog, 'top_left_grid_byte_offset'): dialog.top_left_grid_byte_offset = 0
        dialog.top_left_grid_byte_offset = global_fine_offset_for_grid + (actual_first_visible_tile_idx_in_data * TILE_WIDTH)
        if hasattr(dialog, 'top_left_grid_byte_offset_text_var'):
            try:
                dialog.top_left_grid_byte_offset_text_var.set(f"Grid Top-Left Byte: {dialog.top_left_grid_byte_offset} (0x{dialog.top_left_grid_byte_offset:X})")
            except tk.TclError: pass

        # Create/Resize Pillow viewport image buffer
        if dialog.pil_rom_viewport_image is None or \
           dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
           dialog.pil_rom_viewport_image.height != canvas_viewport_height:
            try:
                dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                self.debug(f"[D] Created/Resized dialog.pil_rom_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except (ValueError, tk.TclError) as e_pil_new:
                self.debug(f"[D] Error creating pil_rom_viewport_image: {e_pil_new}"); return
        else:
            # Fill existing image with background color
            try:
                dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill:
                self.debug(f"[D] Error filling pil_rom_viewport_image: {e_fill}. Filling with darkgrey.")
                dialog.pil_rom_viewport_image.paste("darkgrey", (0,0,canvas_viewport_width,canvas_viewport_height) )

        # Determine visible grid range
        start_grid_row_idx = max(0, int(view_content_y1 // (tile_display_size + padding)))
        end_grid_row_idx = min(num_total_content_rows, int(math.ceil((view_content_y1 + canvas_viewport_height) / (tile_display_size + padding))))
        
        start_grid_col_idx = max(0, int(view_content_x1 // (tile_display_size + padding)))
        end_grid_col_idx = min(current_draw_grid_cols, int(math.ceil((view_content_x1 + canvas_viewport_width) / (tile_display_size + padding))))
        
        self.debug(f"[D] Visible Grid - Rows: {start_grid_row_idx}-{end_grid_row_idx-1}, Cols: {start_grid_col_idx}-{end_grid_col_idx-1}")

        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))
        # Scale factor for resizing 8x8 to tile_display_size
        # Pillow's resize requires positive dimensions.
        scaled_tile_w_for_pil = max(1, tile_display_size)
        scaled_tile_h_for_pil = max(1, tile_display_size)

        for r_grid in range(start_grid_row_idx, end_grid_row_idx):
            for c_grid in range(start_grid_col_idx, end_grid_col_idx):
                current_rom_tile_absolute_idx = r_grid * current_draw_grid_cols + c_grid
                if current_rom_tile_absolute_idx >= total_potential_tiles:
                    continue

                # Determine FG/BG colors and fine offset for this specific tile
                tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = -1, -1, -1
                if current_rom_tile_absolute_idx in selection_dict:
                    stored_props = selection_dict[current_rom_tile_absolute_idx]
                    tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = stored_props[0], stored_props[1], stored_props[2]
                else:
                    tile_fg_idx = current_fg_render_idx
                    tile_bg_idx = current_bg_render_idx
                    fine_offset_for_this_tile_render = global_fine_offset_for_grid # Use global if not selected

                safe_tile_fg_idx = tile_fg_idx if 0 <= tile_fg_idx < len(self.active_msx_palette) else WHITE_IDX
                safe_tile_bg_idx = tile_bg_idx if 0 <= tile_bg_idx < len(self.active_msx_palette) else BLACK_IDX
                color_for_fg_pixel = self.active_msx_palette[safe_tile_fg_idx]
                color_for_bg_pixel = self.active_msx_palette[safe_tile_bg_idx]

                # Calculate byte start position using the determined fine offset for this tile
                rom_byte_start_pos = fine_offset_for_this_tile_render + (current_rom_tile_absolute_idx * TILE_WIDTH)

                if not (0 <= rom_byte_start_pos < len(rom_data)):
                    self.debug(f"[D] Tile {current_rom_tile_absolute_idx} calculated offset {rom_byte_start_pos} out of bounds. Skipping.")
                    continue
                
                bytes_to_read = TILE_HEIGHT # Assuming TILE_WIDTH is bytes per tile, TILE_HEIGHT is rows
                if rom_byte_start_pos + bytes_to_read > len(rom_data):
                    num_bytes_avail = len(rom_data) - rom_byte_start_pos
                    tile_bytes_data = rom_data[rom_byte_start_pos:] + bytes(bytes_to_read - num_bytes_avail) # Pad if short
                else:
                    tile_bytes_data = rom_data[rom_byte_start_pos : rom_byte_start_pos + bytes_to_read]

                # Render the 8x8 tile onto pil_temp_base_tile
                pixel_data_for_base_tile = []
                for y_pixel_in_base in range(TILE_HEIGHT):
                    if y_pixel_in_base >= len(tile_bytes_data): break # Should not happen with padding
                    row_byte = tile_bytes_data[y_pixel_in_base]
                    for x_pixel_in_base in range(TILE_WIDTH):
                        pixel_val = (row_byte >> (7 - x_pixel_in_base)) & 1
                        hex_color_to_use = color_for_fg_pixel if pixel_val == 1 else color_for_bg_pixel
                        try:
                            r_int = int(hex_color_to_use[1:3], 16)
                            g_int = int(hex_color_to_use[3:5], 16)
                            b_int = int(hex_color_to_use[5:7], 16)
                            pixel_data_for_base_tile.append((r_int, g_int, b_int))
                        except ValueError:
                            pixel_data_for_base_tile.append((255,0,255)) # Magenta for error

                if len(pixel_data_for_base_tile) == TILE_WIDTH * TILE_HEIGHT:
                    pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                    # Scale the 8x8 temporary image
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (scaled_tile_w_for_pil, scaled_tile_h_for_pil),
                        Image.Resampling.NEAREST
                    )

                    # Calculate paste position on the pil_rom_viewport_image
                    # This is the tile's top-left on the viewport image, relative to (0,0) of the viewport image
                    paste_x_on_viewport_img = round((c_grid * (tile_display_size + padding) + padding) - view_content_x1)
                    paste_y_on_viewport_img = round((r_grid * (tile_display_size + padding) + padding) - view_content_y1)
                    
                    dialog.pil_rom_viewport_image.paste(pil_scaled_base_tile, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                else:
                    self.debug(f"[D] Incorrect pixel data length for tile {current_rom_tile_absolute_idx}. Skipping paste.")


        # Convert Pillow viewport image to Tk PhotoImage and display
        try:
            dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
        except Exception as e_photoimg:
            self.debug(f"[D] Error converting PIL to Tk PhotoImage for ROM importer: {e_photoimg}"); return

        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1,
                                    image=dialog.tk_rom_photoimage,
                                    anchor=tk.NW,
                                    tags=("rom_content_image", "all_rom_content"))
        except tk.TclError as e_create_img:
            self.debug(f"[D] TclError creating canvas image for ROM importer: {e_create_img}")

        # Redraw selection highlights on top
        self._draw_rom_import_selection_highlight(grid_cols_for_this_draw=current_draw_grid_cols)
        self._update_rom_importer_info_labels()

        if canvas.winfo_exists():
            canvas.update_idletasks() # Ensure image is drawn before method returns

        self.debug("[DEBUG] ### _draw_rom_importer_canvas END ### Pillow Viewport Strategy")

    def _draw_rom_import_selection_highlight(self, grid_cols_for_this_draw=None):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[DEBUG] Highlight: Canvas widget no longer exists. Aborting.")
            return

        try:
            canvas.delete("rom_selection_border")
        except tk.TclError:
            self.debug("[DEBUG] Highlight: TclError deleting 'rom_selection_border'. Ignoring.")

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            self.debug("[DEBUG] Highlight: No selection in selection_dict. Nothing to highlight.")
            return 
        
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        current_grid_cols = 0
        if grid_cols_for_this_draw is not None and grid_cols_for_this_draw > 0:
            current_grid_cols = grid_cols_for_this_draw
        else:
            current_grid_cols = getattr(dialog, 'rom_importer_grid_cols', 1)
            if current_grid_cols <= 0: 
                canvas_width_current = 0
                try:
                    if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
                except tk.TclError: self.debug("[DEBUG] Highlight: TclError getting canvas_width for fallback."); return
                if canvas_width_current <= 1 : self.debug("[DEBUG] Highlight: canvas_width too small for fallback."); return
                current_grid_cols = max(1, canvas_width_current // (tile_display_size + padding))
            self.debug(f"[DEBUG] Highlight: Using fallback/dialog grid_cols: {current_grid_cols}")
        
        if current_grid_cols <= 0:
            self.debug("[DEBUG] Highlight: current_grid_cols is zero or negative. Cannot draw highlights.")
            return

        main_image_items = canvas.find_withtag("rom_content_image")
        
        for selected_tile_idx in selection_dict.keys():
            if not isinstance(selected_tile_idx, int) or selected_tile_idx < 0:
                continue

            grid_r_content, grid_c_content = divmod(selected_tile_idx, current_grid_cols)

            tile_box_content_x1 = grid_c_content * (tile_display_size + padding) + padding
            tile_box_content_y1 = grid_r_content * (tile_display_size + padding) + padding
            tile_box_content_x2 = tile_box_content_x1 + tile_display_size
            tile_box_content_y2 = tile_box_content_y1 + tile_display_size
            
            try:
                if canvas.winfo_exists():
                    rect_id = canvas.create_rectangle(
                        tile_box_content_x1, tile_box_content_y1, 
                        tile_box_content_x2, tile_box_content_y2,
                        outline="yellow", width=1, 
                        tags=("rom_selection_border", "all_rom_content") 
                    )
                    if main_image_items:
                        canvas.tag_raise(rect_id, main_image_items[0]) 
            except tk.TclError as e_rect:
                self.debug(f"[DEBUG] Highlight: TclError creating rectangle for Idx {selected_tile_idx}: {e_rect}")
                break 
        
        self.debug("[DEBUG] --- _draw_rom_import_selection_highlight END ---")

    def _on_rom_canvas_motion(self, event):
        """Handles mouse motion over the ROM importer canvas for hover info and preview."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists(): return

        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        canvas_width_current = 0
        try:
            if canvas.winfo_exists():
                canvas_width_current = canvas.winfo_width()
        except tk.TclError: return

        if canvas_width_current <= 1: return
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        
        clicked_grid_col = int(cx // (tile_display_size + padding)) # Renamed for clarity, though not a click
        clicked_grid_row = int(cy // (tile_display_size + padding))
        hovered_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col
        
        total_potential_tiles = 0
        if len(rom_data) > fine_offset:
            total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        
        # Make sure hovered_rom_tile_absolute_idx is valid before proceeding
        is_valid_hover_idx = (0 <= hovered_rom_tile_absolute_idx < total_potential_tiles)

        if is_valid_hover_idx:
            hovered_byte_start_pos = fine_offset + (hovered_rom_tile_absolute_idx * TILE_WIDTH)
            
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set(
                        f"Offset: {hovered_byte_start_pos} (0x{hovered_byte_start_pos:X}) | Grid Index: {hovered_rom_tile_absolute_idx}"
                    )
                except tk.TclError: pass # Dialog might be closing
            # Pass hovered_rom_tile_absolute_idx to the preview function
            self._draw_rom_tile_preview(hovered_byte_start_pos, hovered_rom_tile_absolute_idx)
        else:
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
                except tk.TclError: pass
            
            preview_canvas = getattr(dialog, 'preview_canvas', None)
            if preview_canvas and preview_canvas.winfo_exists():
                try:
                    preview_canvas.delete("all")
                except tk.TclError: pass

    def _on_rom_canvas_leave(self, event):
        """Clears hover info and preview when mouse leaves ROM importer canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        self.rom_import_dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
        if hasattr(self.rom_import_dialog, 'preview_canvas'): # Check if preview_canvas exists
             self.rom_import_dialog.preview_canvas.delete("all")

    def _on_rom_canvas_left_click(self, event):
        # Handles left-click on ROM importer canvas for complex selection.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return

        # --- Start of existing logic to determine clicked_rom_tile_absolute_idx ---
        rom_data = dialog.rom_data
        current_global_fine_offset = dialog.fine_offset_var.get() 
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = 0
        try:
            if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
        except tk.TclError: return
        if canvas_width_current <=1: return
        
        # Use dialog.rom_importer_grid_cols as it should be up-to-date from the last full draw
        # If it's the very first click before any draw, this might need a default.
        # The _create_rom_importer_dialog now initializes dialog.rom_importer_grid_cols.
        tiles_across = getattr(dialog, 'rom_importer_grid_cols', max(1, canvas_width_current // (tile_display_size + padding)))
        if tiles_across <= 0: tiles_across = 1 # Ensure positive

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        clicked_grid_col = int(cx // (tile_display_size + padding))
        clicked_grid_row = int(cy // (tile_display_size + padding))
        clicked_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col

        total_potential_tiles = 0
        fine_offset_for_total_calc = dialog.fine_offset_var.get()
        if len(rom_data) > fine_offset_for_total_calc :
            total_potential_tiles = (len(rom_data) - fine_offset_for_total_calc) // TILE_WIDTH
        if not (0 <= clicked_rom_tile_absolute_idx < total_potential_tiles):
            self.debug(f"[DEBUG] Click outside valid tile area. Clicked index: {clicked_rom_tile_absolute_idx}, Total potential: {total_potential_tiles}")
            return
        # --- End of logic to determine clicked_rom_tile_absolute_idx ---


        is_shift_pressed = (event.state & 0x0001) != 0
        is_ctrl_pressed = (event.state & 0x0004) != 0
        selection_dict = dialog.rom_importer_selection
        current_anchor_idx = dialog.rom_importer_anchor_idx
        fg_to_associate = dialog.current_importer_fg_idx
        bg_to_associate = dialog.current_importer_bg_idx
        offset_to_associate = current_global_fine_offset # Use current global offset from slider
        properties_tuple_to_associate = (fg_to_associate, bg_to_associate, offset_to_associate)

        self.debug(f"\n[DEBUG] _on_rom_canvas_left_click: Clicked Idx: {clicked_rom_tile_absolute_idx}")
        self.debug(f"[DEBUG] Tiles Across used for click logic: {tiles_across}")
        self.debug(f"[DEBUG] Shift: {is_shift_pressed}, Ctrl: {is_ctrl_pressed}")
        self.debug(f"[DEBUG] Current Anchor: {current_anchor_idx}")
        self.debug(f"[DEBUG] Props to associate: {properties_tuple_to_associate}")
        self.debug(f"[DEBUG] Selection BEFORE: {dict(selection_dict)}") # Less verbose

        selection_changed_in_dict = False # More specific flag

        if is_ctrl_pressed and is_shift_pressed:
            self.debug("[DEBUG] Path: Ctrl+Shift+Click")
            # ... (Ctrl+Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            anchor_props_to_use = properties_tuple_to_associate # Default to current
            if current_anchor_idx != -1 and current_anchor_idx in selection_dict:
                anchor_props_to_use = selection_dict[current_anchor_idx]
                self.debug(f"[DEBUG] Ctrl+Shift: Using properties {anchor_props_to_use} from anchor {current_anchor_idx}.")
            else:
                 self.debug(f"[DEBUG] Ctrl+Shift: No/Invalid anchor, using current global properties {anchor_props_to_use}.")

            min_idx = min(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            max_idx = max(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            for i in range(min_idx, max_idx + 1):
                if i not in selection_dict or selection_dict[i] != anchor_props_to_use:
                    selection_dict[i] = anchor_props_to_use
                    selection_changed_in_dict = True
            if current_anchor_idx == -1: # Set anchor if it was not set
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
                 # selection_changed_in_dict = True # Anchor change is part of selection state
        elif is_shift_pressed:
            self.debug("[DEBUG] Path: Shift+Click")
            # ... (Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if current_anchor_idx != -1:
                new_range_selection = {}
                min_idx = min(current_anchor_idx, clicked_rom_tile_absolute_idx)
                max_idx = max(current_anchor_idx, clicked_rom_tile_absolute_idx)
                for i in range(min_idx, max_idx + 1):
                    new_range_selection[i] = properties_tuple_to_associate
                if selection_dict != new_range_selection: # Compare content
                    selection_dict.clear()
                    selection_dict.update(new_range_selection)
                    selection_changed_in_dict = True
            else: # No anchor, treat as normal click for selection, but set anchor
                if not (len(selection_dict) == 1 and clicked_rom_tile_absolute_idx in selection_dict and selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate):
                    selection_dict.clear()
                    selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                    selection_changed_in_dict = True
                dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
        elif is_ctrl_pressed:
            self.debug("[DEBUG] Path: Ctrl+Click")
            # ... (Ctrl logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if clicked_rom_tile_absolute_idx in selection_dict:
                del selection_dict[clicked_rom_tile_absolute_idx]
                selection_changed_in_dict = True
                if dialog.rom_importer_anchor_idx == clicked_rom_tile_absolute_idx:
                    dialog.rom_importer_anchor_idx = -1 
            else:
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            # Set/update anchor if adding to selection or if it's the only one left
            if clicked_rom_tile_absolute_idx in selection_dict and dialog.rom_importer_anchor_idx != clicked_rom_tile_absolute_idx :
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
            elif not selection_dict : # If selection became empty
                 dialog.rom_importer_anchor_idx = -1

        else: # Normal Click
            self.debug("[DEBUG] Path: Normal Click")
            # ... (Normal click logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            is_already_solely_selected_with_same_props = (
                len(selection_dict) == 1 and
                clicked_rom_tile_absolute_idx in selection_dict and
                selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate
            )
            if not is_already_solely_selected_with_same_props:
                selection_dict.clear()
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx

        # Check if anchor changed, that also means UI state change
        anchor_state_changed = (dialog.rom_importer_anchor_idx != current_anchor_idx)
        
        self.debug(f"[DEBUG] Selection AFTER: {dict(selection_dict)}")
        self.debug(f"[DEBUG] New Anchor: {dialog.rom_importer_anchor_idx}")

        # If selection dict content or anchor changed, then update UI
        if selection_changed_in_dict or anchor_state_changed:
            if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
                dialog.import_button.config(state=tk.NORMAL if selection_dict else tk.DISABLED)
            
            self._update_rom_importer_info_labels() # Updates text vars

            # --- MODIFICATION: Instead of calling highlight directly, trigger a full redraw ---
            self.debug("[DEBUG] Selection/Anchor changed. Triggering full canvas redraw.")
            # Ensure the redraw uses the most recent canvas size if it changed just before click
            # This can be done by calling the configure handler's logic, or just draw
            # self._on_rom_importer_setting_change(configure_event=True) # This will debounce
            # For immediate reflection of selection:
            if canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                 self._draw_rom_importer_canvas() # Direct call
            else: # If canvas not ready, rely on a later configure event to draw
                 self.debug("[DEBUG] Canvas not ready after click, deferring full redraw to configure event.")
            # --- END MODIFICATION ---
        else:
            self.debug("[DEBUG] No change in selection_dict content or anchor. Skipping UI updates from click.")

    def _on_rom_canvas_right_click(self, event):
        """Handles right-click on ROM importer canvas to cancel selection."""
        self._clear_rom_import_selection()

    def _clear_rom_import_selection(self):
        # Clears the current tile selection in the ROM importer dialog.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        dialog = self.rom_import_dialog
        
        selection_was_present = bool(getattr(dialog, 'rom_importer_selection', {}))
        anchor_was_present = (getattr(dialog, 'rom_importer_anchor_idx', -1) != -1)

        if hasattr(dialog, 'rom_importer_selection'):
            dialog.rom_importer_selection.clear()
        else:
            dialog.rom_importer_selection = {} # Ensure it exists
            
        dialog.rom_importer_anchor_idx = -1
            
        if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
            dialog.import_button.config(state=tk.DISABLED) 
        
        self._update_rom_importer_info_labels() # Update text vars

        # If there was a selection or anchor, a redraw is needed to remove highlights
        if selection_was_present or anchor_was_present:
            self.debug("[DEBUG] Selection cleared. Triggering full canvas redraw.")
            canvas = getattr(dialog, 'canvas', None)
            if canvas and canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                self._draw_rom_importer_canvas() # Redraw to remove highlights
            else:
                self.debug("[DEBUG] Canvas not ready after clearing selection, deferring redraw.")
        # else: # No selection was present, _draw_rom_import_selection_highlight would do nothing anyway
        #    self._draw_rom_import_selection_highlight() # Call to ensure no stale borders if logic changes

    def _update_rom_importer_info_labels(self):
        """Updates dynamic labels in the ROM importer (selected count, top-left byte)."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        count = 0
        if hasattr(dialog, 'rom_importer_selection'):
            count = len(dialog.rom_importer_selection)
        
        if hasattr(dialog, 'selection_info_text_var') and isinstance(dialog.selection_info_text_var, tk.StringVar):
            try:
                dialog.selection_info_text_var.set(f"Tiles Selected: {count}")
            except tk.TclError: # Can happen if dialog is closing
                pass
        # top_left_grid_byte_offset_text_var is updated in _draw_rom_importer_canvas

    def _draw_rom_tile_preview(self, rom_byte_start_pos_hover, hovered_rom_tile_absolute_idx=-1):
        """Draws a single tile from ROM data into the preview canvas, using appropriate colors and offset."""
        # rom_byte_start_pos_hover is calculated based on the GLOBAL fine offset for hover info
        # We need to recalculate it here if the tile is selected and has its own offset.

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not hasattr(self.rom_import_dialog, 'preview_canvas'):
            return

        preview_canvas = self.rom_import_dialog.preview_canvas
        rom_data = self.rom_import_dialog.rom_data
        dialog = self.rom_import_dialog
        preview_canvas.delete("all")

        # Determine FG/BG colors and the FINE OFFSET for this preview
        preview_fg_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        preview_bg_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        fine_offset_for_preview = dialog.fine_offset_var.get() # Default to global slider

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if hovered_rom_tile_absolute_idx != -1 and hovered_rom_tile_absolute_idx in selection_dict:
            stored_props = selection_dict[hovered_rom_tile_absolute_idx]
            preview_fg_idx, preview_bg_idx, fine_offset_for_preview = stored_props[0], stored_props[1], stored_props[2]

        # Recalculate the actual starting byte position using the determined fine_offset_for_preview
        # hovered_rom_tile_absolute_idx is the tile's index in the grid if the global offset were 0.
        actual_rom_byte_start_for_preview = fine_offset_for_preview + (hovered_rom_tile_absolute_idx * TILE_WIDTH)

        if not (0 <= actual_rom_byte_start_for_preview < len(rom_data)):
            self.debug(f"[DEBUG] Preview: Invalid actual_rom_byte_start_for_preview {actual_rom_byte_start_for_preview} for tile_idx {hovered_rom_tile_absolute_idx} with offset {fine_offset_for_preview}. Skipping preview.")
            return # Cannot draw if calculated offset is out of bounds

        safe_preview_fg_idx = preview_fg_idx if 0 <= preview_fg_idx < len(self.active_msx_palette) else WHITE_IDX
        safe_preview_bg_idx = preview_bg_idx if 0 <= preview_bg_idx < len(self.active_msx_palette) else BLACK_IDX
        color_for_fg_pixel_preview = self.active_msx_palette[safe_preview_fg_idx]
        color_for_bg_pixel_preview = self.active_msx_palette[safe_preview_bg_idx]

        if actual_rom_byte_start_for_preview + TILE_WIDTH > len(rom_data):
            num_bytes_avail = len(rom_data) - actual_rom_byte_start_for_preview
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview:] + bytes(TILE_WIDTH - num_bytes_avail)
        else:
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview : actual_rom_byte_start_for_preview + TILE_WIDTH]

        pixel_render_size = EDITOR_PIXEL_SIZE
        for r_tile_pixel in range(TILE_HEIGHT):
            if r_tile_pixel >= len(tile_bytes_data): continue
            row_byte = tile_bytes_data[r_tile_pixel]
            for c_tile_pixel in range(TILE_WIDTH):
                pixel_is_set = (row_byte >> (7 - c_tile_pixel)) & 1
                color_hex = color_for_fg_pixel_preview if pixel_is_set else color_for_bg_pixel_preview

                x1 = c_tile_pixel * pixel_render_size
                y1 = r_tile_pixel * pixel_render_size
                x2 = x1 + pixel_render_size
                y2 = y1 + pixel_render_size
                try:
                    if preview_canvas.winfo_exists():
                        preview_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey")
                except tk.TclError:
                    return

    def _on_rom_canvas_keypress(self, event):
        # Handles keyboard navigation for the ROM importer canvas.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        canvas = getattr(self.rom_import_dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return
        
        dialog = self.rom_import_dialog # Get dialog reference
        key_pressed = event.keysym
        self.debug(f"[DEBUG] Keypress: {key_pressed}") # Keep for now if needed

        action_taken = False
        native_scroll_performed = False 

        if key_pressed == "Up":
            canvas.yview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Down":
            canvas.yview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Left":
            canvas.xview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Right":
            canvas.xview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Prior": # PageUp
            canvas.yview_scroll(-1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Next": # PageDown
            canvas.yview_scroll(1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Home":
            current_x_frac, _ = canvas.xview()
            if current_x_frac != 0.0: canvas.xview_moveto(0.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac != 0.0: canvas.yview_moveto(0.0); native_scroll_performed = True
            action_taken = True
        elif key_pressed == "End":
            current_x_frac, _ = canvas.xview()
            if current_x_frac < 1.0: canvas.xview_moveto(1.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac < 1.0: canvas.yview_moveto(1.0); native_scroll_performed = True
            action_taken = True
        else:
            return 

        if action_taken:
            # If a native scroll was performed, or for Home/End, schedule a debounced redraw
            if native_scroll_performed or key_pressed in ["Home", "End"]:
                self.debug(f"[DEBUG] Keypress '{key_pressed}': Scheduling debounced _draw_rom_importer_canvas.")
                
                # Use dialog.redraw_timer_id for consistency with <Configure>
                if not hasattr(dialog, 'redraw_timer_id'): # Should have been init in _create_dialog
                    dialog.redraw_timer_id = None

                if dialog.redraw_timer_id is not None:
                    dialog.after_cancel(dialog.redraw_timer_id)
                
                # Perform_debounced_rom_canvas_draw already exists and calls _draw_rom_importer_canvas
                # It also clears its own timer ID.
                dialog.redraw_timer_id = dialog.after(30, self._perform_debounced_rom_canvas_draw) # 30ms delay
        return "break"

    def _execute_rom_tile_import(self):
        """Reads selected tile data from ROM and appends to the main tileset, using stored colors and offsets."""
        global num_tiles_in_set, current_tile_index, tileset_patterns, tileset_colors

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            messagebox.showwarning("Import Error", "No tiles selected from ROM.", parent=dialog)
            return

        rom_data = dialog.rom_data
        # The global fine_offset_var is NOT directly used here for data fetching;
        # we use the per-tile stored offset.

        # Items are (absolute_rom_tile_idx, (fg, bg, fine_offset_at_selection))
        sorted_selected_items = sorted(selection_dict.items(), key=lambda item: item[0])

        num_tiles_to_import_attempt = len(sorted_selected_items)
        imported_tiles_count = 0

        first_newly_imported_tile_index = -1

        for current_rom_tile_absolute_idx, (fg_idx_for_import, bg_idx_for_import, fine_offset_for_import) in sorted_selected_items:
            if num_tiles_in_set >= MAX_TILES:
                messagebox.showinfo(
                    "Import Limit Reached",
                    f"Tileset limit of {MAX_TILES} reached.\nImported {imported_tiles_count} of {num_tiles_to_import_attempt} selected tiles.",
                    parent=dialog
                )
                break

            # Calculate the starting byte position in rom_data using the tile's stored fine_offset_for_import
            rom_byte_start_pos = fine_offset_for_import + (current_rom_tile_absolute_idx * TILE_WIDTH)

            if not (0 <= rom_byte_start_pos < len(rom_data)):
                self.debug(f"[DEBUG] ROM Import EXEC: Skipping invalid ROM tile index {current_rom_tile_absolute_idx} with stored offset {fine_offset_for_import}, leading to offset {rom_byte_start_pos} out of bounds for ROM size {len(rom_data)}")
                continue

            new_tile_pattern_data = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
            # Colors for all rows of this tile will be the same pair
            new_tile_color_data = [(fg_idx_for_import, bg_idx_for_import) for _ in range(TILE_HEIGHT)]

            if rom_byte_start_pos + TILE_WIDTH > len(rom_data):
                num_bytes_avail = len(rom_data) - rom_byte_start_pos
                tile_bytes_from_rom = rom_data[rom_byte_start_pos:] + bytes(TILE_WIDTH - num_bytes_avail)
            else:
                tile_bytes_from_rom = rom_data[rom_byte_start_pos : rom_byte_start_pos + TILE_WIDTH]

            for r_pixel in range(TILE_HEIGHT):
                if r_pixel < len(tile_bytes_from_rom):
                    row_byte_value = tile_bytes_from_rom[r_pixel]
                    for c_pixel in range(TILE_WIDTH):
                        new_tile_pattern_data[r_pixel][c_pixel] = (row_byte_value >> (7 - c_pixel)) & 1
                else:
                    for c_pixel in range(TILE_WIDTH):
                        new_tile_pattern_data[r_pixel][c_pixel] = 0

            if num_tiles_in_set < MAX_TILES:
                if len(tileset_patterns) > num_tiles_in_set and len(tileset_colors) > num_tiles_in_set:
                    if first_newly_imported_tile_index == -1:
                        first_newly_imported_tile_index = num_tiles_in_set

                    tileset_patterns[num_tiles_in_set] = new_tile_pattern_data
                    tileset_colors[num_tiles_in_set] = new_tile_color_data

                    num_tiles_in_set += 1
                    imported_tiles_count += 1
                    self._mark_project_modified()
                else:
                    self.debug(f"[DEBUG] ROM Import EXEC Error: Tileset data structures not large enough for index {num_tiles_in_set}.")
                    # This indicates a critical issue if MAX_TILES is the conceptual limit but lists are smaller
                    break
            else:
                # This break handles the case where MAX_TILES is reached mid-import loop
                break

        parent_dialog_for_messagebox = self.rom_import_dialog
        self._close_rom_importer_dialog()

        if imported_tiles_count > 0:
            if first_newly_imported_tile_index != -1:
                current_tile_index = first_newly_imported_tile_index
            else:
                current_tile_index = num_tiles_in_set - 1

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()

            if hasattr(self, 'notebook') and hasattr(self, 'tab_tile_editor'):
                try:
                    self.notebook.select(self.tab_tile_editor)
                except tk.TclError:
                    self.debug("[DEBUG] TclError selecting tile editor tab after import (notebook/tab gone?).")

            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._update_edit_menu_state()

            messagebox.showinfo("Import Successful",
                                f"Successfully imported {imported_tiles_count} tile(s).",
                                parent=self.root)
        elif num_tiles_to_import_attempt > 0 :
             messagebox.showwarning("Import Notice",
                                   "No new tiles were imported. Tileset might be full or selected ROM data was out of bounds.",
                                   parent=self.root)

    def _get_zoomed_supertile_pixel_dims(self):
        """
        Calculates the pixel width and height of one supertile on the map canvas
        at the current zoom level, based on the project's supertile dimensions.
        Returns a tuple (width_pixels, height_pixels).
        """
        zoomed_tile_size = self.get_zoomed_tile_size() # This is pixels per TILE_WIDTH/TILE_HEIGHT (8x8) unit

        if zoomed_tile_size <= 0: # Defensive check
            return 0, 0

        zoomed_supertile_pixel_width = self.supertile_grid_width * zoomed_tile_size
        zoomed_supertile_pixel_height = self.supertile_grid_height * zoomed_tile_size
        
        # Ensure minimum 1 pixel if dimensions are very small but > 0
        zoomed_supertile_pixel_width = max(1, zoomed_supertile_pixel_width)
        zoomed_supertile_pixel_height = max(1, zoomed_supertile_pixel_height)

        return zoomed_supertile_pixel_width, zoomed_supertile_pixel_height

    def _update_supertile_rotate_button_state(self):
        """
        Updates the state of the supertile rotate button based on whether
        the current supertile dimensions are square.
        """
        if hasattr(self, 'st_rotate_button') and self.st_rotate_button.winfo_exists():
            try:
                if self.supertile_grid_width == self.supertile_grid_height:
                    self.st_rotate_button.config(state=tk.NORMAL)
                else:
                    self.st_rotate_button.config(state=tk.DISABLED)
            except tk.TclError:
                # Widget might be in the process of being destroyed, or not fully ready
                pass
        # else: button doesn't exist yet, will be configured when created

    def _reconfigure_supertile_definition_canvas(self):
        """
        Reconfigures the size of the supertile definition canvas based on the
        current self.supertile_grid_width and self.supertile_grid_height.
        Then redraws its content.
        """
        if hasattr(self, 'supertile_def_canvas') and self.supertile_def_canvas.winfo_exists():
            try:
                # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32)
                new_canvas_w = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
                new_canvas_h = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
                
                # Ensure minimum practical size for the canvas
                new_canvas_w = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_w) # Min width of one mini-tile
                new_canvas_h = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_h) # Min height of one mini-tile

                self.supertile_def_canvas.config(width=new_canvas_w, height=new_canvas_h)
                
                # The scrollregion for this canvas might not be strictly necessary if it's always
                # sized to fit its content perfectly and doesn't scroll.
                # If it were to scroll (e.g., fixed size canvas viewing larger def),
                # then scrollregion would need update: self.supertile_def_canvas.config(scrollregion=(0,0,new_canvas_w, new_canvas_h))

                self.draw_supertile_definition_canvas() # Redraw content after resize
            except tk.TclError:
                self.debug("[DEBUG]TclError during supertile definition canvas reconfiguration.")
                pass
            except Exception as e:
                self.debug(f"[DEBUG]Error reconfiguring supertile definition canvas: {e}")
                pass
        # else: canvas not yet created or already destroyed.


    def create_map_render_of_supertile(self, supertile_index, target_render_width, target_render_height):
        # Creates a Pillow Image for a supertile, scaled to target_render_width/height.
        # Cache now stores Pillow.Image objects.

        safe_target_render_width = max(1, int(target_render_width))
        safe_target_render_height = max(1, int(target_render_height))

        cache_key = (supertile_index, safe_target_render_width, safe_target_render_height, 
                     self.supertile_grid_width, self.supertile_grid_height)
        
        if cache_key in self.map_render_cache:
            return self.map_render_cache[cache_key]

        # Create a Pillow Image for the entire scaled supertile
        # Use 'RGB' mode. If alpha is needed later, can change to 'RGBA'.
        try:
            # Ensure dimensions are positive for Image.new
            pil_supertile_image = Image.new('RGB', 
                                          (max(1, safe_target_render_width), max(1, safe_target_render_height)), 
                                          INVALID_SUPERTILE_COLOR) # Fill with invalid color initially
        except ValueError as e_img_new: # e.g. negative size if calculations somehow fail
            self.debug(f"[DEBUG] Error creating Pillow image for supertile {supertile_index} (size {safe_target_render_width}x{safe_target_render_height}): {e_img_new}")
            # Return a minimal placeholder Pillow image on error
            placeholder_pil = Image.new('RGB', (1,1), INVALID_SUPERTILE_COLOR)
            self.map_render_cache[cache_key] = placeholder_pil # Cache placeholder to avoid re-erroring
            return placeholder_pil


        if not (0 <= supertile_index < num_supertiles):
            # Already filled with INVALID_SUPERTILE_COLOR
            self.map_render_cache[cache_key] = pil_supertile_image
            return pil_supertile_image

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            self.debug(f"[DEBUG] Supertile {supertile_index} dim mismatch for map render.")
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image

        # Size of one base 8x8 tile when scaled to fit within the target_render_width/height
        scaled_base_tile_w = safe_target_render_width / src_st_tile_grid_w
        scaled_base_tile_h = safe_target_render_height / src_st_tile_grid_h

        # Ensure scaled base tile dimensions are at least 1 pixel for Pillow's resize
        # Pillow's resize to (0,0) or (0,X) or (X,0) might error or produce unexpected results.
        # We round them, then ensure they are at least 1.
        final_scaled_base_tile_w = max(1, round(scaled_base_tile_w))
        final_scaled_base_tile_h = max(1, round(scaled_base_tile_h))


        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))

        for r_st_def in range(src_st_tile_grid_h): # Row in supertile definition
            for c_st_def in range(src_st_tile_grid_w): # Col in supertile definition
                tile_idx_from_st_def = definition[r_st_def][c_st_def]
                
                pixel_data_for_base_tile = [] # Flat list of (r,g,b) tuples for 8x8 tile
                valid_tile = True

                if not (0 <= tile_idx_from_st_def < num_tiles_in_set):
                    valid_tile = False
                else:
                    pattern = tileset_patterns[tile_idx_from_st_def]
                    colors = tileset_colors[tile_idx_from_st_def]

                    for y_pixel_in_base in range(TILE_HEIGHT): # 0-7
                        if not (y_pixel_in_base < len(pattern) and y_pixel_in_base < len(colors)):
                            valid_tile = False; break # Malformed tile data
                        
                        fg_idx, bg_idx = colors[y_pixel_in_base]
                        if not (0 <= fg_idx < len(self.active_msx_palette) and \
                                0 <= bg_idx < len(self.active_msx_palette)):
                            fg_color_hex = INVALID_TILE_COLOR; bg_color_hex = INVALID_TILE_COLOR
                        else:
                            fg_color_hex = self.active_msx_palette[fg_idx]
                            bg_color_hex = self.active_msx_palette[bg_idx]

                        row_pattern_data = pattern[y_pixel_in_base]
                        if not (len(row_pattern_data) == TILE_WIDTH):
                            valid_tile = False; break # Malformed tile row

                        for x_pixel_in_base in range(TILE_WIDTH): # 0-7
                            pixel_val = row_pattern_data[x_pixel_in_base]
                            color_hex_to_use = fg_color_hex if pixel_val == 1 else bg_color_hex
                            try:
                                # Pillow needs RGB tuples, not hex strings for putdata
                                r_int = int(color_hex_to_use[1:3], 16)
                                g_int = int(color_hex_to_use[3:5], 16)
                                b_int = int(color_hex_to_use[5:7], 16)
                                pixel_data_for_base_tile.append((r_int, g_int, b_int))
                            except ValueError: # Invalid hex string
                                pixel_data_for_base_tile.append((255,0,255)) # Magenta for error
                    if not valid_tile: break
                
                if not valid_tile or len(pixel_data_for_base_tile) != TILE_WIDTH * TILE_HEIGHT:
                    # Fill this part of supertile with invalid color if base tile is bad
                    # Create a temporary Pillow image for the scaled error tile
                    error_scaled_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)
                    paste_x = round(c_st_def * scaled_base_tile_w)
                    paste_y = round(r_st_def * scaled_base_tile_h)
                    pil_supertile_image.paste(error_scaled_tile, (paste_x, paste_y))
                    continue

                # Populate the 8x8 temporary Pillow image
                pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                # Scale the 8x8 temporary image to its final size within the supertile
                try:
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (final_scaled_base_tile_w, final_scaled_base_tile_h),
                        Image.Resampling.NEAREST
                    )
                except ValueError as e_resize: # e.g. if final_scaled_base_tile_w/h are zero
                    self.debug(f"[DEBUG] Error resizing base tile in supertile {supertile_index}: {e_resize}")
                    pil_scaled_base_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)


                # Calculate paste position (top-left) for this scaled base tile
                # Use floating point scaled_base_tile_w/h for paste position calculation
                # then round for the final integer paste coordinates.
                paste_x = round(c_st_def * scaled_base_tile_w)
                paste_y = round(r_st_def * scaled_base_tile_h)

                pil_supertile_image.paste(pil_scaled_base_tile, (paste_x, paste_y))

        self.map_render_cache[cache_key] = pil_supertile_image
        return pil_supertile_image

    def _handle_map_scroll_event(self, event=None):
        # This method is called by scrollbar interactions.
        # It needs to redraw the main map canvas content and the minimap.
        # A small delay can sometimes help smooth out rapid scrollbar dragging,
        # but let's try direct calls first. If it's choppy, we can add debouncing.
        if self.map_canvas and self.map_canvas.winfo_exists():
            self.draw_map_canvas() # Redraw main map content
            self.draw_minimap()    # Update minimap

    def _perform_debounced_rom_canvas_draw(self):
        # This method is called by the 'after' timer from _on_rom_importer_setting_change (e.g. Configure)
        # and from scrollbar/keypress handlers in the ROM importer.
        
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.debug("[DEBUG] DebouncedRomDraw: ROM import dialog no longer exists. Aborting.")
            return
        
        dialog = self.rom_import_dialog
        
        # Clear the timer ID if it exists on the dialog object
        if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
            dialog.redraw_timer_id = None # Mark timer as having fired/been cleared

        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            self.debug("[DEBUG] DebouncedRomDraw: ROM importer canvas no longer exists. Aborting.")
            return
            
        # Check canvas size again before drawing, as it might still be too small
        # if configure events are rapid or window is being minimized.
        canvas_w = canvas.winfo_width()
        canvas_h = canvas.winfo_height()
        min_draw_size = VIEWER_TILE_SIZE # A sensible minimum, e.g., one tile
        
        if canvas_w < min_draw_size or canvas_h < min_draw_size:
            self.debug(f"[DEBUG] DebouncedRomDraw: Canvas still too small (W:{canvas_w}, H:{canvas_h}). Rescheduling.")
            # Reschedule the debounced draw if canvas is not yet ready
            if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
                 dialog.after_cancel(dialog.redraw_timer_id) # Cancel if somehow another one got set
            dialog.redraw_timer_id = dialog.after(100, self._perform_debounced_rom_canvas_draw) # Try again
            return

        self.debug("[DEBUG] DebouncedRomDraw: Conditions met. Calling _draw_rom_importer_canvas.")
        self._draw_rom_importer_canvas() # Call the (now Pillow-optimized) drawing method

    def _on_fine_offset_slider_change(self, slider_value_str=None):
        """Handles the fine_offset slider value change with debouncing and snapping."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        # Ensure the slider_redraw_timer_id attribute exists on the dialog object
        if not hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None

        if slider_value_str is not None:
            try:
                # The value from the slider command is a string representation of a float
                current_float_val = float(slider_value_str)
                rounded_int_val = round(current_float_val) # Round to nearest integer

                # Ensure the rounded value is within the slider's defined range (0-7)
                # This is mostly a safeguard, as 'from_' and 'to' should constrain it.
                clamped_int_val = max(0, min(7, rounded_int_val))

                # Update the IntVar. This will cause the slider to visually snap
                # if its current internal float value was different from the rounded int.
                # Only set if different to avoid potential recursive calls if not careful,
                # though with an IntVar, Tkinter usually handles this well.
                if dialog.fine_offset_var.get() != clamped_int_val:
                    dialog.fine_offset_var.set(clamped_int_val)
                    # No need to call _draw_rom_importer_canvas here directly.
                    # The debouncer will handle it based on the *final* settled value.
                    # If you wanted instant preview of the *snapped* value, you could add it here.

            except ValueError:
                # Handle cases where slider_value_str might not be a valid float string
                # This shouldn't happen with a standard Scale widget but good for robustness.
                pass # Keep current var value if conversion fails

        # Cancel any previously scheduled redraw for the slider
        if dialog.slider_redraw_timer_id is not None:
            dialog.after_cancel(dialog.slider_redraw_timer_id)
        
        # Schedule the actual redraw after a short delay
        # _perform_debounced_slider_redraw will use dialog.fine_offset_var.get()
        dialog.slider_redraw_timer_id = dialog.after(250, self._perform_debounced_slider_redraw)

    def _perform_debounced_slider_redraw(self):
        """Called by the after timer to redraw the ROM importer canvas after slider movement has paused."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        
        # Ensure the slider_redraw_timer_id attribute exists before trying to clear it
        if hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None # Clear the timer ID

        # Now, call the main drawing function for the ROM importer canvas
        # This function will use the current value of dialog.fine_offset_var.get()
        self._draw_rom_importer_canvas()

    def _update_importer_color_swatches(self):
        """Updates the BG/FG color swatches in the ROM importer dialog."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        # Ensure swatches and color indices exist on dialog
        if not all(hasattr(dialog, attr) for attr in ['importer_fg_swatch', 'importer_bg_swatch', 
                                                      'current_importer_fg_idx', 'current_importer_bg_idx']):
            return

        try:
            fg_color_hex = self.active_msx_palette[dialog.current_importer_fg_idx]
            bg_color_hex = self.active_msx_palette[dialog.current_importer_bg_idx]

            if dialog.importer_fg_swatch.winfo_exists():
                dialog.importer_fg_swatch.config(bg=fg_color_hex, fg=get_contrast_color(fg_color_hex))
            if dialog.importer_bg_swatch.winfo_exists():
                dialog.importer_bg_swatch.config(bg=bg_color_hex, fg=get_contrast_color(bg_color_hex))
        except IndexError:
            self.debug("[DEBUG] Error updating importer swatches: Palette index out of range.")
        except tk.TclError:
            self.debug("[DEBUG] Error updating importer swatches: TclError (widget likely destroyed).")


    def _pick_importer_color(self, swatch_type):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not self.active_msx_palette:
            return

        dialog = self.rom_import_dialog
        
        # Create a standard Toplevel window for the picker
        picker_win = tk.Toplevel(dialog)
        picker_win.title(f"Select Importer {'FG' if swatch_type == 'fg' else 'BG'} Color")
        picker_win.transient(dialog) # Make it a "child" of the dialog
        picker_win.grab_set()      # Modal behavior
        picker_win.resizable(False, False)

        # Canvas for color swatches
        picker_canvas_size_w = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        picker_canvas_size_h = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        
        picker_canvas = tk.Canvas(picker_win, 
                                  width=picker_canvas_size_w, 
                                  height=picker_canvas_size_h, 
                                  borderwidth=0, highlightthickness=0)
        picker_canvas.pack(padx=5, pady=5)

        selected_palette_index_from_picker = tk.IntVar(value=-1) 

        def on_palette_color_click(event, index_clicked):
            selected_palette_index_from_picker.set(index_clicked)
            picker_win.destroy() # This is the primary way it should close

        # Bind Escape to close the picker window
        picker_win.bind("<Escape>", lambda e: picker_win.destroy())

        # Populate the picker canvas with color swatches
        for i in range(len(self.active_msx_palette)): 
            row, col = divmod(i, 4)
            x1 = col * (PALETTE_SQUARE_SIZE + 2) + 2
            y1 = row * (PALETTE_SQUARE_SIZE + 2) + 2
            x2 = x1 + PALETTE_SQUARE_SIZE
            y2 = y1 + PALETTE_SQUARE_SIZE
            color_hex = self.active_msx_palette[i]
            
            rect_id = picker_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey", width=1, tags=f"picker_swatch_{i}")
            picker_canvas.tag_bind(rect_id, "<Button-1>", 
                                   lambda e, idx=i: on_palette_color_click(e, idx))
            # Optional: Add hover effects back if desired, but keep it simple first
            # picker_canvas.tag_bind(rect_id, "<Enter>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="yellow", width=2))
            # picker_canvas.tag_bind(rect_id, "<Leave>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="grey", width=1))
        
        # --- Positioning Logic ---
        picker_win.update_idletasks() # Calculate picker's required size

        clicked_swatch_widget = None
        if swatch_type == 'fg':
            clicked_swatch_widget = getattr(dialog, 'importer_fg_swatch', None)
        elif swatch_type == 'bg':
            clicked_swatch_widget = getattr(dialog, 'importer_bg_swatch', None)

        if clicked_swatch_widget and clicked_swatch_widget.winfo_exists():
            dialog.update_idletasks() # Ensure main dialog geometry is current
            
            swatch_screen_x = clicked_swatch_widget.winfo_rootx()
            swatch_screen_y = clicked_swatch_widget.winfo_rooty()
            swatch_width = clicked_swatch_widget.winfo_width()
            
            target_x_pos = swatch_screen_x + swatch_width + 5 # Position to the right
            target_y_pos = swatch_screen_y                     # Align top edges

            picker_w = picker_win.winfo_width() 
            picker_h = picker_win.winfo_height()
            screen_w = picker_win.winfo_screenwidth()
            screen_h = picker_win.winfo_screenheight()

            # Adjust if off-screen (simplified boundary check)
            if target_x_pos + picker_w > screen_w:
                target_x_pos = swatch_screen_x - picker_w - 5 # Try left
            if target_x_pos < 0: # Still off left, or was initially off left
                 target_x_pos = 5 # Fallback to near left edge of screen
            
            if target_y_pos + picker_h > screen_h:
                target_y_pos = screen_h - picker_h - 5 # Move up from bottom
            if target_y_pos < 0:
                target_y_pos = 5 # Fallback to near top edge of screen
            
            picker_win.geometry(f"+{target_x_pos}+{target_y_pos}")
        else:
            # Fallback: Center on the ROM importer dialog if swatch widget not found or other issue
            self.debug("[DEBUG] _pick_importer_color: Swatch widget not found or error; using fallback centering.")
            picker_win.update_idletasks()
            dialog_x = dialog.winfo_rootx()
            dialog_y = dialog.winfo_rooty()
            dialog_w = dialog.winfo_width()
            picker_w = picker_win.winfo_width()
            x_pos = dialog_x + (dialog_w // 2) - (picker_w // 2)
            y_pos = dialog_y + 50 # Offset slightly from dialog top
            picker_win.geometry(f"+{max(0, x_pos)}+{max(0, y_pos)}") # Ensure on screen
        
        picker_win.focus_set()
        picker_win.wait_window() # This blocks until picker_win is destroyed

        # --- Post-picker logic (after it's closed) ---
        chosen_idx = selected_palette_index_from_picker.get()
        if 0 <= chosen_idx < len(self.active_msx_palette):
            changed_color = False
            if swatch_type == 'fg':
                if dialog.current_importer_fg_idx != chosen_idx:
                    dialog.current_importer_fg_idx = chosen_idx
                    changed_color = True
            elif swatch_type == 'bg':
                if dialog.current_importer_bg_idx != chosen_idx:
                    dialog.current_importer_bg_idx = chosen_idx
                    changed_color = True
            
            if changed_color:
                self._update_importer_color_swatches()
                self._draw_rom_importer_canvas()

    def confirm_quit(self):
        """Checks for unsaved changes and prompts user before quitting."""
        if self.project_modified:
            # Ask: "Save changes to [Project Name / Untitled] before quitting?"
            project_name_display = "Untitled"
            if self.current_project_base_path:
                project_name_display = os.path.basename(self.current_project_base_path)
            
            response = messagebox.askyesnocancel(
                "Quit MSX Tile Forge",
                f"Save changes to '{project_name_display}' before quitting?",
                parent=self.root # Ensure dialog is on top of main window
            )

            if response is True:  # Yes, Save
                save_successful = self.save_project() # save_project handles "Save As" if needed
                if save_successful: # If save_project itself wasn't cancelled by user
                    self.root.destroy()
                # If save_successful is False, it means user cancelled the save dialog
                # or an error occurred. In this case, we DON'T quit, allowing them
                # to try saving again or to cancel quitting.
            elif response is False:  # No, Don't Save
                self.root.destroy()
            elif response is None:  # Cancel
                return # Do nothing, don't quit
        else:
            # No unsaved changes, quit directly
            self.root.destroy()

    def _on_palette_pane_configure_for_redraw_only(self, event=None):
        # Called when the palette pane in the map editor is resized.
        # Solely responsible for debouncing the redraw of its content (map_supertile_selector_canvas).
        
        current_pane_event_width = getattr(event, 'width', 'N/A') # Get width if event is provided
        self.debug(f"[DEBUG] _on_palette_pane_configure_for_redraw_only: Event (width={current_pane_event_width}). Scheduling selector redraw.")

        if hasattr(self, '_palette_pane_resize_timer') and self._palette_pane_resize_timer is not None:
            try:
                self.root.after_cancel(self._palette_pane_resize_timer)
            except tk.TclError: pass 
        
        if not hasattr(self, '_palette_pane_resize_timer'): 
            self._palette_pane_resize_timer = None
            
        self._palette_pane_resize_timer = self.root.after(100, self._redraw_map_supertile_selector_debounced)
        self.debug(f"[DEBUG] === _on_palette_pane_configure_for_redraw_only END ===") # Optional: reduce log noise

    def _redraw_map_supertile_selector_debounced(self):
        # Actual redraw function called by the debouncer.
        self._palette_pane_resize_timer = None # Clear timer ID
        if hasattr(self, 'map_supertile_selector_canvas') and \
           self.map_supertile_selector_canvas.winfo_exists():
            self.debug("[DEBUG] Palette pane configured, redrawing map_supertile_selector_canvas.")
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        else:
            self.debug("[DEBUG] Palette pane configured, but map_supertile_selector_canvas not ready/exists.")

    def _enforce_palette_min_width_on_release(self, event=None):
        # Called on ButtonRelease-1 on the PanedWindow.
        # Checks if the palette pane is too small and corrects sash if needed.
        self.debug(f"\n[DEBUG] === _enforce_palette_min_width_on_release START ===")
        
        palette_pane_widget = getattr(self, 'map_editor_palette_pane_container', None)
        paned_window_widget = getattr(self, 'map_paned_window', None)

        if not paned_window_widget or not paned_window_widget.winfo_exists() or \
           not palette_pane_widget or not palette_pane_widget.winfo_exists():
            self.debug("[DEBUG] EnforceMinOnRelease: Required widgets missing. Aborting.")
            self.debug("[DEBUG] === _enforce_palette_min_width_on_release END (widgets missing) ===")
            return

        try:
            # Give Tkinter a moment to settle sizes after drag release, then check
            # This 'after' helps ensure winfo_width() is up-to-date.
            self.root.after(10, self._do_check_and_enforce_palette_min_width) 
            
        except Exception as e: 
            self.debug(f"[DEBUG] Unexpected error scheduling enforcement check: {e}")
        
        self.debug(f"[DEBUG] === _enforce_palette_min_width_on_release END (check scheduled) ===")

    def _do_check_and_enforce_palette_min_width(self):
        self.debug(f"\n[DEBUG] --- _do_check_and_enforce_palette_min_width ---")

        map_pane_container = getattr(self, 'map_editor_map_pane_container', None)
        palette_pane_container = getattr(self, 'map_editor_palette_pane_container', None)
        paned_window_widget = getattr(self, 'map_paned_window', None)

        if not paned_window_widget or not paned_window_widget.winfo_exists() or \
           not palette_pane_container or not palette_pane_container.winfo_exists() or \
           not map_pane_container or not map_pane_container.winfo_exists():
            self.debug("[DEBUG] DoCheckEnforce: Required paned window/pane widgets missing. Aborting.")
            return

        try:
            paned_window_total_width = paned_window_widget.winfo_width()
            sash_thickness_approx = 8 
            
            if paned_window_total_width < 50: 
                self.debug(f"[DEBUG] DoCheckEnforce: PanedWindow total width ({paned_window_total_width}) too small. Skipping enforcement.")
                return

            self.debug(f"[DEBUG] DoCheckEnforce: PanedWindowTotalW={paned_window_total_width}")

            # Min width for Left Pane (Map Area + Controls)
            # Ensure self.map_controls_min_width has a sensible default if not yet calculated
            # The value 400 worked for you.
            min_left_pane_width = getattr(self, 'map_controls_min_width', 400) 
            if min_left_pane_width <= 10: # If it was calculated as something tiny or was default 0
                min_left_pane_width = 400 # Override with your known good fallback
                self.debug(f"[DEBUG] DoCheckEnforce: Overriding min_left_pane_width to fallback {min_left_pane_width}")
            min_left_pane_width = max(50, min_left_pane_width) # Absolute floor
            self.debug(f"[DEBUG] DoCheckEnforce: Min Left Pane (Map Controls) Width Required: {min_left_pane_width}")

            # Min width for Right Pane (Palette) Content
            padding_for_palette_content = 1
            frame_padding_palette_approx = 20
            scrollbar_width_approx = 10 
            one_supertile_item_w = (self.supertile_grid_width * TILE_WIDTH)
            min_canvas_content_width_palette = (1 * one_supertile_item_w) + (1 + 1) * padding_for_palette_content 
            min_canvas_content_width_palette = max(32, min_canvas_content_width_palette)
            min_total_right_pane_width = min_canvas_content_width_palette + frame_padding_palette_approx + scrollbar_width_approx
            self.debug(f"[DEBUG] DoCheckEnforce: Min Total Right Pane (Palette) Width Required: {min_total_right_pane_width}")

            current_sash_0_pos = paned_window_widget.sashpos(0)
            final_target_sash_pos = current_sash_0_pos # Start with current, adjust if needed
            self.debug(f"[DEBUG] DoCheckEnforce: Initial current_sash_pos(0) = {final_target_sash_pos}")

            # Calculate desired sash position to satisfy right pane's minimum
            sash_for_right_min = paned_window_total_width - min_total_right_pane_width - sash_thickness_approx
            
            # Calculate desired sash position to satisfy left pane's minimum
            sash_for_left_min = min_left_pane_width

            needs_correction = False

            # If left pane is too small
            if current_sash_0_pos < sash_for_left_min:
                self.debug(f"[DEBUG] DoCheckEnforce: Left pane ({current_sash_0_pos}) is smaller than required ({sash_for_left_min}). Targetting {sash_for_left_min}.")
                final_target_sash_pos = sash_for_left_min
                needs_correction = True
            
            # Now, check if this 'final_target_sash_pos' makes the right pane too small
            effective_right_pane_width = paned_window_total_width - final_target_sash_pos - sash_thickness_approx
            if effective_right_pane_width < min_total_right_pane_width:
                self.debug(f"[DEBUG] DoCheckEnforce: Giving left pane its min would make right pane ({effective_right_pane_width}) too small (min {min_total_right_pane_width}).")
                # This means we might not be able to satisfy both. Prioritize left pane's minimum.
                # The 'final_target_sash_pos' is already set to satisfy the left pane.
                # If we wanted to prioritize right, we'd set: final_target_sash_pos = sash_for_right_min
                # and then re-check if left became too small.
                # The current logic: if left needs X, set sash to X. If this makes right too small, tough for right.
                # Let's refine: try to satisfy both, but if conflict, choose.
                
                # Can we satisfy both?
                if (sash_for_left_min + sash_thickness_approx + min_total_right_pane_width) <= paned_window_total_width:
                    # Yes, there's enough space for both minimums and the sash.
                    # Ensure left gets its min.
                    final_target_sash_pos = max(final_target_sash_pos, sash_for_left_min)
                    # Ensure right gets its min (adjust sash from left edge).
                    final_target_sash_pos = min(final_target_sash_pos, sash_for_right_min)
                    self.debug(f"[DEBUG] DoCheckEnforce: Enough space for both. Final target after considering both: {final_target_sash_pos}")

                else: # Not enough space for both minimums
                    self.debug(f"[DEBUG] DoCheckEnforce: Not enough total width for both minimums. Prioritizing left pane min.")
                    final_target_sash_pos = sash_for_left_min # Prioritize left pane
                needs_correction = True # A correction is likely needed if we entered this complex block

            # Final clamping of the target sash position to valid PanedWindow bounds
            final_target_sash_pos = max(0, final_target_sash_pos)
            # Ensure right pane at least has space for sash thickness if target is too far right
            final_target_sash_pos = min(final_target_sash_pos, paned_window_total_width - sash_thickness_approx) 
                                          
            self.debug(f"[DEBUG] DoCheckEnforce: OriginalSashPos={current_sash_0_pos}, FinalCalculatedTargetSashPos={final_target_sash_pos}")

            if needs_correction and abs(current_sash_0_pos - final_target_sash_pos) > 2:
                self.debug(f"[DEBUG] DoCheckEnforce: Applying final sashpos(0) to: {final_target_sash_pos}")
                try:
                    paned_window_widget.sashpos(0, final_target_sash_pos)
                except tk.TclError as e_sash:
                    self.debug(f"[DEBUG] DoCheckEnforce: TclError setting sashpos: {e_sash}")
            elif needs_correction: # Corrected value is too close to current, no actual sashpos call
                 self.debug(f"[DEBUG] DoCheckEnforce: Correction calculated but change too small or already correct. Not calling sashpos.")
            else: # No violation detected initially
                self.debug(f"[DEBUG] DoCheckEnforce: No minimum width violations detected. No change to sash needed.")
        
        except tk.TclError as e:
            self.debug(f"[DEBUG] TclError in _do_check_and_enforce_palette_min_width: {e}")
        except Exception as e: 
            self.debug(f"[DEBUG] Unexpected error in _do_check_and_enforce_palette_min_width: {e}")
        self.debug(f"[DEBUG] --- _do_check_and_enforce_palette_min_width END ---")

    def _on_main_window_configure(self, event=None):
        if event and event.widget != self.root:
            return 

        self.debug(f"[DEBUG] _on_main_window_configure: Main window resized/moved (w={self.root.winfo_width()}, h={self.root.winfo_height()}).")

        if hasattr(self, '_main_window_configure_timer') and self._main_window_configure_timer is not None:
            try:
                self.root.after_cancel(self._main_window_configure_timer)
            except tk.TclError: pass
        
        # Ensure this calls the correctly named method
        self._main_window_configure_timer = self.root.after(300, self._call_enforce_min_width_logic_from_main_resize)

    def _call_enforce_min_width_logic_from_main_resize(self): # Renamed for clarity
        self.debug("[DEBUG] --- Main window resize: performing debounced pane minimum check ---")
        if hasattr(self, '_main_window_configure_timer'): 
            self._main_window_configure_timer = None
        
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                # Check if the currently selected tab's frame widget is the map editor's frame widget
                selected_tab_path = self.notebook.select()
                if selected_tab_path: # Ensure a tab is actually selected
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
            except tk.TclError: 
                self.debug("[DEBUG] Main resize check: TclError getting selected tab info.")
        
        if is_map_tab_active:
            # Ensure map_paned_window exists and is mapped (visible) before calling enforce
            if hasattr(self, 'map_paned_window') and \
               self.map_paned_window.winfo_exists() and \
               self.map_paned_window.winfo_ismapped():
                self.debug("[DEBUG] Main resize: Map tab active and paned window mapped. Calling _do_check_and_enforce_palette_min_width.")
                self._do_check_and_enforce_palette_min_width() # Call the core logic
            else:
                self.debug("[DEBUG] Main resize: Map tab active, but map_paned_window not ready/mapped. Skipping enforcement.")
        else:
            self.debug("[DEBUG] Main resize: Map tab not active. Skipping pane minimum enforcement.")

    def _on_map_canvas_configure(self, event=None):
        # Called when the map_canvas itself is resized (e.g., due to sash drag or window resize)
        
        map_canvas_widget = getattr(self, 'map_canvas', None)
        if not map_canvas_widget or not map_canvas_widget.winfo_exists():
            self.debug("[DEBUG] _on_map_canvas_configure: Map canvas not available. Skipping redraw.")
            return

        # event.width and event.height should give the new dimensions of self.map_canvas
        # Fallback to winfo_width/height if event attributes are not present (though they should be for <Configure>)
        new_width = getattr(event, 'width', map_canvas_widget.winfo_width())
        new_height = getattr(event, 'height', map_canvas_widget.winfo_height())

        self.debug(f"[DEBUG] _on_map_canvas_configure: Map canvas configured. New WxH: {new_width}x{new_height}.")

        # We only want to trigger a full redraw if the size has actually changed meaningfully,
        # as <Configure> can also fire for position changes.
        # We can compare with the dimensions of our current Pillow viewport image.
        viewport_changed_width = True # Assume changed unless proven otherwise
        viewport_changed_height = True

        if hasattr(self, 'pil_map_viewport_image') and self.pil_map_viewport_image:
            if self.pil_map_viewport_image.width == new_width:
                viewport_changed_width = False
            if self.pil_map_viewport_image.height == new_height:
                viewport_changed_height = False
        
        # Only redraw if dimensions are valid and have actually changed, or if no viewport image exists yet
        if (new_width > 1 and new_height > 1) and \
           (not hasattr(self, 'pil_map_viewport_image') or self.pil_map_viewport_image is None or viewport_changed_width or viewport_changed_height):
            
            if map_canvas_widget.winfo_ismapped(): # Ensure it's actually visible
                self.debug("[DEBUG] _on_map_canvas_configure: Calling draw_map_canvas() due to size change or initial setup.")
                self.draw_map_canvas() 
                self.draw_minimap()    
            else:
                self.debug("[DEBUG] _on_map_canvas_configure: Map canvas not mapped, draw call skipped despite size change.")
        else:
            self.debug(f"[DEBUG] _on_map_canvas_configure: No significant size change or canvas too small/not ready. W={new_width}, H={new_height}, ViewportChangedW={viewport_changed_width}, ViewportChangedH={viewport_changed_height}. Draw call skipped.")


    def _create_add_many_dialog(self, parent, title_text, prompt_text, current_items, max_items_total):
        """
        Helper to create a dialog for 'Add Many...' functionality.
        Returns the number of items to add, or None if cancelled.
        """
        space_available = max_items_total - current_items
        if space_available <= 0:
            messagebox.showinfo(title_text, "The list is already full.", parent=parent)
            return None

        dialog = tk.Toplevel(parent)
        dialog.title(title_text)
        dialog.transient(parent)
        dialog.grab_set()
        dialog.resizable(False, False)

        # Calculate default value for spinbox
        default_val = 8
        if space_available < 8:
            default_val = space_available
        
        # Frame for content
        main_frame = ttk.Frame(dialog, padding="10")
        main_frame.pack(expand=True, fill="both")

        ttk.Label(main_frame, text=prompt_text).pack(pady=(0, 5))

        spinbox_var = tk.IntVar(value=default_val)
        # Spinbox range is 1 to space_available
        spinbox = ttk.Spinbox(
            main_frame, 
            from_=1, 
            to=max(1, space_available), # Ensure 'to' is at least 1 if space_available is 1
            textvariable=spinbox_var, 
            width=5,
            wrap=False # Do not wrap around
        )
        spinbox.pack(pady=5)
        spinbox.focus_set()
        spinbox.selection_range(0, tk.END) # Select current text for easy overwrite

        # Frame for buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(10, 0))

        result = {"value": None} # Use a dictionary to pass result back

        def on_ok():
            try:
                val = spinbox_var.get()
                if 1 <= val <= space_available:
                    result["value"] = val
                    dialog.destroy()
                else:
                    messagebox.showerror("Invalid Input", f"Please enter a number between 1 and {space_available}.", parent=dialog)
            except tk.TclError: # Handles non-integer input if user types garbage
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.", parent=dialog)


        def on_cancel():
            dialog.destroy() # result["value"] remains None

        ok_button = ttk.Button(button_frame, text="OK", command=on_ok, width=8)
        ok_button.pack(side=tk.LEFT, padx=5)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=on_cancel, width=8)
        cancel_button.pack(side=tk.LEFT, padx=5)

        dialog.bind("<Return>", lambda e: on_ok())
        dialog.bind("<Escape>", lambda e: on_cancel())
        
        # Center dialog on parent
        parent.update_idletasks() # Ensure parent geometry is up to date
        dialog.update_idletasks() # Ensure dialog knows its requested size
        
        parent_x = parent.winfo_rootx()
        parent_y = parent.winfo_rooty()
        parent_w = parent.winfo_width()
        parent_h = parent.winfo_height()
        
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = parent_x + (parent_w // 2) - (dialog_w // 2)
        y_pos = parent_y + (parent_h // 2) - (dialog_h // 2)
        
        dialog.geometry(f"+{x_pos}+{y_pos}")

        dialog.wait_window()
        return result["value"]

    def handle_add_many_tiles(self):
        global num_tiles_in_set, current_tile_index, tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX # Globals

        if num_tiles_in_set >= MAX_TILES:
            messagebox.showinfo("Add Many Tiles", "Tileset is already full.", parent=self.root)
            return

        space_available = MAX_TILES - num_tiles_in_set
        
        num_to_add = self._create_add_many_dialog(
            parent=self.root, # Or the specific tab frame if preferred for modality
            title_text="Add Many Tiles",
            prompt_text=f"How many tiles to add? (1-{space_available})",
            current_items=num_tiles_in_set,
            max_items_total=MAX_TILES
        )

        if num_to_add is None or num_to_add <= 0: # User cancelled or entered invalid
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass # Redraw will happen as part of update_all_displays

        self._mark_project_modified()
        
        first_new_tile_idx = num_tiles_in_set # Index where new tiles will start
        
        for _ in range(num_to_add):
            if num_tiles_in_set < MAX_TILES: # Double check limit inside loop
                # Ensure global lists are extended if they are not pre-allocated to MAX_TILES
                # (Assuming they are already MAX_TILES long and we just update num_tiles_in_set)
                if num_tiles_in_set < len(tileset_patterns) and num_tiles_in_set < len(tileset_colors):
                    tileset_patterns[num_tiles_in_set] = [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    tileset_colors[num_tiles_in_set] = [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    num_tiles_in_set += 1
                else:
                    # This case implies tileset_patterns/colors are not MAX_TILES long, or an issue with num_tiles_in_set
                    self.debug(f"[DEBUG] handle_add_many_tiles: Error - trying to access beyond list capacity for tile {num_tiles_in_set}")
                    break # Stop adding if data structures are not as expected
            else:
                break # Should be caught by space_available and num_to_add logic

        current_tile_index = first_new_tile_idx # Select the first of the newly added tiles
        
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        self.scroll_viewers_to_tile(current_tile_index)
        self._update_editor_button_states()
        self.debug(f"Added {num_to_add} new tiles.")

    def handle_add_many_supertiles(self):
        global num_supertiles, current_supertile_index, supertiles_data # Globals

        if num_supertiles >= MAX_SUPERTILES: # MAX_SUPERTILES is now 65535
            messagebox.showinfo("Add Many Supertiles", "Supertile set is already full.", parent=self.root)
            return

        space_available = MAX_SUPERTILES - num_supertiles

        num_to_add = self._create_add_many_dialog(
            parent=self.root,
            title_text="Add Many Supertiles",
            prompt_text=f"How many supertiles to add? (1-{space_available})",
            current_items=num_supertiles,
            max_items_total=MAX_SUPERTILES
        )

        if num_to_add is None or num_to_add <= 0:
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        self._mark_project_modified()
        
        first_new_st_idx = num_supertiles # Index where new supertiles will start

        for _ in range(num_to_add):
            if num_supertiles < MAX_SUPERTILES:
                # Assuming supertiles_data is always MAX_SUPERTILES long (and initialized)
                if num_supertiles < len(supertiles_data):
                    supertiles_data[num_supertiles] = [
                        [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
                    ]
                    num_supertiles += 1
                else:
                    self.debug(f"[DEBUG] handle_add_many_supertiles: Error - trying to access beyond list capacity for ST {num_supertiles}")
                    break
            else:
                break
        
        current_supertile_index = first_new_st_idx # Select the first new one

        self.supertile_image_cache.clear()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()
        self.debug(f"Added {num_to_add} new supertiles.")

    def append_tileset_from_file(self):
        global tileset_patterns, tileset_colors, current_tile_index, num_tiles_in_set # Using globals

        if num_tiles_in_set >= MAX_TILES:
            messagebox.showinfo("Append Tileset", "Current project tileset is already full. Cannot append.", parent=self.root)
            return

        load_path = filedialog.askopenfilename(
            master=self.root, # Ensure dialog is modal to the main app
            filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
            title="Select Tileset File to Append",
        )
        if not load_path:
            return # User cancelled

        try:
            temp_loaded_patterns = []
            temp_loaded_colors = []
            tiles_in_file_count = 0

            with open(load_path, "rb") as f:
                # Read header
                num_tiles_header_byte_val = f.read(1)
                if not num_tiles_header_byte_val:
                    raise ValueError("Selected file is empty or missing tile count header.")
                
                header_value = struct.unpack("B", num_tiles_header_byte_val)[0]
                tiles_in_file_count = 256 if header_value == 0 else header_value

                if not (1 <= tiles_in_file_count <= MAX_TILES):
                    raise ValueError(f"Invalid tile count in file header: {tiles_in_file_count}.")

                # Read and discard reserved bytes (expecting v0.0.39 format)
                reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                    # This indicates it's either an old format file missing these bytes,
                    # or a corrupted new one. For append, we strictly expect the new format.
                    raise ValueError(f"File '{os.path.basename(load_path)}' does not appear to be a valid v0.0.39+ format tileset file (missing reserved bytes after header). Please migrate it if it's an older version.")
                
                self.debug(f"Info: Read {tiles_in_file_count} tiles header, skipped {RESERVED_BYTES_COUNT} reserved bytes from appending file.")

                # Read all pattern data from file
                bytes_per_tile_pattern = TILE_HEIGHT
                total_pattern_bytes_to_read = tiles_in_file_count * bytes_per_tile_pattern
                all_pattern_data_bytes = f.read(total_pattern_bytes_to_read)
                if len(all_pattern_data_bytes) < total_pattern_bytes_to_read:
                    raise EOFError("EOF while reading pattern data block from append file.")

                current_byte_offset_pattern = 0
                for _i in range(tiles_in_file_count):
                    tile_pattern_data = [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    tile_pattern_bytes = all_pattern_data_bytes[current_byte_offset_pattern : current_byte_offset_pattern + bytes_per_tile_pattern]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_pattern_bytes[r_idx]
                        for c in range(TILE_WIDTH):
                            pixel_bit = (byte_val >> (7 - c)) & 1
                            tile_pattern_data[r_idx][c] = pixel_bit
                    temp_loaded_patterns.append(tile_pattern_data)
                    current_byte_offset_pattern += bytes_per_tile_pattern
                
                # Read all color data from file
                bytes_per_tile_colors = TILE_HEIGHT
                total_color_bytes_to_read = tiles_in_file_count * bytes_per_tile_colors
                all_color_data_bytes = f.read(total_color_bytes_to_read)
                if len(all_color_data_bytes) < total_color_bytes_to_read:
                    raise EOFError("EOF while reading color data block from append file.")

                current_byte_offset_colors = 0
                for _i in range(tiles_in_file_count):
                    tile_color_data = [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    tile_color_bytes = all_color_data_bytes[current_byte_offset_colors : current_byte_offset_colors + bytes_per_tile_colors]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        if not (0 <= fg_idx < 16 and 0 <= bg_idx < 16):
                            tile_color_data[r_idx] = (WHITE_IDX, BLACK_IDX) # Default on error
                        else:
                            tile_color_data[r_idx] = (fg_idx, bg_idx)
                    temp_loaded_colors.append(tile_color_data)
                    current_byte_offset_colors += bytes_per_tile_colors

            # File reading successful, now handle append logic
            space_available = MAX_TILES - num_tiles_in_set
            num_to_actually_append = tiles_in_file_count # How many we'd like to append

            if tiles_in_file_count > space_available:
                confirm_partial = messagebox.askyesno(
                    "Tileset Limit Reached",
                    f"The selected file contains {tiles_in_file_count} tiles, "
                    f"but there is only space for {space_available} more tiles in the current project (max {MAX_TILES}).\n\n"
                    f"Do you want to append the first {space_available} tiles from the file?",
                    parent=self.root
                )
                if confirm_partial:
                    num_to_actually_append = space_available
                else:
                    self.debug("User cancelled partial tile append.")
                    return # User cancelled
            
            if num_to_actually_append <= 0: # Handles case where space_available was 0 or became 0
                messagebox.showinfo("Append Tileset", "No space available or no tiles to append.", parent=self.root)
                return

            if self._clear_marked_unused(trigger_redraw=False):
                pass

            self._mark_project_modified()
            
            first_appended_tile_idx = num_tiles_in_set # For selection later

            for i in range(num_to_actually_append):
                # These global lists (tileset_patterns, tileset_colors) are assumed to be
                # already allocated to MAX_TILES length. We are writing into the slots.
                if num_tiles_in_set < MAX_TILES: # Final check within loop
                    tileset_patterns[num_tiles_in_set] = temp_loaded_patterns[i]
                    tileset_colors[num_tiles_in_set] = temp_loaded_colors[i]
                    num_tiles_in_set += 1
                else:
                    # Should not be reached if num_to_actually_append logic is correct
                    self.debug("[DEBUG] append_tileset: Exceeded MAX_TILES during append loop unexpectedly.")
                    break 
            
            current_tile_index = first_appended_tile_idx # Select first appended tile

            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            
            final_message = f"Appended {num_to_actually_append} tile(s) from {os.path.basename(load_path)}."
            if num_to_actually_append < tiles_in_file_count:
                final_message += f"\n({tiles_in_file_count - num_to_actually_append} tiles from file were not appended due to limit.)"
            messagebox.showinfo("Append Successful", final_message, parent=self.root)

        except FileNotFoundError:
            messagebox.showerror("Append Error", f"File not found:\n{load_path}", parent=self.root)
        except (EOFError, ValueError, struct.error) as e:
            messagebox.showerror(
                "Append Tileset Error",
                f"Invalid data or format in tileset file '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )
        except Exception as e:
            messagebox.showerror(
                "Append Tileset Error",
                f"Failed to append tileset from '{os.path.basename(load_path)}':\n{e}",
                parent=self.root
            )

    def _confirm_supertile_import_with_broken_refs(self, parent_dialog, supertile_def_to_render, original_st_index_in_file, num_tiles_actually_staged, original_starting_tile_idx_in_project):
        """
        Placeholder for a dialog that shows a supertile with broken refs and asks for confirmation.
        For now, uses a simpler messagebox.askyesnocancel.
        A proper implementation would render the supertile visually with error masks.

        Args:
            parent_dialog: The parent window for this dialog (e.g., self.root).
            supertile_def_to_render: The 2D list of remapped tile indices (where broken ones are already 0).
            original_st_index_in_file: The index of this supertile in the source file (for user message).
            num_tiles_actually_staged: How many tiles were successfully read from the linked .SC4Tiles.
            original_starting_tile_idx_in_project: The project index where tiles from the pack started.

        Returns:
            str: "import", "skip", or "cancel_all"
        """
        self.debug(f"[DEBUG] Confirming ST import: Original ST index {original_st_index_in_file} from file.")
        # In a full implementation, render supertile_def_to_render here,
        # highlighting cells that were remapped to 0 due to original index T_orig >= num_tiles_actually_staged.

        title = "Supertile Import Confirmation"
        message = (
            f"Supertile {original_st_index_in_file} (from file) references tiles that could not be fully imported "
            f"from its associated tileset (due to project tileset limits).\n\n"
            f"These broken tile references within this supertile have been set to use Project Tile 0.\n\n"
            f"Do you want to import this supertile with these adjustments?"
        )
        
        # Using a custom dialog setup for three distinct return values
        dialog = tk.Toplevel(parent_dialog)
        dialog.title(title)
        dialog.transient(parent_dialog)
        dialog.grab_set()
        dialog.resizable(False, False)

        result = {"action": "cancel_all"} # Default to cancel if window closed

        label = ttk.Label(dialog, text=message, wraplength=400, justify=tk.LEFT)
        label.pack(padx=20, pady=10)

        # TODO: Add visual rendering of the supertile_def_to_render here
        # For now, it's just a text confirmation.
        # Example:
        # preview_canvas = tk.Canvas(dialog, width=self.supertile_grid_width*32, height=self.supertile_grid_height*32, bg="lightgrey")
        # preview_canvas.pack(pady=5)
        # ... logic to draw the supertile_def_to_render onto preview_canvas ...
        # You would need to pass self.supertile_grid_width/height or get them
        # And use logic similar to create_supertile_image, but also indicate broken refs.

        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10, padx=10, fill=tk.X)
        button_frame.grid_columnconfigure(0, weight=1) # For centering buttons
        button_frame.grid_columnconfigure(1, weight=1)
        button_frame.grid_columnconfigure(2, weight=1)


        def set_action(action_val):
            result["action"] = action_val
            dialog.destroy()

        import_button = ttk.Button(button_frame, text="Import This Supertile", command=lambda: set_action("import"))
        import_button.grid(row=0, column=0, padx=5, sticky="ew")

        skip_button = ttk.Button(button_frame, text="Skip This Supertile", command=lambda: set_action("skip"))
        skip_button.grid(row=0, column=1, padx=5, sticky="ew")
        
        cancel_all_button = ttk.Button(button_frame, text="Cancel All Appending", command=lambda: set_action("cancel_all"))
        cancel_all_button.grid(row=0, column=2, padx=5, sticky="ew")

        dialog.bind("<Escape>", lambda e: set_action("cancel_all")) # Escape cancels all

        # Center dialog
        parent_dialog.update_idletasks()
        dialog.update_idletasks()
        px, py, pw, ph = parent_dialog.winfo_rootx(), parent_dialog.winfo_rooty(), parent_dialog.winfo_width(), parent_dialog.winfo_height()
        dw, dh = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
        dialog.geometry(f"{dw}x{dh}+{px + (pw - dw)//2}+{py + (ph - dh)//2}")


        dialog.wait_window()
        return result["action"]

    def append_supertiles_from_file(self):
        global supertiles_data, num_supertiles, tileset_patterns, tileset_colors, num_tiles_in_set # Globals
        global current_supertile_index, current_tile_index # For selection update

        # --- 1. User selects .SC4Super file ---
        st_load_path = filedialog.askopenfilename(
            master=self.root,
            filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
            title="Select Supertile File to Append",
        )
        if not st_load_path:
            return # User cancelled

        # --- 2. Preliminary Checks ---
        # Find associated .SC4Tiles file
        st_dir, st_filename = os.path.split(st_load_path)
        st_basename, _ = os.path.splitext(st_filename)
        tile_load_path = os.path.join(st_dir, f"{st_basename}.SC4Tiles")

        if not os.path.exists(tile_load_path):
            messagebox.showerror("Append Error", 
                                 f"Associated tileset file '{os.path.basename(tile_load_path)}' not found in the same directory. "
                                 "This operation requires it to append supertiles and their referenced tiles together.",
                                 parent=self.root)
            return

        file_st_grid_w, file_st_grid_h, file_st_count = 0,0,0
        file_tile_count = 0

        try: # Read headers to get counts and dimensions
            with open(st_load_path, "rb") as f_st:
                first_count_byte = f_st.read(1)
                if not first_count_byte: raise ValueError("Supertile file empty.")
                indicator = struct.unpack("B", first_count_byte)[0]
                if indicator == 0:
                    count_short_bytes = f_st.read(2)
                    if len(count_short_bytes) < 2: raise EOFError("EOF for ST count.")
                    file_st_count = struct.unpack(">H", count_short_bytes)[0]
                else:
                    file_st_count = indicator
                
                dim_w_byte, dim_h_byte = f_st.read(1), f_st.read(1)
                if not dim_w_byte or not dim_h_byte: raise EOFError("EOF for ST dimensions.")
                file_st_grid_w = struct.unpack("B", dim_w_byte)[0]
                file_st_grid_h = struct.unpack("B", dim_h_byte)[0]
            
            with open(tile_load_path, "rb") as f_tile:
                header_byte = f_tile.read(1)
                if not header_byte: raise ValueError("Tileset file empty.")
                val = struct.unpack("B", header_byte)[0]
                file_tile_count = 256 if val == 0 else val

        except Exception as e:
            messagebox.showerror("Append Error", f"Error reading file headers:\n{e}", parent=self.root)
            return

        if file_st_grid_w != self.supertile_grid_width or file_st_grid_h != self.supertile_grid_height:
            messagebox.showerror("Append Error",
                                 f"Cannot append. Supertile dimensions in file ({file_st_grid_w}x{file_st_grid_h}) "
                                 f"do not match current project's dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}).",
                                 parent=self.root)
            return
        
        if file_st_count == 0:
             messagebox.showinfo("Append Supertiles", "The selected supertile file contains no supertile definitions to append.", parent=self.root)
             return


        # --- 3. Capacity Checks & Overall Confirmation ---
        st_space_available = MAX_SUPERTILES - num_supertiles
        tile_space_available = MAX_TILES - num_tiles_in_set

        if st_space_available <= 0:
            messagebox.showinfo("Append Supertiles", "Current project supertile set is full. Cannot append.", parent=self.root)
            return
        if tile_space_available <= 0 and file_tile_count > 0:
            messagebox.showinfo("Append Supertiles", 
                                "Current project tileset is full. Cannot append required tiles for these supertiles.", 
                                parent=self.root)
            return

        num_st_to_attempt_append = min(file_st_count, st_space_available)
        num_tiles_to_attempt_append_from_file = min(file_tile_count, tile_space_available)

        if num_st_to_attempt_append < file_st_count or num_tiles_to_attempt_append_from_file < file_tile_count:
            warn_msg = "Warning: Project limits will be reached.\n\n"
            if num_tiles_to_attempt_append_from_file < file_tile_count:
                warn_msg += f"Tiles: Will attempt to append {num_tiles_to_attempt_append_from_file} of {file_tile_count} from '{os.path.basename(tile_load_path)}'.\n"
            if num_st_to_attempt_append < file_st_count:
                warn_msg += f"Supertiles: Will attempt to append {num_st_to_attempt_append} of {file_st_count} from '{os.path.basename(st_load_path)}'.\n"
            warn_msg += "\nPartial tile appending may lead to broken references in some supertiles (you will be asked to confirm these individually).\n\nProceed with appending?"
            if not messagebox.askyesno("Confirm Partial Append", warn_msg, parent=self.root):
                self.debug("User cancelled overall partial append.")
                return
        
        if num_st_to_attempt_append == 0 : # Should be caught by st_space_available check, but defensive
            messagebox.showinfo("Append Supertiles", "No supertiles to append after considering limits.", parent=self.root)
            return


        # --- 4. Stage Tile Data (Temporary) ---
        temp_appended_tile_patterns = []
        temp_appended_tile_colors = []
        original_starting_tile_index_in_project = num_tiles_in_set # Current count before appending
        num_tiles_actually_staged_from_file = 0

        if file_tile_count > 0 and num_tiles_to_attempt_append_from_file > 0:
            try:
                with open(tile_load_path, "rb") as f_tile:
                    _ = f_tile.read(1) # Skip header
                    _ = f_tile.read(RESERVED_BYTES_COUNT) # Skip reserved

                    bytes_per_tile_pattern = TILE_HEIGHT
                    all_pattern_bytes = f_tile.read(file_tile_count * bytes_per_tile_pattern)
                    
                    bytes_per_tile_colors = TILE_HEIGHT
                    all_color_bytes = f_tile.read(file_tile_count * bytes_per_tile_colors)

                    if len(all_pattern_bytes) < file_tile_count * bytes_per_tile_pattern or \
                       len(all_color_bytes) < file_tile_count * bytes_per_tile_colors:
                        raise EOFError("Could not read all tile data from linked tileset file.")

                    pat_offset, col_offset = 0,0
                    for i in range(num_tiles_to_attempt_append_from_file): # Only read up to what we attempt
                        tile_pat = [[0]*TILE_WIDTH for _ in range(TILE_HEIGHT)]
                        tile_col = [(WHITE_IDX,BLACK_IDX)]*TILE_HEIGHT
                        
                        # Parse pattern
                        tile_pattern_bytes_slice = all_pattern_bytes[pat_offset : pat_offset + bytes_per_tile_pattern]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_pattern_bytes_slice[r]
                            for c in range(TILE_WIDTH): tile_pat[r][c] = (byte_val >> (7-c)) & 1
                        temp_appended_tile_patterns.append(tile_pat)
                        pat_offset += bytes_per_tile_pattern

                        # Parse colors
                        tile_color_bytes_slice = all_color_bytes[col_offset : col_offset + bytes_per_tile_colors]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_color_bytes_slice[r]
                            fg,bg = (byte_val >> 4)&0xF, byte_val&0xF
                            tile_col[r] = (fg if 0<=fg<16 else WHITE_IDX, bg if 0<=bg<16 else BLACK_IDX)
                        temp_appended_tile_colors.append(tile_col)
                        col_offset += bytes_per_tile_colors
                        num_tiles_actually_staged_from_file +=1
            except Exception as e:
                messagebox.showerror("Append Error", f"Error reading data from linked tileset file '{os.path.basename(tile_load_path)}':\n{e}", parent=self.root)
                return
        self.debug(f"Staged {num_tiles_actually_staged_from_file} tiles for appending.")

        # --- 5. Process Supertile Definitions (Iterative with Per-Supertile Confirmation) ---
        temp_appended_supertile_definitions = []
        supertiles_skipped_count = 0
        operation_fully_cancelled = False

        try:
            with open(st_load_path, "rb") as f_st:
                # Skip headers (already read for counts/dims) and reserved bytes
                _ = f_st.read(1) # ST count byte 1
                if file_st_count >= 256 or (struct.unpack("B",_)[0] == 0 and file_st_count !=0): # Check if it was a 3-byte header
                    _ = f_st.read(2) # ST count bytes 2,3
                _ = f_st.read(1) # ST grid width
                _ = f_st.read(1) # ST grid height
                _ = f_st.read(RESERVED_BYTES_COUNT) # Reserved bytes

                tiles_in_one_def = self.supertile_grid_width * self.supertile_grid_height
                bytes_per_def = tiles_in_one_def # Since tile indices are 1 byte

                for st_file_idx in range(file_st_count): # Iterate all STs in file
                    st_def_bytes = f_st.read(bytes_per_def)
                    if len(st_def_bytes) < bytes_per_def:
                        raise EOFError(f"EOF reading definition for supertile index {st_file_idx} from file.")
                    
                    if st_file_idx >= num_st_to_attempt_append: # Only process up to what we can append
                        break 

                    current_st_def_remapped = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                    has_broken_refs = False
                    byte_ptr = 0
                    for r_st_def in range(self.supertile_grid_height):
                        for c_st_def in range(self.supertile_grid_width):
                            t_orig = st_def_bytes[byte_ptr]
                            byte_ptr += 1
                            t_new = 0
                            if t_orig >= num_tiles_actually_staged_from_file: # Tile it needs wasn't staged
                                has_broken_refs = True
                                t_new = 0 # Default to project tile 0
                            else:
                                t_new = t_orig + original_starting_tile_index_in_project
                            current_st_def_remapped[r_st_def][c_st_def] = t_new
                    
                    if has_broken_refs:
                        user_choice = self._confirm_supertile_import_with_broken_refs(
                            self.root, current_st_def_remapped, st_file_idx, 
                            num_tiles_actually_staged_from_file, original_starting_tile_index_in_project
                        )
                        if user_choice == "import":
                            temp_appended_supertile_definitions.append(current_st_def_remapped)
                        elif user_choice == "skip":
                            supertiles_skipped_count += 1
                        elif user_choice == "cancel_all":
                            operation_fully_cancelled = True
                            break 
                    else: # No broken refs
                        temp_appended_supertile_definitions.append(current_st_def_remapped)
            
            if operation_fully_cancelled:
                self.debug("Append supertiles operation cancelled by user during ST confirmation.")
                messagebox.showinfo("Append Cancelled", "Append operation cancelled.", parent=self.root)
                return

        except Exception as e:
            messagebox.showerror("Append Error", f"Error processing supertile file '{os.path.basename(st_load_path)}':\n{e}", parent=self.root)
            return

        # --- 6. Final Commit ---
        if not temp_appended_tile_patterns and not temp_appended_supertile_definitions:
            messagebox.showinfo("Append Supertiles", "No new tiles or supertiles were ultimately appended.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False): pass
        self._mark_project_modified()

        appended_tiles_actual_count = 0
        if num_tiles_actually_staged_from_file > 0:
            for i in range(num_tiles_actually_staged_from_file):
                if num_tiles_in_set < MAX_TILES:
                    tileset_patterns[num_tiles_in_set] = temp_appended_tile_patterns[i]
                    tileset_colors[num_tiles_in_set] = temp_appended_tile_colors[i]
                    num_tiles_in_set += 1
                    appended_tiles_actual_count +=1
                else: break
        
        appended_st_actual_count = 0
        if temp_appended_supertile_definitions:
            first_new_st_idx_project = num_supertiles
            for st_def in temp_appended_supertile_definitions:
                if num_supertiles < MAX_SUPERTILES:
                    supertiles_data[num_supertiles] = st_def
                    num_supertiles += 1
                    appended_st_actual_count +=1
                else: break
            current_supertile_index = first_new_st_idx_project # Select first new ST

        if appended_tiles_actual_count > 0:
             current_tile_index = original_starting_tile_index_in_project # Select first new Tile

        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        if appended_tiles_actual_count > 0 : self.scroll_viewers_to_tile(current_tile_index)
        if appended_st_actual_count > 0 : self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()

        summary_msg = f"Successfully appended {appended_tiles_actual_count} tile(s) and {appended_st_actual_count} supertile(s)."
        if supertiles_skipped_count > 0:
            summary_msg += f"\n{supertiles_skipped_count} supertile(s) from the file were skipped by user."
        if num_st_to_attempt_append < file_st_count and appended_st_actual_count < num_st_to_attempt_append :
             summary_msg += f"\nNote: Supertile limit prevented appending all desired supertiles from file."
        if num_tiles_to_attempt_append_from_file < file_tile_count and appended_tiles_actual_count < num_tiles_to_attempt_append_from_file:
             summary_msg += f"\nNote: Tileset limit prevented appending all desired tiles from file."

        messagebox.showinfo("Append Successful", summary_msg, parent=self.root)


    def _on_mousewheel_scroll(self, event):
        # Generic handler for mousewheel vertical scrolling on canvases.
        canvas = event.widget
        if not canvas.winfo_exists():
            return

        scroll_units = 0
        if event.num == 5 or event.delta < 0:  # Scroll Down
            scroll_units = self.scroll_speed_units
        elif event.num == 4 or event.delta > 0: # Scroll Up
            scroll_units = -self.scroll_speed_units

        if scroll_units != 0:
            try:
                current_view_before_scroll = canvas.yview() # Get view before scroll
                canvas.yview_scroll(scroll_units, "units")
                current_view_after_scroll = canvas.yview()  # Get view after scroll

                # Only redraw if the view actually changed.
                if current_view_before_scroll != current_view_after_scroll:
                    # Identify the canvas and call its specific redraw method
                    if canvas == self.tileset_canvas:
                        self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
                    elif canvas == self.st_tileset_canvas:
                        self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                    elif canvas == self.supertile_selector_canvas:
                        self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                    elif canvas == self.map_canvas:
                        if not (event.state & 0x0004): # If Ctrl key is NOT pressed (mask for Control is 4)
                            self.draw_map_canvas()
                            self.draw_minimap() 
                    elif canvas == self.map_supertile_selector_canvas:
                        self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
                    elif hasattr(self, 'rom_import_dialog') and \
                         self.rom_import_dialog and \
                         tk.Toplevel.winfo_exists(self.rom_import_dialog) and \
                         canvas == getattr(self.rom_import_dialog, 'canvas', None):
                        self.debug("[DEBUG] Mousewheel scroll on ROM importer, scheduling direct redraw.")
                        self._schedule_debounced_draw_from_scroll_rom_direct()
                else:
                    self.debug(f"[DEBUG] Scroll attempted on {canvas} but view did not change (likely at limit). No redraw triggered.")

            except tk.TclError as e:
                self.debug(f"[DEBUG] TclError during yview_scroll/redraw: {e}")
            except Exception as e:
                self.debug(f"[DEBUG] Unexpected error during yview_scroll/redraw: {e}")
        return "break"

    def _schedule_debounced_draw_from_scroll_rom_direct(self):
        # Helper to schedule the debounced draw for the ROM importer canvas.
        current_dialog = getattr(self, 'rom_import_dialog', None)
        if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
        if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

        if current_dialog.redraw_timer_id is not None:
            try:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            except tk.TclError:
                pass # Timer might have already fired
        current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

    def _calculate_color_usage_data(self):
        # Calculates usage counts for each of the 16 active palette slots.
        # Returns a list of dictionaries, one for each slot.
        global tileset_patterns, tileset_colors, num_tiles_in_set # Using globals

        results = []
        if not self.active_msx_palette or len(self.active_msx_palette) != 16:
            self.debug("[DEBUG] _calculate_color_usage_data: Active MSX palette is not ready or not 16 colors.")
            # Return empty or placeholder data for 16 slots if palette is bad
            for i in range(16):
                results.append({
                    'slot_index': i,
                    'current_color_hex': "#FF00FF", # Error color
                    'pixel_uses_count': 0,
                    'line_refs_count': 0,
                    'tile_refs_count': 0
                })
            return results

        for p_idx in range(16): # For each of the 16 palette slots
            current_color_hex = self.active_msx_palette[p_idx]
            pixel_uses = 0
            line_references = 0
            tile_references_set = set() # To count unique tiles using this p_idx

            for tile_idx in range(num_tiles_in_set):
                tile_uses_this_color_slot = False
                for row_idx in range(TILE_HEIGHT):
                    if tile_idx >= len(tileset_colors) or row_idx >= len(tileset_colors[tile_idx]):
                        # Should not happen if data is consistent
                        continue 
                    
                    fg_slot, bg_slot = tileset_colors[tile_idx][row_idx]
                    line_uses_this_color_slot = False

                    if fg_slot == p_idx:
                        line_references += 1
                        tile_uses_this_color_slot = True
                        line_uses_this_color_slot = True
                    
                    # Check bg_slot, but only add to line_references if fg_slot didn't already count this line
                    if bg_slot == p_idx:
                        tile_uses_this_color_slot = True 
                        if not line_uses_this_color_slot: # Avoid double counting line if both FG/BG use same p_idx
                            line_references += 1
                            line_uses_this_color_slot = True # Mark line as counted for this p_idx

                    # Calculate pixel uses for this line if the p_idx is involved
                    if line_uses_this_color_slot:
                        if tile_idx >= len(tileset_patterns) or row_idx >= len(tileset_patterns[tile_idx]):
                            continue

                        for col_idx in range(TILE_WIDTH):
                            if col_idx >= len(tileset_patterns[tile_idx][row_idx]):
                                continue
                            
                            pixel_pattern_value = tileset_patterns[tile_idx][row_idx][col_idx]
                            if pixel_pattern_value == 1 and fg_slot == p_idx: # FG pixel
                                pixel_uses += 1
                            elif pixel_pattern_value == 0 and bg_slot == p_idx: # BG pixel
                                pixel_uses += 1
                
                if tile_uses_this_color_slot:
                    tile_references_set.add(tile_idx)

            results.append({
                'slot_index': p_idx,
                'current_color_hex': current_color_hex,
                'pixel_uses_count': pixel_uses,
                'line_refs_count': line_references,
                'tile_refs_count': len(tile_references_set)
            })
            
        return results

    def toggle_color_usage_window(self):
        # Toggles the visibility of the Color Usage window.
        if self.color_usage_window is None or not tk.Toplevel.winfo_exists(self.color_usage_window):
            self.debug("[DEBUG] Creating new Color Usage window.")
            self.color_usage_window = ColorUsageWindow(self) # Pass self (the app instance)
            # Optional: Position the window relative to the main app
            self.root.update_idletasks()
            self.color_usage_window.update_idletasks()
            main_x = self.root.winfo_rootx()
            main_y = self.root.winfo_rooty()
            main_w = self.root.winfo_width()
            # main_h = self.root.winfo_height() # Not used here

            cuw_w = self.color_usage_window.winfo_reqwidth()
            # cuw_h = self.color_usage_window.winfo_reqheight() # Not used here
            
            # Position to the right of the main window, aligned with top
            pos_x = main_x + main_w + 10 
            pos_y = main_y
            
            # Basic screen boundary check (adjust if needed for multi-monitor or complex setups)
            screen_w = self.root.winfo_screenwidth()
            if pos_x + cuw_w > screen_w:
                pos_x = screen_w - cuw_w - 10 # Try to fit on the right
            if pos_x < 0 : pos_x = 10 # Fallback if still off screen

            self.color_usage_window.geometry(f"+{pos_x}+{pos_y}")

        else:
            self.debug("[DEBUG] Lifting existing Color Usage window.")
            self.color_usage_window.lift()
            self.color_usage_window.focus_set()
            if hasattr(self.color_usage_window, 'refresh_data'): # If it has a refresh method
                self.color_usage_window.refresh_data() # Refresh when brought to front

# --- Main Execution ---
if __name__ == "__main__":
    import argparse 

    parser = argparse.ArgumentParser(description="MSX Tile Forge - Tile and Map Editor.")
    parser.add_argument("--debug",action="store_true",help="Enable detailed debug console output.")
    args = parser.parse_args()
    
    root = tk.Tk()
    root.withdraw() # Hide main window initially
    root.app_debug_mode = args.debug
    if root.app_debug_mode: print("[INFO] Debug mode enabled via --debug flag.")

    splash_win = tk.Toplevel(root)
    splash_win.overrideredirect(True) # No window decorations
    splash_win.config(cursor="watch")

    splash_after_id = None # To store the ID of the 'after' job

    def destroy_splash_and_show_main():
        # This function is called either by timer or by Esc key
        global splash_after_id
        if tk.Toplevel.winfo_exists(splash_win): # Check if splash window still exists
            if splash_after_id: # If a timer was set
                try:
                    splash_win.after_cancel(splash_after_id) # Try to cancel it
                    print("Splash timer cancelled.")
                except tk.TclError:
                    pass # Timer might have already fired or window gone
            splash_after_id = None
            splash_win.destroy()
        
        if root.winfo_exists(): # Check if root window still exists
            root.deiconify()
            app = TileEditorApp(root) # Create and show the main application
            if hasattr(app, 'debug'): app.debug("[DEBUG] Main application initialized.")

    def handle_splash_escape(event=None): # Added event=None for binding
        print("Escape pressed on splash, skipping.")
        destroy_splash_and_show_main()

    if not SPLASH_IMAGE or not isinstance(SPLASH_IMAGE, str) or len(SPLASH_IMAGE) < 20:
        print("[WARNING] SPLASH_IMAGE is invalid or not defined. Skipping splash image display.")
        if root.winfo_exists():
            splash_after_id = root.after(100, destroy_splash_and_show_main) # Very short delay if no image
        root.bind("<Escape>", handle_splash_escape) 
        raise RuntimeError("Splash image data invalid") # Go to except block for fallback

    image_data = base64.b64decode(SPLASH_IMAGE)
    splash_photo_ref = tk.PhotoImage(data=image_data) # Keep reference directly

    # Frame to hold image and text, to help with centering and layout
    content_frame = ttk.Frame(splash_win)
    content_frame.pack(expand=True, fill='both', padx=1, pady=1) # Add minimal padding if needed

    splash_image_label = ttk.Label(content_frame, image=splash_photo_ref, borderwidth=0)
    splash_image_label.pack(side=tk.TOP, padx=0, pady=0)
    splash_image_label.image = splash_photo_ref # Keep reference on label

    version_text_label = ttk.Label(
        content_frame, 
        text=f"v{APP_VERSION}", 
        font=("Segoe UI", 7), # Small font for version
    )
    version_text_label.pack(side=tk.BOTTOM, pady=(2, 2)) # Small padding below image
    splash_win.update_idletasks()
    req_width = content_frame.winfo_reqwidth()
    req_height = content_frame.winfo_reqheight()
        
    # Ensure positive dimensions, fallback to image size if frame calculation is off
    img_w = splash_photo_ref.width() if splash_photo_ref else 100
    img_h = splash_photo_ref.height() if splash_photo_ref else 50
        
    final_width = max(req_width, img_w, 1) # At least image width, or 1
    final_height = max(req_height, img_h, 1) # At least image height + text, or 1

    screen_width = splash_win.winfo_screenwidth()
    screen_height = splash_win.winfo_screenheight()
    x_pos = (screen_width // 2) - (final_width // 2)
    y_pos = (screen_height // 2) - (final_height // 2)
        
    splash_win.geometry(f'{final_width}x{final_height}+{x_pos}+{y_pos}')

    splash_win.bind("<Escape>", handle_splash_escape)
    splash_win.focus_set() # Give splash window focus to receive Esc key

    if root.winfo_exists():
        splash_after_id = splash_win.after(3000, destroy_splash_and_show_main)
    else: # Root closed before timer set
        if tk.Toplevel.winfo_exists(splash_win): splash_win.destroy()

    root.mainloop()
    